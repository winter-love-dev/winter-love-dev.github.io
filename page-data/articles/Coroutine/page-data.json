{"componentChunkName":"component---src-templates-category-template-js","path":"/articles/Coroutine/","result":{"pageContext":{"currentCategory":"Coroutine","categories":["All","Coroutine","ComposeInternals","Life","Android"],"publicEdges":[{"node":{"id":"3f2ca060-a674-58c5-b6ff-8ec784120d18","excerpt":"취소 기본적인 취소 코루틴을 취소하기 위해 사용되는 예외(exception)은  or 이 예외의 서브 타입이어야 한다. Job 인터페이스는 취소하기 위한  메소드를 가지고 있다. 이 메소드를 호출할 때 호출 시점에 잡을 끝낸다. 잡이 자식을 가지고 있다면, 자식들도 취소된다. 부모는 영향받지 않는다. 취소된 잡은 더이상 코루틴의 부모로 사용될 수 없다. 취소된 잡은  상태가 되었다가  상태로 바뀐다.  메소드도 알고 넘어가자.\n 이 호출된 뒤, 다음 작업을 진행하기 전에  을 호출하면 취소 과정이 완료되는걸 기다리게 된다. 우리는 명시적인  시점을 핸들링 하기 위해  을 사용하는 사례가 많을거다.\n그래서 이 둘을 세트로 호출할 수 있는 확장 함수 를 잘 활용하자.  하위에 생성된 수많은 자식 잡을 한 번에 취소할 수 있다는 점도 알고 가자. 취소는 어떻게 작동하는가?  이 취소되면  상태로 바뀐다. 상태가 바뀐 뒤, 첫 번 째 중단점에서  예외를 던진다. 예외는  로 잡을 수도 있…","fields":{"slug":"/coroutine-deep-dive/3-coroutine-cancel-exception-scope/"},"frontmatter":{"categories":"Coroutine","title":"코루틴 빌더, 컨텍스트, 잡과 자식 코루틴 기다리기 (Coroutine DEEP DIVE)","date":"2026.02.09","private":false}},"next":{"fields":{"slug":"/coroutine-deep-dive/2-coroutine-builder-context-job-and-wait-children/"}},"previous":null},{"node":{"id":"de5557fe-3243-5d29-8bd9-e0f4eaa98089","excerpt":"러프하게 초안 정리 상태 코루틴 빌더 중단 함수는 컨티뉴에이션 객체를 다른 중단 함수로 전달해야 한다.\n(4장에서 다뤘는데, 중단 함수들의 콜스택과 연결되는 개념이다) 그래서 일반 함수가 중단 함수를 호출 할수는 없지만\n중단 함수는 일반 함수를 실행할 수 있다. 우리는 지금까지\n중단 함수는 코루틴을 실행할 수 있으며\n코루틴은 함수를 일시중단 할 수 있다고 배웠다. 그렇다면 중단 함수는 처음에 어떻게 실행 되는가?\n이것을 시작하는 지점이 코루틴 빌더다. 계층으로 표현해본다면 이런 느낌? 코루틴 빌더 중단 함수 or 코루틴 launch 빌더 새로운 일시중단 가능한 분기를 생성한다.\nlaunch 는 몇 번이든 호출하여 새로운 분기를 만들 수 있다. runBlocking 빌더 이 빌더가 실행된 스레드가 중단된다. async 빌더 비동기 태스크를 async 블록으로 감싸면 비동기 태스크가 실행되며 Deferred 타입을 반환한다.\ndeferred 객체의 await() 을 호출하면 결과 값을…","fields":{"slug":"/coroutine-deep-dive/2-coroutine-builder-context-job-and-wait-children/"},"frontmatter":{"categories":"Coroutine","title":"코루틴 취소, 예외처리, 스코프 함수 (Coroutine DEEP DIVE)","date":"2026.02.08","private":false}},"next":{"fields":{"slug":"/coroutine-deep-dive/1-understnad-kotlin-coroutine/"}},"previous":{"fields":{"slug":"/coroutine-deep-dive/3-coroutine-cancel-exception-scope/"}}},{"node":{"id":"1c1bcd09-5227-54b1-bfaa-f902533444d4","excerpt":"본문에서 자주 사용하는 단축어 정의: cont: Continuation 객체의 줄임말.\n코드에서는  또는 으로 표기될 수 있음. 코틀린 코루틴을 배워야 하는 이유 안드로이드에선 UI를 다루는 스레드가 하나만 존재한다.\nRestAPI 를 호출해서 데이터를 불러오고, 이를 UI 에 보여주기까지의 과정을 생각해보자. 스레드 전환:\n스레드에서 RestAPI 호출 후,  를 통해 UI 스레드로 전환하는 방법이 있다.\n하지만 스레드가 실행 되었을때 멈출수 있는 방법이 없어 메모리 누수로 이어질 수 있다.\n스레드를 많이 생성하면 비용이 많이 들기도 하고, 코드가 길어지고 이해하기 어려워지는 문제도 있다. 콜백:\n대안으로 콜백 활용을 생각해볼 수 있다.\n취소할 수는 있지만 매우 번거로워서 쉽지 않은 일이다.\n그리고 여러번 중첩되어 사용되는 패턴인 “콜백 지옥”이 형성되어 읽기 어려운 코드가 될 수 있다. RxJava & 리액티브 스트림:\n오랫동안 자바 진영에서 인기있는 해결책은 RxJava, 리…","fields":{"slug":"/coroutine-deep-dive/1-understnad-kotlin-coroutine/"},"frontmatter":{"categories":"Coroutine","title":"코틀린 코루틴 이해하기 (Coroutine DEEP DIVE)","date":"2026.02.01","private":false}},"next":{"fields":{"slug":"/composeinternals/3-the-compose-runtime/"}},"previous":{"fields":{"slug":"/coroutine-deep-dive/2-coroutine-builder-context-job-and-wait-children/"}}}]}},"staticQueryHashes":["1073350324","1321836341","339315159"],"slicesMap":{}}
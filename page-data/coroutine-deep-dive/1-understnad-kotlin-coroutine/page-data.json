{"componentChunkName":"component---src-templates-content-template-js","path":"/coroutine-deep-dive/1-understnad-kotlin-coroutine/","result":{"data":{"cur":{"id":"1c1bcd09-5227-54b1-bfaa-f902533444d4","html":"<p>본문에서 자주 사용하는 단축어 정의:</p>\n<blockquote>\n<p>cont: Continuation 객체의 줄임말.\n코드에서는 <code class=\"language-text\">cont</code> 또는 <code class=\"language-text\">continuation</code>으로 표기될 수 있음.</p>\n</blockquote>\n<hr>\n<h1 id=\"코틀린-코루틴을-배워야-하는-이유\" style=\"position:relative;\"><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"코틀린 코루틴을 배워야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코틀린 코루틴을 배워야 하는 이유</h1>\n<p>안드로이드에선 UI를 다루는 스레드가 하나만 존재한다.\nRestAPI 를 호출해서 데이터를 불러오고, 이를 UI 에 보여주기까지의 과정을 생각해보자.</p>\n<p><strong>스레드 전환:</strong>\n스레드에서 RestAPI 호출 후, <code class=\"language-text\">runOnUiThread { ... }</code> 를 통해 UI 스레드로 전환하는 방법이 있다.\n하지만 스레드가 실행 되었을때 멈출수 있는 방법이 없어 메모리 누수로 이어질 수 있다.\n스레드를 많이 생성하면 비용이 많이 들기도 하고, 코드가 길어지고 이해하기 어려워지는 문제도 있다.</p>\n<p><strong>콜백:</strong>\n대안으로 콜백 활용을 생각해볼 수 있다.\n취소할 수는 있지만 매우 번거로워서 쉽지 않은 일이다.\n그리고 여러번 중첩되어 사용되는 패턴인 “콜백 지옥”이 형성되어 읽기 어려운 코드가 될 수 있다.</p>\n<p><strong>RxJava &#x26; 리액티브 스트림:</strong>\n오랫동안 자바 진영에서 인기있는 해결책은 RxJava, 리액티브 스트림이 있다.\n이 방법은 스트림 내에서 일어나는 모든 연산을 시작, 처리 관찰할 수 있다.\n스레드 전환과 동시성 처리를 지원하기 때문에 애플리케이션 내의 연산을 병렬 처리할 수 있다.\n취소가 가능, 메모리 누수가 없어서 스레드를 적절하게 사용할 수 있다.\n단점이 있다면 구현하기 아주 복잡하다는 것이다.</p>\n<p><strong>코틀린 코루틴 사용:</strong>\n핵심은 코루틴을 특정 지점에서 멈추고, 이후에 재개할 수 있다는 것.\n코루틴을 사용하면 UI 스레드 블로킹 없이 중단 지점을 만들고 API 에서 데이터를 불러올 수 있다.\nAPI 를 불러온 뒤, 중단한 지점에서 다시 시작하여 UI 를 업데이트 할 수 있다.</p>\n<p>코루틴 중단 함수 안에선 비동기 코드를 마치 동기 코드처럼 순차적으로 작성할 수 있다.\n또는 비동기 코드를 병렬로 실행하여 (<code class=\"language-text\">async { }</code>, <code class=\"language-text\">await()</code>) 호출 결과를 더 빨리 받아볼 수 있다.\n이 모든것을 읽기 쉬운 간단한 코드로 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">showNews</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  viewModelScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> config <span class=\"token operator\">=</span> async <span class=\"token punctuation\">{</span> <span class=\"token function\">getConfigFromApi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">val</span> news <span class=\"token operator\">=</span> async <span class=\"token punctuation\">{</span> <span class=\"token function\">gerNewsFromApi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> async <span class=\"token punctuation\">{</span> <span class=\"token function\">gerUserFromApi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    view<span class=\"token punctuation\">.</span><span class=\"token function\">showNews</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span> news<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>코루틴을 사용하면를 스레드를 재우는 대신 “코루틴”을 중단 시킨다.\n코루틴을 시작하는 비용은 스레드와 비교되지 않을만큼 저렴하다.</p>\n<h2 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h2>\n<p>코루틴은 스레드를 블로킹 하지 않고 중단 지점을 만들어서 비동기 로직을 실행한 뒤, 중단 지점에서 로직을 재개할 수 있다.\n이 동작은 어떤 비동기 로직 실행 방법보다 읽기 쉽게 작성할 수 있다.\n중단 함수는 취소가 가능하며, 스레드보다 비용이 적게 든다.</p>\n<p>추가 장점: 멀티플랫폼에서도 사용할 수 있다.</p>\n<h1 id=\"시퀀스-빌더\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%ED%80%80%EC%8A%A4-%EB%B9%8C%EB%8D%94\" aria-label=\"시퀀스 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시퀀스 빌더</h1>\n<p>코틀린에서는 제너레이터 대신 시퀀스를 생성할 때 사용하는 시퀀스 빌더를 제공한다.\n시퀀스 빌더는 필요할 때마다 값을 하나씩 계산하는 지연 처리를 한다.\n때문에 요구되는 연산을 최소한으로 수행해서 메모리 사용이 효율적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> seq <span class=\"token operator\">=</span> sequence <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>num <span class=\"token keyword\">in</span> seq<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 123</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 알아야 할것은 각 숫자가 미리 생성되는 대신, 필요할 때마다 생성된다는 점이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> seq <span class=\"token operator\">=</span> requence <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Generating first\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Generating second\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Generating third\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">yeild</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Done\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>num <span class=\"token keyword\">in</span> seq<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"The next number is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">num</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Generating first</span>\n<span class=\"token comment\">// The next number is 1</span>\n<span class=\"token comment\">// Generating second</span>\n<span class=\"token comment\">// The next number is 2</span>\n<span class=\"token comment\">// Generating third</span>\n<span class=\"token comment\">// The next number is 3</span>\n<span class=\"token comment\">// Done</span></code></pre></div>\n<p>시퀀스의 작동 방식에 대해 알아보자.\n“Generating first” 를 출력한 뒤 -> 숫자 1을 반환한다.\n이후 반복문에서 반환된 값을 반은 뒤 -> “Next number is 1”을 출력한다.\n여기서 반복문과 다른 점을 알아야 한다.</p>\n<p>main: <code class=\"language-text\">val num = seq.next()</code></p>\n<p>seq: <code class=\"language-text\">println(\"Generating first\")</code></p>\n<p>seq: <code class=\"language-text\">yeild(1)</code> &#x3C;- 1 반환</p>\n<p>main <code class=\"language-text\">println(\"The next number is $num\")</code> &#x3C;- 중단 후 시퀀스에서 반환한 값 1 출력</p>\n<p>main: <code class=\"language-text\">val num = seq.next()</code> &#x3C;- 중단 지점에서 시퀀스 다시 재개</p>\n<p>seq: <code class=\"language-text\">println(\"Generating second\")</code> &#x3C;- 중단 지점으로부터 다음 메시지 출력</p>\n<p>seq: <code class=\"language-text\">yeild(2)</code> &#x3C;- 2 반환</p>\n<p>main <code class=\"language-text\">println(\"The next number is $num\")</code> &#x3C;- 다시 중단 후 시퀀스에서 반환한 값 2 출력</p>\n<p>…</p>\n<p><strong>중단이 왜 필요한가?</strong>\n위 예시 패턴처럼, 중단이 가능하기 때문에 main 함수와 시퀀스 제너레이터가 번갈아가면서 실행될 수 있기 때문이라고 한다.</p>\n<p>시퀀스 빌더는 반환(yield)이 아닌 중단 함수를 사용하면 안 된다.\n중단이 필요하다면 데이터를 가져오기 위해 나중에 배울 플로우를 사용하는 것이 낫다.\n플로우 빌더가 작동하는 방식은 시퀀스 빌더와 비슷하지만, 플로우는 여러가지 코루틴 기능을 지원한다고 한다.</p>\n<p>다음 장에서 중단이 어떻게 작동하는지 살펴보자.</p>\n<h1 id=\"중단은-어떻게-작동할까\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%8B%A8%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%A0%EA%B9%8C\" aria-label=\"중단은 어떻게 작동할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중단은 어떻게 작동할까?</h1>\n<p>중단 함수는 코틀린 코투린의 핵심이다.\n코투린을 중단한다는 건 실행을 중간에 멈추는것을 의미한다.\n비디오 게임을 하다 멈추는 상황과 비슷하다.</p>\n<p>코루틴은 중단 되었을 때 cont 객체를 반환한다.\n이 객체는 게임을 저장하는 것과 비슷하다.\ncont 를 이용하면 멈췄던 곳에서 다시 코루틴을 실행할 수 있다.\n다른 스레드에서 시작할 수 있다.\n중단했을 때 코루틴은 어떤 자원도 사용하지 않는다.</p>\n<h2 id=\"재개\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B0%9C\" aria-label=\"재개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재개</h2>\n<p>코루틴은 <code class=\"language-text\">runBlocking</code> 이나 <code class=\"language-text\">launch</code> 와 같은 코루틴 빌더를 통해 만들 수 있다. </br>\n중단 함수 코루틴을 중단할 수 있는 함수다. </br>\n중단 함수는 반드시 코루틴 혹은 다른 중단 함수에 의해 호출 되어야 한다. </br>\n중단 함수는 중단할 수 있는곳이 필요하다. </br></p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n  suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span></code></pre></div>\n<p>Before 와 After 사이에 중단을 하는 예시다.\n위 결과처럼 After 는 출력되지 않으며 코드는 실행된 상태로 유지된다.\nmain 함수가 끝나지 않았기 때문.\n프로그램은 멈춘채 재개되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n  suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n    cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span>\n<span class=\"token comment\">// After</span></code></pre></div>\n<p>cont 객체를 사용해서 코루틴을 중단한 후 곧바로 실행할 수 있다.\ncont 에서 resume 을 호출했기 때문에 After 를 호출할 수 있게 되었다.</p>\n<blockquote>\n<p>코틀린 1.3 이후부턴 <code class=\"language-text\">resumeWith()</code> 함수만 사용할 수 있다고 한다.</p>\n</blockquote>\n<p>suspendScope 에서 잠깐 동안 정지(sleep)된 뒤 재개되는 다른 스레드를 실행할수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n  suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> continuation <span class=\"token operator\">-></span>\n      thread <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Suspended\"</span></span><span class=\"token punctuation\">)</span>\n          Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n          continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">)</span>\n          <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Resume\"</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span>\n<span class=\"token comment\">// Suspended</span>\n<span class=\"token comment\">// (1초 후)</span>\n<span class=\"token comment\">// After</span>\n<span class=\"token comment\">// Resumed</span></code></pre></div>\n<p>위 예제로부터 다른 스레드가 재개하는 방식은 코투린을 이해하는데 중요하다.</p>\n<h2 id=\"값으로-재개하기\" style=\"position:relative;\"><a href=\"#%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%9E%AC%EA%B0%9C%ED%95%98%EA%B8%B0\" aria-label=\"값으로 재개하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>값으로 재개하기</h2>\n<p>suspend 함수에 기본적으로 Unit 을 인자로 넘길수 있고, 객체로 반환될 값의 타입을 지정할수도 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// Unit 을 인자로 넘기는 경우</span>\n<span class=\"token keyword\">val</span> ret<span class=\"token operator\">:</span> Unit <span class=\"token operator\">=</span> \n  suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token operator\">-></span>\n    cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// 특정 타입을 인자로 넘기는 경우</span>\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> ret<span class=\"token operator\">:</span> Unit <span class=\"token operator\">=</span> \n      \n  <span class=\"token keyword\">val</span> i<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n    cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 42</span>\n  \n  <span class=\"token keyword\">val</span> str<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n    cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Some text\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Some tex</span>\n\n  <span class=\"token keyword\">val</span> b<span class=\"token operator\">:</span> Boolean <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>Boolean<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n      cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>RestAPI 호출에서 응용하는 방법.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    requestUser <span class=\"token punctuation\">{</span> user <span class=\"token operator\">-></span>\n      cont<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>    \n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span>\n<span class=\"token comment\">// (1초 후)</span>\n<span class=\"token comment\">// User(name=Test)</span>\n<span class=\"token comment\">// After</span></code></pre></div>\n<h2 id=\"예외로-재개하기\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%99%B8%EB%A1%9C-%EC%9E%AC%EA%B0%9C%ED%95%98%EA%B8%B0\" aria-label=\"예외로 재개하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예외로 재개하기</h2>\n<p>우리가 사용하는 모든 함수는 값을 반환하거나 예외를 던진다. suspendCoroutine 또한 마찬가지.</p>\n<p>보통 네트워크 관련 예외를 알릴 때 사용할 수 있다.</p>\n<p><code class=\"language-text\">resume()</code> 호출:  인자로 들어온 데이터를 반환한다. </br>\n<code class=\"language-text\">resumeWithException()</code> 호출: 중단된 지점에서 인자로 넣어준 예외를 던진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> MyException <span class=\"token operator\">:</span> <span class=\"token function\">Throwable</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Just an exception\"</span></span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n      cont<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span><span class=\"token function\">MyException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> MyExeption<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Caught!\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Caught!</span></code></pre></div>\n<h2 id=\"함수가-아닌-코루틴을-중단시킨다\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98%EA%B0%80-%EC%95%84%EB%8B%8C-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%84-%EC%A4%91%EB%8B%A8%EC%8B%9C%ED%82%A8%EB%8B%A4\" aria-label=\"함수가 아닌 코루틴을 중단시킨다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수가 아닌 코루틴을 중단시킨다</h2>\n<p>함수가 아닌 코루틴을 중단하는 것.\n중단 함수는 코루틴이 아니다.\n중단 함수는 코루틴을 중단할 수 있는 함수라고 한다.</p>\n<p>아래 예시를 보자. 이 이예시는 의도와 달리 종료되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">var</span> continuatino<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span><span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">suspendAndSetContinuation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  suspendCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n    continuation <span class=\"token operator\">=</span> cont\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n    \n  <span class=\"token function\">suspendAndSetContinuation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  continuation<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">)</span>\n    \n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>After<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span></code></pre></div>\n<p>여기서 resume() 은 호출되지 않는다.\n다른 스레드나 다른 코루틴으로 재개하지 않으면 프로그램은 실행된 상태로 유지된다.</p>\n<p>이 섹션의 첫 내용을 다시 상기하며 개념 정리: </br>\n<strong>코루틴, 코루틴 스코프:</strong> 둘 다 코루틴을 지칭한다. </br>\n<strong>중단 함수:</strong> 코루틴을 중단할 수 있는 함수다.</p>\n<blockquote>\n<p>중단 함수는 코루틴을 실행 시킬수 있는 함수.</p>\n</blockquote>\n<blockquote>\n<p>코루틴은 일시 중단과 재개를 시킬 수 있다.</p>\n</blockquote>\n<h1 id=\"코루틴의-실제-구현\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B5%AC%ED%98%84\" aria-label=\"코루틴의 실제 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴의 실제 구현</h1>\n<ul>\n<li>\n<p>중단 함수가 상태를 가지는 시점: 함수가 시작할때와 중단 함수가 호출 되었을때.\n이렇듯, 중단 함수가 상태를 가진다는 점에서 상태 머신 (state machine) 과 비슷하다.</p>\n</li>\n<li>\n<p>cont 객체는 상태를 나타내는 숫자와 로컬 데이터를 가지고 있다.</p>\n</li>\n<li>\n<p>호출된 함수의 cont 는 호출한 함수의 cont 를 감싸면서 체인을 형성한다.\n이 체인이 코루틴의 콜 스택 역할을 한다 — 함수가 끝나면 이 체인을 따라 되돌아간다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">호출 순서<span class=\"token operator\">:</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Continuation 체인</span>\nc<span class=\"token punctuation\">.</span>cont <span class=\"token operator\">-></span> b<span class=\"token punctuation\">.</span>cont <span class=\"token operator\">-></span> a<span class=\"token punctuation\">.</span>cont <span class=\"token comment\">// 각각 이전 호출자를 참조</span>\n\n<span class=\"token comment\">// 반환 순서</span>\nc 완료 → b resume → b 완료 → a resume → a 완료</code></pre></div>\n</li>\n</ul>\n<h2 id=\"컨티뉴에이션-전달-방식\" style=\"position:relative;\"><a href=\"#%EC%BB%A8%ED%8B%B0%EB%89%B4%EC%97%90%EC%9D%B4%EC%85%98-%EC%A0%84%EB%8B%AC-%EB%B0%A9%EC%8B%9D\" aria-label=\"컨티뉴에이션 전달 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컨티뉴에이션 전달 방식</h2>\n<p>중단 함수는 여러 방식으로 구현할 수 있다.\n코틀린 팀은 <strong>컨티뉴에이션 전달 방식</strong>(continuation-passing style)을 택했다고 한다.</p>\n<p>컨티뉴에이션은 함수에서 함수로 파라미터를 통해 전달된다.\n관례상 컨티뉴에이션은 마지막 파라미터로 정렬 한다고 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> User<span class=\"token operator\">?</span>\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">checkAvailability</span><span class=\"token punctuation\">(</span>flight<span class=\"token operator\">:</span> Flight<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span> Continuatoin<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any<span class=\"token operator\">?</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span>\n  user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">,</span> \n  continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any\n<span class=\"token keyword\">fun</span> <span class=\"token function\">checkAvailability</span><span class=\"token punctuation\">(</span>\n  flight<span class=\"token operator\">:</span> Flight<span class=\"token punctuation\">,</span>\n  continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any</code></pre></div>\n<p>중단 함수 내부를 들여다보면 원래 선언했던 형태와 반환 타입이 Any 또는 Any? 로 바뀌었다.\n그 이유는, 중단 함수를 실행하는 도중에 중단되면 선언된 타입의 값을 반환하지 않을수 있기 때문이라고 한다.\n이때 중단 함수는 <code class=\"language-text\">COROUTINE_SUSPENDED</code>라는 특별한 마커를 반환한다.</p>\n<p>지금은 <code class=\"language-text\">getUser()</code> 함수가 <code class=\"language-text\">User?</code> or <code class=\"language-text\">COROUTINE_SUSPENDED</code> 를 반환할 수 있기 때문에,\n이 결과와 가장 가까운 슈퍼 타입인 <code class=\"language-text\">Any?</code> 로 지정된 것이다.</p>\n<h2 id=\"아주-간단한-함수\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%A3%BC-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%95%A8%EC%88%98\" aria-label=\"아주 간단한 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아주 간단한 함수</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 중단 함수</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">myFunction</code> 함수의 시그니처(signature)를 다음과 같이 추론할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any</code></pre></div>\n<p>이번에 알아볼 것은, 이 함수는 상태를 저장하기 위해 자신만의 cont 객체가 필요할것이다.\n이 상태명을 <code class=\"language-text\">MyFunctionContinuation</code> 이라고 가정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">val continuation = MyFunctionContinuation(continuation)</code></pre></div>\n<p><code class=\"language-text\">myFunction</code> 함수가 실행될 때 파라미터인 continuation 을 자신만의 컨티뉴에이션인 <code class=\"language-text\">MyFunctionContinuation</code> 으로 포장한다.</p>\n<p>이미 래핑된 컨티뉴에이션이면 그대로 두고, 아니면 새로 래핑한다.\n만약 코루틴이 재실행되고 있으면 컨티뉴에이션 객체는 이미 래핑되어 있을것이므로 컨티뉴에이션 객체를 그대로 둬야한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> continuation <span class=\"token operator\">=</span> \n    continuation <span class=\"token keyword\">as</span><span class=\"token operator\">?</span> MyFunctionContinuation \n    <span class=\"token operator\">?:</span> <span class=\"token function\">MyFunctionContinuation</span><span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">myFunction</code> 함수가 시작되는 지점은 함수의 시작점과 중단 이후 재개 시점 두 곳이다.\n현재 상태를 저장하려면 <code class=\"language-text\">label</code> 이라는 필드를 사용한다.\n함수가 처음 시작할 때 이 <code class=\"language-text\">label</code> 값은 0으로 설정된다.\n이후 중단되기 전에 다음 상태로 설정되어 코루틴이 재개될 시점을 알 수 있게 도와준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// myFunction 의 세부 구현을 간단하게 표현한 예시</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> continuation <span class=\"token operator\">=</span> continuation <span class=\"token keyword\">as</span><span class=\"token operator\">?</span> MyFunctionContinuation\n      <span class=\"token operator\">?:</span> <span class=\"token function\">MyFunctionContinuation</span><span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">)</span>\n      \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">.</span>label <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n      continuation<span class=\"token punctuation\">.</span>label <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> continuation<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> COROUTINE_SUSPEND<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> COROUTINE_SUSPEND\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">.</span>label <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> Unit\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Impossible\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에 중요한 부분이 있다.\n<code class=\"language-text\">delay</code> 에 의해 중단된 경우, <code class=\"language-text\">delay</code> 로부터 <code class=\"language-text\">COROUTINE_SUSPEND</code> 가 반환된다.\n<code class=\"language-text\">myFunction</code> 은 <code class=\"language-text\">COROUTINE_SUSPEND</code>를 반환한다.\n<code class=\"language-text\">myFunction</code>을 호출한 함수부터 시작해 콜 스택에 있는 모든 함수도 똑같다.</p>\n<p>즉, 중단이 일어나면 콜 스택에 있는 모든 함수가 <code class=\"language-text\">COROUTINE_SUSPEND</code> 를 반환 받으며,\n결과적으로 아래와 같이 중단된 코루틴의 실행이 종료된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n    \n  <span class=\"token comment\">// 여기서 중단되면 main도 COROUTINE_SUSPENDED 반환</span>\n  <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n    \n  <span class=\"token comment\">// 재개후 실행됨</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// Before</span>\n<span class=\"token comment\">// After</span></code></pre></div>\n<p>중단된 코루틴을 실행하던 스레드를 실행 가능한 코드가 사용할 수 있게된다.</p>\n<blockquote>\n<p>만약 <code class=\"language-text\">delay</code> 호출이 <code class=\"language-text\">COROUTINE_SUSPEND</code>를 반환하지 않고 <code class=\"language-text\">Unit</code>을 반환하면 어떻게 될까?\n그냥 중단 없이 다음 코드로 넘어가는 일반적인 함수 호출이 된다.</p>\n</blockquote>\n<p>다음으로 컨티뉴에이션 객체다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">cont <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> <span class=\"token function\">ContinuatoinIm</span><span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> result<span class=\"token operator\">:</span> Any<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">var</span> label <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  \n  <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">invokeSuspend</span><span class=\"token punctuation\">(</span>`$result`<span class=\"token operator\">:</span> Any<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> `$result`<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"상태를-가진-함수\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%83%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%ED%95%A8%EC%88%98\" aria-label=\"상태를 가진 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상태를 가진 함수</h2>\n<p>함수가 중단된 후 다시 사용할 지역 변수나 파라미터같은 상태를 가지고 있다면,\n함수의 컨티뉴에이션 객체에 상태를 저장해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">myFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>\"Before<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">var</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 중단 함수</span>\n  counter<span class=\"token operator\">++</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>\"Counter<span class=\"token operator\">:</span> $counter<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>\"After<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>counter 는 0 과 1로 표시된 두 상태에서 사용되므로 컨티뉴에이션을 통해 이를 저장해야 한다.\n함수 내에 사용되던 값들은 중단 직전에 저장되고, 이후 함수가 재개될 때 복구된다.</p>\n<h2 id=\"값을-받아-재개되는-함수\" style=\"position:relative;\"><a href=\"#%EA%B0%92%EC%9D%84-%EB%B0%9B%EC%95%84-%EC%9E%AC%EA%B0%9C%EB%90%98%EB%8A%94-%ED%95%A8%EC%88%98\" aria-label=\"값을 받아 재개되는 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>값을 받아 재개되는 함수</h2>\n<p>중단 함수로부터 값을 받아야 하는 경우는 좀 더 복잡하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">printUser</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Before\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> userId <span class=\"token operator\">=</span> <span class=\"token function\">getUserId</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 중단 함수</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Got userId: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userId</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> userName <span class=\"token operator\">=</span> <span class=\"token function\">getUserName</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 중단 함수</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">User</span><span class=\"token punctuation\">(</span>userId<span class=\"token punctuation\">,</span> userName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"After\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">getUserId</code> 와  <code class=\"language-text\">getUserName</code> 이라는 두 가지 중단 함수가 있다.\ntoken 이라는 파라미터를 받으면 중단 함수는 특정 값을 반환한다.</p>\n<p>함수가 재개되었다면 결과는 <code class=\"language-text\">Result.Success(value)</code> 가 되며, 이 값을 얻어 사용할 수 있다.\n함수가 예외로 재개되었다면 결과는 <code class=\"language-text\">Result.Failuer(exception)</code> 이 되며 이 때는 예외를 던진다.</p>\n<h2 id=\"콜스택\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EC%8A%A4%ED%83%9D\" aria-label=\"콜스택 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜스택</h2>\n<p>코루틴을 재개할 때 콜 스택을 사용할수는 없다.\n코루틴을 중단하면 스레드를 반환해 콜스택에 있는 정보가 사라지니까.\n그래서 컨티뉴에이션 객체가 콜 스택의 역할을 대신 한다.</p>\n<p>서두에서 언급했듯  호출된 함수의 cont 는 호출한 함수의 cont 를 감싸면서 체인을 형성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">호출 순서<span class=\"token operator\">:</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Continuation 체인</span>\nc<span class=\"token punctuation\">.</span>cont <span class=\"token operator\">-></span> b<span class=\"token punctuation\">.</span>cont <span class=\"token operator\">-></span> a<span class=\"token punctuation\">.</span>cont <span class=\"token comment\">// 각각 이전 호출자를 참조</span>\n\n<span class=\"token comment\">// 반환 순서</span>\nc 완료 → b resume → b 완료 → a resume → a 완료</code></pre></div>\n<h2 id=\"중단-함수의-성능\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%8B%A8-%ED%95%A8%EC%88%98%EC%9D%98-%EC%84%B1%EB%8A%A5\" aria-label=\"중단 함수의 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중단 함수의 성능</h2>\n<p>일반적인 함수 대신 중단 함수를 사용하면 비용은 어떻게 될까?\n코루틴 내부 구현을 보면 비용이 클 거라 생각하겠지만 실제로는 그렇지 않다.\n지역변수를 복사하지 않고 새로운 변수가 메모리 내 특정 값을 가리키게 한다.\n컨티뉴에이션 객체를 생성할 때 비용이 어느정도 들지만, 마찬가지로 큰 문제는 아니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqElEQVR42r2Syy8DURTGB30/EAsSgrCoRCxEWNkQia1FN1hIENV2HpogHiFWQhCxUlSIEGlR2umLir1qIwQL/Cno595pOy0bkYhJvpybme/+zplzDqPjAvhLMf8GVHMhqNJScmFJGi74M1DDijAKQej57EstuVjKH6NK8KCCP0K14EYl70YJfwaDEJL9BhIL6TkXuBB5Qf6wD0Vpk54ToWJDaHDso4nbQKOwjRZuHa0jTgL3gLGIUFh9kldt96PA6gctSgaCPPPhZzCDpzAQE81OL3SsxdC7ew/L4SMGDp7QunIN82YC3Vs36HHF0b97C7Mzhr6dBGqmogQuSkmY948kvkNpprLRMEwzUdQR0Vg+HoFp9hK101FY9u9gP3xAlzMOwfOI+rkrKG3+FJDiMtDF8xcwQ2cSVMsGoCAmhTUlWgGN+VYRzRMetE/soW3Mhc7JHVQ4TqFmU72UfjkXunTxKkOp9BlxAXlwWhv5bvOi2H4Co90LHev/2kMJmkzK0NXLV+RZfGTagS8TzCoobYKGrBSVLmedZGAKCrylocukUhVt9C8X+xMldRJz1E6XrgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/4b408a31e407236aee179777c392489b/37523/cover.png\"\n        srcset=\"/static/4b408a31e407236aee179777c392489b/e9ff0/cover.png 180w,\n/static/4b408a31e407236aee179777c392489b/f21e7/cover.png 360w,\n/static/4b408a31e407236aee179777c392489b/37523/cover.png 720w,\n/static/4b408a31e407236aee179777c392489b/0a867/cover.png 986w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","excerpt":"본문에서 자주 사용하는 단축어 정의: cont: Continuation 객체의 줄임말.\n코드에서는  또는 으로 표기될 수 있음. 코틀린 코루틴을 배워야 하는 이유 안드로이드에선 UI를 다루는 스레드가 하나만 존재한다.\nRestAPI 를 호출해서 데이터를 불러오고, 이를 UI 에 보여주기까지의 과정을 생각해보자. 스레드 전환:\n스레드에서 RestAPI 호출 후,  를 통해 UI 스레드로 전환하는 방법이 있다.\n하지만 스레드가 실행 되었을때 멈출수 있는 방법이 없어 메모리 누수로 이어질 수 있다.\n스레드를 많이 생성하면 비용이 많이 들기도 하고, 코드가 길어지고 이해하기 어려워지는 문제도 있다. 콜백:\n대안으로 콜백 활용을 생각해볼 수 있다.\n취소할 수는 있지만 매우 번거로워서 쉽지 않은 일이다.\n그리고 여러번 중첩되어 사용되는 패턴인 “콜백 지옥”이 형성되어 읽기 어려운 코드가 될 수 있다. RxJava & 리액티브 스트림:\n오랫동안 자바 진영에서 인기있는 해결책은 RxJava, 리…","frontmatter":{"date":"2026.02.01","title":"코틀린 코루틴 이해하기 (Coroutine DEEP DIVE)","categories":"Coroutine","author":"Winter","emoji":null,"thumbnail":{"publicURL":"/static/4b408a31e407236aee179777c392489b/cover.png"},"articleDescription":null,"articleKeywords":null,"articleModifiedDate":null},"fields":{"slug":"/coroutine-deep-dive/1-understnad-kotlin-coroutine/"}},"next":{"id":"6fe9521a-0f0a-595b-86c6-4e10e47f1d74","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<p>주당 1챕터씩 작성하려 했으나 1주가 미뤄졌다. 회사 일이 바쁘고 주말에 지침 이슈. <del>(게으름 이슈)</del> 연말 휴가때 좀 몰아서 읽어야겠다.</p>\n<p>이번 3 장은 Compose Runtime의 핵심 동작 원리를 다룬다.</p>\n<ul>\n<li>슬롯 테이블과 변경 목록이 어떻게 composition 상태를 관리하는지</li>\n<li>Composer가 어떻게 변경사항을 기록하고 Applier가 어떻게 이를 실제 트리에 적용하는지</li>\n<li>Recomposer가 어떻게 전체 recomposition 프로세스를 조율하는지 살펴본다</li>\n</ul>\n<p>컴파일러가 코드를 변환하는 방법을 다뤘던 2장과 달리, 이번 장은 런타임에서 실제로 UI가 어떻게 만들어지고 업데이트되는지 메커니즘을 살펴본다.</p>\n<p><a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/\">이전 2장 컴포즈 컴파일러</a>\n도 만만치 않았지만, 이번 3장은 분량이 2배다.\n예시코드와 그림들이 전보다 많기 때문에 장수가 더 많아진 감도 있다.\n이전 장도 이해하고 요약하기 위해 마음의 준비가 필요했지만, 이번 장은 2배 정도의 노력이 더 필요했다.</p>\n<hr>\n<blockquote>\n<p><strong>슬롯 테이블 (Slot Table):</strong> Composition의 현재 상태를 저장하는 메모리 구조. 모든 Composable 호출의 위치, 파라미터, 기억된 값 등을 추적.</p>\n</blockquote>\n<blockquote>\n<p><strong>변경 목록 (List of Changes):</strong> 노드 트리에 실제로 적용할 변경사항을 담은 목록. 패치 파일처럼 동작.</p>\n</blockquote>\n<h1 id=\"슬롯-테이블과-변경-목록-the-slot-table-and-the-list-of-changes\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%A1%AF-%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%EB%B3%80%EA%B2%BD-%EB%AA%A9%EB%A1%9D-the-slot-table-and-the-list-of-changes\" aria-label=\"슬롯 테이블과 변경 목록 the slot table and the list of changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬롯 테이블과 변경 목록 (The slot table and the list of changes)</h1>\n<p>슬롯 테이블은 composition의 현재 상태를 저장한다.\nComposable 호출의 위치, 파라미터, 기억된 값, CompositionLocal 등 모든 정보가 여기 담긴다.</p>\n<p>변경 목록은 실제 노드 트리에 적용할 변경사항이다.\n패치 파일처럼 동작한다.</p>\n<p>슬롯 테이블 = 상태 기록, 변경 목록 = 변경 적용.</p>\n<p>Composer가 슬롯 테이블의 정보를 보고 변경 목록을 생성한다.\nApplier가 변경 목록을 트리에 적용한다.\nRecomposer가 언제, 어디서 할지 결정한다.</p>\n<hr>\n<blockquote>\n<p><strong>갭 버퍼 (Gap Buffer):</strong> 텍스트 에디터에서 사용하는 자료구조. 데이터 중간에 빈 공간(갭)을 두고, 갭을 이동시키면서 효율적으로 삽입/삭제.</p>\n</blockquote>\n<blockquote>\n<p><strong>앵커 (Anchor):</strong> 슬롯 테이블에서 특정 위치를 가리키는 포인터. 빠른 접근을 위해 사용.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 132.7777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAACwklEQVR42tWVS08TURzFEUjEhYlxYUx0rcRHxPgF3Llh4fcxhp2s+QQ1JsbQWvqEQkKhuiGtBWtCmjQ8hEIKhXZoO6/O496/5z+2gCg4NTHGSadzJ2nPnN89597p6/ubBxFduujs+1dH98n9W1tbr46OjuK1Wm2y3lBD9aYWqitKsF6vh6vV6ttEInGrS3IhZmc42Gq1crgnwZ/aF6KvCb6V/GXbtjk3N/eg859+X4KHh4dL/GfTIVvPvXb11AvXNHTHsm2paao2MzNzj384NjbmS3CgUqlkWbClakJtKqQqVVI1TZqmSZgKs1fBwWazeYKcfknyzTMSdvs7smX1jnxwcJDtIAvj8yTp6XEyDUM6jkuq2jJjsdh9/mEwGBzwJbi/v591HIcajYYwLAfCkjQgW5ZFiqL0joy5yu3u7lI6nRb5/Cf6+CFDCwsLslQqER6kT09PP49EIk9wXjtTufOR2SH6KLa3t6lQKNDa2prksa7rZjweH45Go1fh9PG5Tk8LoryeIBIVQGURxpeGYfDVhMM7gUBgCAV/5EvwNPLy8jJlMifIKHZ7dnZ2mAWTyeRIN5yfVs1Zh1JKQh8FAiIW2tnZkXt7exyOOTU15TnEHI74cshz2G63CVcBbEIveSxVVeXxaeSncHclHA7fgOvrP7j8FfL8/LyHDHQey2KxyCl7yBMTE5fRx1HeKFi46/bcHnKxsdsI9I7T9hxijaPYau/I2KaynC7mTUCIhb05ZHEgt1Op1N2eQmFkBHKcMnB57CG7rnss6Lc2x7sNHAnsjZw2d1J2AvKQFxcXh7BJ+EOG0BKwaWNjw0Y4LgTdzc1NB3WSeICGlB8C96bvYmNF5NjZ6uqqWF9fp3w+TysrK97SE0LwWh7tuvT1TimXy+NwmUSRQ0g8jHUcxvg9gokg6Xfo3e3f7jZ/8pr9v9/L3wAorHGwx9AzBwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/4116c0c7c14607c1bcf48477d184be33/37523/0.png\"\n        srcset=\"/static/4116c0c7c14607c1bcf48477d184be33/e9ff0/0.png 180w,\n/static/4116c0c7c14607c1bcf48477d184be33/f21e7/0.png 360w,\n/static/4116c0c7c14607c1bcf48477d184be33/37523/0.png 720w,\n/static/4116c0c7c14607c1bcf48477d184be33/302a4/0.png 1080w,\n/static/4116c0c7c14607c1bcf48477d184be33/07a9c/0.png 1440w,\n/static/4116c0c7c14607c1bcf48477d184be33/08c33/0.png 1570w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1 id=\"슬롯-테이블-심층-분석-the-slot-table-in-depth\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%A1%AF-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%8B%AC%EC%B8%B5-%EB%B6%84%EC%84%9D-the-slot-table-in-depth\" aria-label=\"슬롯 테이블 심층 분석 the slot table in depth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬롯 테이블 심층 분석 (The slot table in depth)</h1>\n<p>슬롯 테이블은 갭 버퍼 개념을 바탕으로 한다.\n빠른 선형 접근에 최적화된 데이터 구조다.</p>\n<p>두 개의 배열로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">var</span> groups <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> slots <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>groups 배열은 그룹 메타데이터를 저장한다. 부모-자식 관계, 그룹 타입 등의 정보다.\nslots 배열은 실제 composition 데이터를 저장한다. Any? 타입이므로 모든 종류의 값을 담을 수 있다.</p>\n<p><a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#%EA%B5%90%EC%B2%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-replaceable-groups\">2장에서 봤듯이 (교체 가능한 그룹)</a>\n컴파일러는 Composable 함수 본문을 그룹으로 감싼다.\n그룹은 Composable 함수에 고유 ID를 부여하고 관련 정보를 감싼다.\n그룹 타입은 재시작 가능한 그룹, 이동 가능한 그룹, 교체 가능한 그룹, 재사용 가능한 그룹이 있다.\n부모 그룹이 먼저 나오고 자식 그룹이 뒤따른다. 선형 구조로 그룹 트리를 모델링한다.</p>\n<p>갭은 테이블에서 이동 가능한 범위 포인터다.\n데이터를 읽고 쓸 위치를 결정한다.\n조건부 로직에서 조건이 바뀌면 갭이 그룹 시작 위치로 돌아가서 기존 슬롯을 덮어쓴다.</p>\n<p>SlotReader는 테이블에서 데이터를 읽는다. 여러 개의 Reader가 동시에 읽을 수 있다.\nSlotWriter는 테이블에 데이터를 쓴다. 하나의 Writer만 활성화될 수 있다.\n동시 읽기/쓰기를 막아서 경쟁 상태를 방지한다.\nReader는 방문자처럼 작동한다. 현재 그룹, 위치, 부모, 슬롯 등을 추적하면서 배열을 탐색한다.\nWriter는 그룹과 슬롯을 추가, 교체, 이동, 제거한다. 갭을 이동시키면서 어디에 쓸지 결정한다.</p>\n<p>앵커는 특정 인덱스를 가리키는 포인터다. 빠른 접근을 위해 사용된다.\n앵커가 가리키는 위치 앞에서 그룹이 이동/교체/삽입/제거되면 앵커도 업데이트된다.</p>\n<hr>\n<h1 id=\"변경-목록-the-list-of-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EB%AA%A9%EB%A1%9D-the-list-of-changes\" aria-label=\"변경 목록 the list of changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 목록 (The list of changes)</h1>\n<p>Composition이 발생할 때마다 Composable 함수들이 실행되고 방출된다.\n방출이란 슬롯 테이블을 업데이트하고, 지연된 변경사항을 생성하는 것이다.\n이 변경사항들이 목록 형태로 저장된다.</p>\n<p>새로운 변경 목록은 슬롯 테이블에 이미 저장된 값을 바탕으로 생성된다.\n트리의 어떤 변경사항이라도 composition의 현재 상태에 의존하기 때문이다.</p>\n<p>예를 들어 노드를 이동한다고 생각해보자.\n테이블에서 해당 노드가 이전에 어디 있었는지 확인하고, 그 위치의 슬롯을 제거한 다음 새 위치에 다시 작성해야 한다.</p>\n<p>Composable 함수가 방출될 때마다 슬롯 테이블을 확인하고, 현재 정보에 따라 지연된 변경사항을 생성하고, 변경 목록에 추가한다.\n나중에 composition이 끝나면 변경 목록의 내용들이 실제로 실행되면서 구체화된다.\n그때가 슬롯 테이블을 최신 정보로 실제 업데이트하는 순간이다.\n실행을 기다리는 작업을 미리 생성해두는 것만으로 방출 과정이 매우 빠르다.</p>\n<p>변경 목록이 적용된 직후, 구체화된 노드 트리를 업데이트하기 위해 Applier에게 알린다.</p>\n<p>Recomposer는 이 과정을 조율한다.\n어떤 스레드에서 composition/recomposition 할지, 어떤 스레드에서 변경사항을 적용할지 결정한다.\n변경사항을 적용하는 스레드는 LaunchedEffect가 사이드 이펙트를 실행하는 디폴트 컨텍스트가 되기도 한다.</p>\n<p>이제 Composer를 살펴볼 차례다.</p>\n<hr>\n<h1 id=\"composer\" style=\"position:relative;\"><a href=\"#composer\" aria-label=\"composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer</h1>\n<p>주입된 $composer는 우리가 작성하는 Composable 함수를 Compose Runtime에 연결하는 역할을 한다.\n<a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#composer-%EC%A3%BC%EC%9E%85%ED%95%98%EA%B8%B0-injecting-the-composer\"><code class=\"language-text\">$composer</code>가 어떻게 주입 되는지는 2장에서 자세히 다뤘다.</a></p>\n<hr>\n<h1 id=\"composer-키우기-feeding-the-composer\" style=\"position:relative;\"><a href=\"#composer-%ED%82%A4%EC%9A%B0%EA%B8%B0-feeding-the-composer\" aria-label=\"composer 키우기 feeding the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer 키우기 (Feeding the Composer)</h1>\n<p>트리의 메모리 표현에 노드가 어떻게 추가되는지 살펴보자.\nLayout Composable을 예로 들 수 있다.\nLayout은 Compose UI의 모든 UI 컴포넌트의 기반이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Layout</span><span class=\"token punctuation\">(</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    modifier<span class=\"token operator\">:</span> Modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">,</span>\n    measurePolicy<span class=\"token operator\">:</span> MeasurePolicy\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> density <span class=\"token operator\">=</span> LocalDensity<span class=\"token punctuation\">.</span>current\n    <span class=\"token keyword\">val</span> layoutDirection <span class=\"token operator\">=</span> LocalLayoutDirection<span class=\"token punctuation\">.</span>current\n    ReusableComposeNode<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n        factory <span class=\"token operator\">=</span> ComposeUiNode<span class=\"token punctuation\">.</span>Constructor<span class=\"token punctuation\">,</span>\n        update <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>measurePolicy<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetMeasurePolicy<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>density<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetDensity<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>layoutDirection<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetLayoutDirection<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        skippableUpdate <span class=\"token operator\">=</span> <span class=\"token function\">materializerOf</span><span class=\"token punctuation\">(</span>modifier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        content <span class=\"token operator\">=</span> content\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Layout은 LayoutNode를 composition에 방출하기 위해 ReusableComposeNode를 사용한다.\n즉각 노드를 생성하고 추가하는 것처럼 보이지만, 실제로는 “적절한 시기에 노드를 생성, 초기화, 삽입하는 방법”을 런타임에게 가르친다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">></span> <span class=\"token function\">ReusableComposeNode</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">noinline</span> factory<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">,</span>\n    update<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> Updater<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">noinline</span> skippableUpdate<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> SkippableUpdater<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">startReusableNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">createNode</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Updater</span><span class=\"token punctuation\">(</span>currentComposer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// initialization</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">startReplaceableGroup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x7ab4aae9</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">content</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">endReplaceableGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">endNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>currentComposer 인스턴스에 모든 것을 위임하는 형태다.\n교체 가능한 그룹으로 Composable 함수 본문을 감싼다.\ncontent 람다 내부에서 방출된 모든 자식들은 이 교체 가능한 그룹의 자식으로 저장된다.\n다른 모든 Composable 함수도 동일한 방출 작업을 수행한다.\nremember를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  <span class=\"token function\">remember</span><span class=\"token punctuation\">(</span>calculation<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span>invalid <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> calculation<span class=\"token punctuation\">)</span></code></pre></div>\n<p>remember는 제공된 람다가 반환한 값을 composition에 캐싱하기 위해 currentComposer를 사용한다.\ninvalid 매개변수는 값을 강제로 업데이트한다.</p>\n<p>cache 함수는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  Composer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span>invalid<span class=\"token operator\">:</span> Boolean<span class=\"token punctuation\">,</span> block<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">rememberedValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>invalid <span class=\"token operator\">||</span> it <span class=\"token operator\">===</span> Composer<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">val</span> value <span class=\"token operator\">=</span> <span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">updateRememberedValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n            value\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> it\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> T\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 composition(슬롯 테이블)에서 값을 검색한다.\n찾을 수 없으면 변경사항을 방출해서 값 업데이트를 예약한다.\n있으면 그대로 반환한다.</p>\n<hr>\n<h1 id=\"변경-사항-모델링-modeling-the-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EB%AA%A8%EB%8D%B8%EB%A7%81-modeling-the-changes\" aria-label=\"변경 사항 모델링 modeling the changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항 모델링 (Modeling the Changes)</h1>\n<p>currentComposer에 위임된 모든 방출 작업은 Change로 모델링되어 변경 목록에 추가된다.\nChange는 현재 Applier와 SlotWriter에 접근할 수 있는 지연된 함수다.\n작성자는 한 번에 하나만 활성화될 수 있다는 걸 기억하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">typealias</span> Change <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n    applier<span class=\"token operator\">:</span> Applier<span class=\"token punctuation\">,</span>\n    slots<span class=\"token operator\">:</span> SlotWriter<span class=\"token punctuation\">,</span>\n    rememberManager<span class=\"token operator\">:</span> RememberManager\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit</code></pre></div>\n<p>이런 변경사항들은 변경 목록에 추가된다. 다시 말해 기록된다.\n“방출”이라는 행위는 본질적으로 이런 Change들을 생성하는 것이다.\nChange는 슬롯 테이블에서 노드를 추가, 제거, 교체, 이동할 수 있는 지연된 람다식이며, 결과적으로 Applier에 변경사항을 알린다.\n궁극적으로 Applier를 통해 구체화된다.</p>\n<p>따라서 “변경사항 방출”, “변경사항 기록”, “변경사항 스케줄링”은 모두 같은 의미다.\nComposition이 끝나면 일련의 Composable 함수들이 호출되고, 모든 변경사항이 기록된다.\n그 후 Applier에 의해 모든 변경사항들이 일괄 적용된다.\nComposition 자체는 Composition 클래스로 모델링된다.</p>\n<hr>\n<h1 id=\"작성-시기-최적화-optimizing-when-to-write\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EC%84%B1-%EC%8B%9C%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94-optimizing-when-to-write\" aria-label=\"작성 시기 최적화 optimizing when to write permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>작성 시기 최적화 (Optimizing when to write)</h1>\n<p>새로운 노드를 삽입하는 것은 Composer에게 위임된다.\nComposer가 composition에 새로운 노드를 삽입하는 과정에 참여하고 있을 때, Compose는 항상 그 사실을 알고 있다.\n이런 경우 Composer는 변경사항을 변경 목록에 추가하지 않는다.\n곧바로 슬롯 테이블에 변경사항을 작성한다.\n그 외의 경우에는 변경사항이 변경 목록에 기록되고 지연된다.\n아직 적용할 시점이 아니기 때문이다.</p>\n<hr>\n<h1 id=\"쓰기-및-읽기-그룹-writing-and-reading-groups\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EA%B8%B0-%EB%B0%8F-%EC%9D%BD%EA%B8%B0-%EA%B7%B8%EB%A3%B9-writing-and-reading-groups\" aria-label=\"쓰기 및 읽기 그룹 writing and reading groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰기 및 읽기 그룹 (Writing and reading groups)</h1>\n<p>Composition이 완료되면 <code class=\"language-text\">composition.applyChanges()</code>가 호출된다.\n트리를 구체화하고 변경사항이 슬롯 테이블에 기록된다.</p>\n<p>Composer는 데이터, 노드, 그룹 등 다양한 유형의 정보를 작성할 수 있다.\n단순화를 위해 궁극적으로 모든 항목은 그룹 형태로 저장된다.\n그룹들은 서로 다른 그룹 필드로 차별화된다.</p>\n<p>Composer는 모든 그룹을 “시작”하고 “종료”할 수 있다.\n쓰기 작업 중이면 슬롯 테이블에서 “그룹 생성”과 “그룹 제거”를 의미한다.\n읽기 작업 중이면 SlotReader가 읽기 포인터를 그룹 외부로 이동한다.</p>\n<p>Composable 트리의 노드는 삽입뿐만 아니라 제거되거나 이동될 수도 있다.\n그룹을 제거한다는 것은 그룹과 모든 슬롯을 테이블에서 제거하는 것이다.\nComposer는 SlotReader를 재배치하고 해당 그룹을 건너뛰게 하며, 모든 노드를 Applier에서 제거한다.\n모든 수정 작업은 일괄 적용을 위해 예약(기록)되어야 한다.\n모든 변경사항이 동시에 반영되어야 의미 있기 때문이다.\nComposer는 제거된 그룹에 대한 모든 보류 중인 invalidation을 폐기한다.</p>\n<p>모든 그룹이 재시작/교체/이동/재사용 가능한 형태로 분류되는 것은 아니다.\n예를 들어 디폴트 값을 둘러싸는 블록도 매우 특정한 그룹으로 분류된다.\n<code class=\"language-text\">model: Model = remember { DefaultModel() }</code> 같은 형태다.</p>\n<p>Composer가 그룹을 시작하려고 할 때 다음과 같은 일이 발생한다.\n값들을 삽입하는 과정이면 곧바로 슬롯 테이블에 작성한다.\n보류 중인 작업이 있으면 변경사항 적용 시 모두 기록한다. 대상 그룹이 이미 존재하면 재사용한다.\n그룹이 다른 위치에 있으면(이동됨) 모든 슬롯을 이동하는 동작이 기록된다.\n새 그룹이면(테이블에 없음) 삽입 모드로 이동해서 중간 insertTable에 작성한 후 최종 테이블에 삽입을 예약한다.\n삽입 중도 아니고 보류 중인 작성 작업도 없으면 그룹 읽기를 시작한다.</p>\n<p>그룹 재사용은 흔하다.\n이미 존재하는 노드는 재사용할 수 있다.\nApplier에 의해 노드 이동 작업은 발행(기록)하지만, 생성과 초기화 작업은 생략한다.</p>\n<p>노드의 속성에 업데이트가 필요하면 그 업데이트 동작도 Change로 기록된다.</p>\n<hr>\n<h1 id=\"값-기억하기-remembering-values\" style=\"position:relative;\"><a href=\"#%EA%B0%92-%EA%B8%B0%EC%96%B5%ED%95%98%EA%B8%B0-remembering-values\" aria-label=\"값 기억하기 remembering values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>값 기억하기 (Remembering values)</h1>\n<p>Composer는 값을 composition에 기억하고(슬롯 테이블에 기록), 나중에 업데이트할 수 있다.\n마지막 composition으로부터 값이 변경되었는지 비교는 remember 함수가 호출되는 즉시 수행된다.\n하지만 업데이트 작업은 Composer가 값을 이미 삽입하는 중이 아니라면 Change로 기록된다.\n업데이트할 값이 RememberObserver인 경우 Composer는 암시적 Change도 기록한다.\ncomposition의 기억 작업을 추적하기 위해서다.\n나중에 기억하고 있는 모든 값을 다시 잊어야 할 때 사용한다.</p>\n<hr>\n<blockquote>\n<p><strong>RecomposeScope:</strong> Composition의 나머지 부분과 독립적으로 재구성될 수 있는 영역.</p>\n</blockquote>\n<h1 id=\"재구성-범위-recompose-scopes\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B5%AC%EC%84%B1-%EB%B2%94%EC%9C%84-recompose-scopes\" aria-label=\"재구성 범위 recompose scopes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재구성 범위 (Recompose scopes)</h1>\n<p>Composer를 통해 발생하는 또 다른 기능은 스마트 recomposition을 가능하게 하는 범위 재구성이다.\n이는 재시작 가능한 그룹과 직접 관련이 있다.\n재시작 가능한 그룹이 생성될 때마다 Composer는 RecomposeScope를 생성하고 이를 Composition의 currentRecomposeScope로 설정한다.</p>\n<p>RecomposeScope는 Composable의 recomposition을 수동으로 invalidate하고 트리거하는 데 사용할 수 있다.\ninvalidate는 <code class=\"language-text\">composer.currentRecomposeScope().invalidate()</code>와 같이 Composer를 통해 요청된다.\n재구성을 위해 Composer는 슬롯 테이블을 해당 그룹의 시작 위치에 배치한 다음 재구성 블록을 호출한다.\nComposable 함수가 다시 호출되어 한 번 더 방출되므로 Composer에게 테이블의 기존 데이터를 재정의하도록 요청한다.</p>\n<p>Composer는 invalidate된 모든 재구성 범위의 스택을 유지한다.\n다음 recomposition에서 트리거되어야 하는 보류 중인 범위들이다.\ncurrentRecomposeScope는 실제로 이 재구성 범위 스택을 통해 생성된다.</p>\n<p>RecomposeScope가 항상 활성화되는 것은 아니다.\nCompose가 Composable 함수 내에서 상태 스냅샷 읽기와 관련된 작업을 발견했을 경우에만 발생한다.\n이 경우 Composer는 RecomposeScope를 used로 표시한다.\n그러면 Composable 함수 끝에 삽입된 “end” 호출이 더 이상 null을 반환하지 않고 뒤따르는 recomposition 람다를 활성화한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// After compiler inserts boilerplate</span>\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> $composer<span class=\"token operator\">:</span> Composer<span class=\"token punctuation\">,</span> $changed<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    $composer<span class=\"token punctuation\">.</span><span class=\"token function\">startRestartGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    $composer<span class=\"token punctuation\">.</span><span class=\"token function\">endRestartGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateScope</span> <span class=\"token punctuation\">{</span> next <span class=\"token operator\">-></span>\n        <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">,</span> $changed <span class=\"token operator\">or</span> <span class=\"token number\">0b1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>endRestartGroup 함수 호출의 ? 문자 뒤를 보자.\nComposer는 재구성이 필요할 때 현재 상위 그룹의 invalidate된 하위 그룹을 모두 recomposition할 수 있다.\n그렇지 않은 경우 SlotReader가 그룹을 마지막까지 생략할 수 있다.\n(<a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#%EB%B9%84%EA%B5%90-%EC%A0%84%ED%8C%8C-comparison-propagation\">2장의 비교 전파 섹션 참고</a>)</p>\n<hr>\n<h1 id=\"composer와-사이드-이펙트-sideeffects-in-the-composer\" style=\"position:relative;\"><a href=\"#composer%EC%99%80-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-sideeffects-in-the-composer\" aria-label=\"composer와 사이드 이펙트 sideeffects in the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer와 사이드 이펙트 (SideEffects in the Composer)</h1>\n<p>Composer는 사이드 이펙트도 기록할 수 있다.\n사이드 이펙트는 항상 composition 이후에 실행된다.\n트리에 대한 변경사항 적용이 완료된 시점에 호출 가능한 함수 형태로 기록된다.\n이는 Composable 함수 외부에서 발생하는 이펙트를 나타내므로 Composable의 라이프사이클과 완전히 무관하다.\nComposition을 떠날 때 실행 중인 작업을 자동 취소하거나 recomposition에 이펙트를 재시도하는 것 같은 작업은 담당하지 않는다.\n이런 유형의 이펙트는 슬롯 테이블에 저장되지 않기 때문에 composition이 실패하면 간단히 폐기된다.</p>\n<hr>\n<h1 id=\"compositionlocals-저장-storing-compositionlocals\" style=\"position:relative;\"><a href=\"#compositionlocals-%EC%A0%80%EC%9E%A5-storing-compositionlocals\" aria-label=\"compositionlocals 저장 storing compositionlocals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CompositionLocals 저장 (Storing CompositionLocals)</h1>\n<p>Composer는 CompositionLocals를 등록하고 키를 통해 해당 값을 획득하는 방법을 제공한다.\n<code class=\"language-text\">CompositionLocal.current</code> 호출은 이에 의존한다.\nCompositionLocals의 Provider(공급자)와 공급되는 값은 모두 슬롯 테이블에 그룹 형태로 저장된다.</p>\n<hr>\n<h1 id=\"소스-정보-저장-storing-source-information\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%8A%A4-%EC%A0%95%EB%B3%B4-%EC%A0%80%EC%9E%A5-storing-source-information\" aria-label=\"소스 정보 저장 storing source information permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소스 정보 저장 (Storing source information)</h1>\n<p>Composer는 composition 중에 수집된 내용을 CompositionData 형태로 소스 정보를 저장한다.\n각종 Compose 툴에서 활용할 수 있도록 하기 위해서다.</p>\n<hr>\n<blockquote>\n<p><strong>Subcomposition:</strong> 독립적인 invalidation을 지원하기 위해 별도로 생성된 composition. 상위 composition과 CompositionContext로 연결됨.</p>\n</blockquote>\n<h1 id=\"compositioncontext를-이용한-composition-연결-linking-compositions-via-compositioncontext\" style=\"position:relative;\"><a href=\"#compositioncontext%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-composition-%EC%97%B0%EA%B2%B0-linking-compositions-via-compositioncontext\" aria-label=\"compositioncontext를 이용한 composition 연결 linking compositions via compositioncontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CompositionContext를 이용한 Composition 연결 (Linking Compositions via CompositionContext)</h1>\n<p>CompositionContext는 단일 composition에는 없지만 composition과 subcomposition 트리에 존재한다.</p>\n<p>Subcomposition은 독립적인 invalidation을 지원하기 위해 현재 컨텍스트에서 별도의 composition을 구성하려는 의도로 생성된 인라인 타입의 composition이다.\n상위 CompositionContext 참조를 통해 상위 composition과 연결된다.</p>\n<p>CompositionContext는 composition과 subcomposition을 하나의 트리로 연결하기 위해 존재한다.\nCompositionLocal과 invalidation이 마치 단일 composition에 속한 것처럼 투명하게 트리 아래로 전파되는 것을 보장한다.\nCompositionContext 자체도 슬롯 테이블에 그룹의 한 유형으로 기록된다.</p>\n<p>Subcomposition은 일반적으로 <code class=\"language-text\">rememberCompositionContext</code>를 통해 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">rememberCompositionContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CompositionContext <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">buildContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수는 슬롯 테이블의 현재 위치에 새 composition을 기억하거나, 이미 기억된 경우 이를 반환한다.\nVectorPainter, Dialog, SubcomposeLayout, Popup 같은 별도의 composition이 필요한 위치에서 subcomposition을 만드는 데 사용된다.\nAndroid View를 Composable 트리에 통합하기 위해 사용하는 wrapper인 AndroidView도 마찬가지다.</p>\n<hr>\n<h1 id=\"현재-상태-스냅샷에-접근--accessing-the-current-state-snapshot\" style=\"position:relative;\"><a href=\"#%ED%98%84%EC%9E%AC-%EC%83%81%ED%83%9C-%EC%8A%A4%EB%83%85%EC%83%B7%EC%97%90-%EC%A0%91%EA%B7%BC--accessing-the-current-state-snapshot\" aria-label=\"현재 상태 스냅샷에 접근  accessing the current state snapshot permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>현재 상태 스냅샷에 접근  (Accessing the current State snapshot)</h1>\n<p>Composer는 현재 스냅샷에 대한 참조를 가지고 있다.\n이는 현재 스레드에 대한 가변적인 상태 및 기타 상태 객체들이 반환하는 값의 스냅샷과 유사하다.\n모든 상태 객체는 스냅샷에서 명시적으로 변경되지 않는 한 스냅샷이 생성되었을 때와 동일한 값을 갖는다.</p>\n<hr>\n<h1 id=\"노드-탐색-navigating-the-nodes\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%83%90%EC%83%89-navigating-the-nodes\" aria-label=\"노드 탐색 navigating the nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 탐색 (Navigating the nodes)</h1>\n<p>노드 트리 탐색은 Applier에 의해 수행되지만 직접적으로 수행되지는 않는다.\n구독자에 의해 탐색되는 노드의 모든 위치를 기록하고 downNodes 배열에 기록함으로써 수행된다.\n노드 탐색이 실현되면 downNodes에 있는 모든 하향 노드 정보를 Applier에 전달된다.\n하향 노드 탐색이 수행되기 전에 상향 노드 탐색이 수행되는 경우에는 downNodes 스택에서 제거하여 탐색 경로를 단축한다.</p>\n<hr>\n<h1 id=\"구독자와-작성자의-동기화-유지--keeping-reader-and-writer-in-sync\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EB%8F%85%EC%9E%90%EC%99%80-%EC%9E%91%EC%84%B1%EC%9E%90%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%9C%A0%EC%A7%80--keeping-reader-and-writer-in-sync\" aria-label=\"구독자와 작성자의 동기화 유지  keeping reader and writer in sync permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구독자와 작성자의 동기화 유지  (Keeping reader and writer in sync)</h1>\n<p>구독자와 작성자의 동기화 유지는 low-level에서 이루어지는 작업이다.\n특정 그룹을 삽입, 삭제, 이동할 수 있으므로 작성자의 그룹 위치는 변경사항이 적용될 때까지 일시적으로 구독자의 위치와 다를 수 있다.</p>\n<p>이 차이를 추적하기 위해 델타를 유지 관리한다.\n델타는 삽입, 삭제, 이동에 따라 업데이트되며 “작성자와 구독자의 현재 슬롯 위치를 정확하게 일치시키기 위해 이동해야 하는 실현되지 않은 거리”를 반영한다.</p>\n<p>구독자와 작성자 간의 동기화는 Compose Runtime 라이브러리의 ComposerChangeListWriter에서 수행된다.\n이 클래스 내에는 writersReaderDelta 변수가 존재하고, 구독자와 작성자 간의 슬롯 위치를 지속적으로 계산하는 함수들이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> writersReaderDelta<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">moveReaderRelativeTo</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    writersReaderDelta <span class=\"token operator\">+=</span> location <span class=\"token operator\">-</span> reader<span class=\"token punctuation\">.</span>currentGroup\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">moveReaderToAbsolute</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    writersReaderDelta <span class=\"token operator\">=</span> location\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수들은 구독자와 작성자 간의 격차를 추적하기 위해 Composer에 의해 지속적으로 호출된다.\n그룹 생성이 시작되거나 값에 업데이트가 발생할 때마다 realizeOperationLocation 함수를 실행시켜 거리 간격을 정확하게 일치시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">realizeOperationLocation</span><span class=\"token punctuation\">(</span>forParent<span class=\"token operator\">:</span> Boolean <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> location <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>forParent<span class=\"token punctuation\">)</span> reader<span class=\"token punctuation\">.</span>parent <span class=\"token keyword\">else</span> reader<span class=\"token punctuation\">.</span>currentGroup\n    <span class=\"token keyword\">val</span> distance <span class=\"token operator\">=</span> location <span class=\"token operator\">-</span> writersReaderDelta\n    <span class=\"token function\">runtimeCheck</span><span class=\"token punctuation\">(</span>distance <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string-literal singleline\"><span class=\"token string\">\"Tried to seek backward\"</span></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>distance <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        changeList<span class=\"token punctuation\">.</span><span class=\"token function\">pushAdvanceSlotsBy</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">)</span>\n        writersReaderDelta <span class=\"token operator\">=</span> location\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h1 id=\"변경-사항-적용하기-applying-the-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-applying-the-changes\" aria-label=\"변경 사항 적용하기 applying the changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항 적용하기 (Applying the changes)</h1>\n<p>이번 챕터에서 여러 번 언급했듯이 Applier가 변경사항 적용을 담당한다.\nComposer는 이 추상화를 Applier에게 위임하여 composition 이후에 기록된 모든 변경사항을 적용한다.\n이것을 “구체화(materializing)“라고 한다.</p>\n<p>이 프로세스는 변경 목록을 실행하고 결과적으로 슬롯 테이블을 업데이트한다.\n슬롯 테이블에 저장된 composition 데이터를 해석하여 효과적으로 결과를 생성한다.</p>\n<p>런타임은 Applier의 구현체와 독립적이다.\n클라이언트 라이브러리가 구현할 것으로 기대되는 계약에 의존한다.\nApplier는 플랫폼과의 통합점과 같으므로 유즈케이스에 따라 인터페이스의 구현체가 전혀 달라질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Applier<span class=\"token operator\">&lt;</span>N<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> current<span class=\"token operator\">:</span> N\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onBeginChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">down</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">insertTopDown</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">insertBottomUp</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>가장 먼저 보이는 것은 N 제네릭 타입 매개변수다.\nN 매개변수는 우리가 적용하는 노드의 타입을 결정한다.\n이것이 Compose가 제네릭 호출 그래프 또는 노드 트리와 함께 동작할 수 있는 이유다.\n사용되는 노드 타입에 대해서는 항상 상호운용이 가능하다.</p>\n<p>Applier는 트리를 탐색하고 노드를 삽입, 제거, 이동하는 작업을 제공한다.\n하지만 해당 노드의 타입이나 최종적으로 어떻게 삽입되는지는 관여하지 않는다.\n노드 자체에게 위임된다.</p>\n<p>Applier는 현재 노드에서 지정된 범위의 모든 하위 항목을 제거하거나, 하위 항목을 이동시키고 위치를 변경하는 방법도 정의한다.\nclear 작업은 루트를 가리키고 트리에서 모든 노드를 제거한다.\nApplier와 해당 루트를 향후 새 composition에 사용할 준비를 한다.</p>\n<p>Applier는 모든 노드를 방문하고 적용하면서 전체 트리를 순회한다.\n트리는 하향 또는 상향 순회할 수 있다.\nApplier는 방문하고 변경사항을 적용하는 현재 노드에 대한 참조를 항상 유지한다.</p>\n<p>Composer가 변경사항 적용을 시작하고 끝낼 때 <code class=\"language-text\">onBeginChanges()</code>와 <code class=\"language-text\">onEndChanges()</code>를 호출한다.\n<code class=\"language-text\">insertTopDown()</code>과 <code class=\"language-text\">insertBottomUp()</code>으로 상단에서 하단으로, 또는 하단에서 상단으로 노드를 삽입한다.\n<code class=\"language-text\">down()</code>으로 현재 노드의 자식 노드로 이동하고, <code class=\"language-text\">up()</code>으로 현재 노드의 부모로 이동한다.</p>\n<hr>\n<h1 id=\"노드-트리-구축-시-성능--performance-when-building-the-node-tree\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%B6%95-%EC%8B%9C-%EC%84%B1%EB%8A%A5--performance-when-building-the-node-tree\" aria-label=\"노드 트리 구축 시 성능  performance when building the node tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 트리 구축 시 성능  (Performance when building the node tree)</h1>\n<p>트리를 하향식으로 작성하는 것과 상향식으로 작성하는 것에는 중요한 차이가 있다.</p>\n<p><strong>하향식 삽입  (Inserting top‑down)</strong></p>\n<p>아래와 같은 트리가 있다고 가정해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVR42tVVzU8TQRTf8qXxDzDReDPKyROx0YvEgwnc1IQ7N/8COdrEgwe9qCQNUChqWyRbS4WuLP2iS+lWSlvaClisoUAhUMpXC2wL1e5zX8vCEgjpwslJJvPb934z++a938wQxH/fVKCqOA2frwGhwKHeVV+FXWqTvxZAcSKZpJ65d3wz2BFLfWU3kiQrcfyw0vtwshCDwGaEn8hM8Yg7BZuUU250RbJ1m2mJwRy8N6tzbXRX7hfMg3Xb3SLlyIqwZ7m/IcLPAJv0895VP49Yv2xslB2htPWt0c+9XDCOHfHFJKMqyURv/dz8idY3S20X0iAzwNy39dvuYXUvtuDBZE3IoNRO9N49f4SieFVExUDKrh7Lhvjv2QkeMdpkC5yEUgWNKappFpbg25StYP/NFBAbN6gmKUeWDh3bnpZZWAQ11ZHrsGpziNEmW4diMVqT2jv+/GQmzE1DJBuFwJ/JNNrkXxRCfnBL5i/mx8bQ11dOjqWdO94hY9D82kSaHhXPcrk5FHPj6nZdpmn6qcViUYo+iqIeWAYHnwinpKasPB7eIlBf1cXoG7U2wy38DECgGjtiHa2r1bi6G4gAUX3mzSPmRJMglc5NT9CXDW3Y06MOdbyzVuS0Ln287cx47D4utDmcZoOahEF5ej6PdFfl5nxsXJCHa8GTT0ASHDsek0gb3mVN6LPHR/Ix4eYZzflZoomoPNie4kR0HYu6G5G/0VXHnLvwou3lnj8dhnA++pMYJC4JP6uJFGJRV4KFt33qPTY5XgjuT6c613qun4zyqGIKNzfunIcVCKR/7OPo3GX1Is2ecRsWIQVj68H9BcGH3FPWOF6QdwvtN21bIxYvF4gPbTE6VfjN1cOdCJjeYHR4lSEHuWcW5tAhnNe69rorGLH0zwd+xTX0CRwgytCjMKkCewmTlcefUfSVtCfllXVSzjpaRd95n1O57R/PrAH+Fhy8uAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"\"\n        src=\"/static/bb176ec8f505adb0b11e3728eaf4ace2/37523/1.png\"\n        srcset=\"/static/bb176ec8f505adb0b11e3728eaf4ace2/e9ff0/1.png 180w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/f21e7/1.png 360w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/37523/1.png 720w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/302a4/1.png 1080w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/11a8f/1.png 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 트리를 하향식으로 구축하려면 먼저 B를 R에 삽입한 다음 A를 B에 삽입하고 마지막으로 C를 B에 삽입한다.\n즉, 아래 그림과 같은 순서(좌측에서 우측)로 동작한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACwklEQVR42rVTzU8TQRwtYggY0aLU8GGUgzHGGBNj4k0T/wgSIgdj4kG9ES9gxHIwXoz2IJoQaRaMbeOEZdd2XUp229kt3WkLFZDyEQFFEDDQj6VUKGki485iEWhNvDDJZibv98ub995v1mDYj4UxLgCjoMiADQV7awQ3m80H/hffKgJQCF6DY1nynRfZ2+1VEMKDO9r1OsHBM1CSn3CJq5DTodsA8ybOxpUBCA4TnFEZI8GZNKzhXtnKnE7nIb1/DpT40v23XHF4Ya8IfflW+9+Ob05jbe+0WCxGhJCuVloJPB3bnMJ9q/1uO2uvCgaDRwiONsJNw5kJ7IuHhrWYcm17VKUlmBzEnoTSbDFbjG7k1gk9Cd9dlAhjqKJWYAUmPsjrhGJKqfNFQ9izrHTlVahlWMT6uevkzLJslfaVZmuswl1r06zSNF2ZtazHITFXGcgY82bI/OipgUtKSw+WK+k39AkggKMEty04y+VY4CEfE88Thdpw9Gzbo2ypdxk9cMfEK3kVDqQj777iBRzeiNgbGxvLshkG1geff8Hz+ON6xNMBOqr9ExO68lBmuPnz5jccWv0U0TIszFEoqsp9cb4PC6q/gTJTWoZbhL2zsMmz4MdeVXlitVpNQljQlQtz0j3hu5QR5+UPtbW1hTkKyYOGeMuOy+WqJlkBhEocnY6zThzWc+Np/iRFUcXUDCy2UbZzAI8WORyOGuAC1bm2NcIs0P2i+3jvoveyFEcDMI5atwdHgYr3c+4zcjzgkxMBm+5sRamTo2hGSEg3/pAe2PX7kd18+mbx0Np4w8yvRTySmoxDHC4nOHlOodRQ/dTGLB5NTq21rXeeGvk5aY/hFB7LTHf9k5AHvIkepythEj12R+X6bJ0DXAUFKaN3xf9IjPvv6L2qdAkmgy/5hHgx77T3bZGbiPxdFv7WtvEdfdvKfgOrUsb0cwiUEQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"\"\n        src=\"/static/434146ece8a02d8c9abdafc06d48ddbd/37523/2.png\"\n        srcset=\"/static/434146ece8a02d8c9abdafc06d48ddbd/e9ff0/2.png 180w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/f21e7/2.png 360w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/37523/2.png 720w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/302a4/2.png 1080w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/07a9c/2.png 1440w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/78ed4/2.png 2566w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>상향식 삽입 (Inserting bottom‑up)</strong></p>\n<p>트리의 상향식 구축은 A와 C를 B에 삽입한 다음, B 트리를 R에 삽입하는 것으로 시작된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAClUlEQVR42rVTz2vTcBTv7OZ0mw42XQc6GU4U/wAVERxe9OJOssME8eZJYV5FiEdRBgpD6Xao3cDBF7o2TU3aJWn6I+m6Lq61blW7TUXUNmtWarUrOOGZb2ak+5GL4IMv7+Xx4ZP3Pu89i+V/mSzLDdpr2ppLpVLNO+Fpmm4UBKHFlNButzeMj4/vx7EGrMfeITj2kBxnMzA4DwB1OPZ6vU1jrrEOHBu5Tcap4p3gaszhXvR3+ZCvE+emlPBNfkVkptTQSfzNMEw3Qmg3jlk1epcvSM9Qyd+2jZQFuXVWTavz5UWIr70aGO4lWnqBqE+WFxKfQIGZauqW3iZP92A/A5n2ueJ8IVNZAhkyl/8QWi21zFw+PBjMSSMoSx8kSdLWb7FY/W+5QUGN2T1h33mMcddUqFV+O6hII17wNm2tcEMTwXvAI3pOoH5kJWPkMX5VGphMvTiud7AcvBKoRM5oZJ14GDjnCrg6MH5HDfsBWQVV9AmK+HEiO9kTUqafLsNniJYSjokq0y2ps7/i5eQP6s3UJX36IDdwSpRiv0Te85DQSQkgdv0l9IC4b+bbXD798x3wJfGif4kbjBTiwK2IxDCgFiEnLfF5MUMl/acxfhrStnhpTklWMiCvv9Y1RFpRmzRkS9Kp6HqibwgN7aUo6lAAUs0EbKxPAALNj4FudE+4u5Amvv3G/VY6y/Wx+ehV5yPnEdPVMfbL5XId1tsgtDbAUmeAydHnNmY1dDakTo/68uxRfZi56BCjRK5tIzU0wIS4wlqA4YknDzuSlQVKhe/wsrpwj6uKFz7AV0ivZXOjJdRmWqEZ4aTT2c4q4etCIRYPlCPnUBG1hotxOlSUHpieIG4T37DZvZtq9a+GCY1n6Fv7k98hwrPmcxMu5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3\"\n        title=\"\"\n        src=\"/static/cf97a607676ef4497f404bdd62879df1/37523/3.png\"\n        srcset=\"/static/cf97a607676ef4497f404bdd62879df1/e9ff0/3.png 180w,\n/static/cf97a607676ef4497f404bdd62879df1/f21e7/3.png 360w,\n/static/cf97a607676ef4497f404bdd62879df1/37523/3.png 720w,\n/static/cf97a607676ef4497f404bdd62879df1/302a4/3.png 1080w,\n/static/cf97a607676ef4497f404bdd62879df1/07a9c/3.png 1440w,\n/static/cf97a607676ef4497f404bdd62879df1/81a70/3.png 2616w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하향식과 상향식의 트리 작성 성능은 상당히 다를 수 있다.\n사용되는 Applier의 구현체에 따라 성능의 결과가 달라지며, 일반적으로 새 하위 항목이 삽입될 때마다 알림을 받아야 하는 노드 수에 따라 달라진다.</p>\n<p>Compose로 표현하려는 그래프에 노드가 삽입될 때마다 노드의 모든 상위 항목에 알려야 한다고 상상해보자.\n하향식 삽입의 경우는 수많은 노드(부모 노드, 부모의 부모 노드 등 먼 조상까지)에게 알려야 할지도 모른다.\n그래프에 새로운 깊이가 추가될 때마다 변경사항을 알려야 할 노드가 기하급수적으로 증가한다.</p>\n<p>대신 상향식 삽입의 경우 부모가 아직 트리에 연결되어 있지 않기 때문에 언제나 직속 부모 노드에게만 알린다.\n자식 노드에게만 변화를 알리는 형태의 전략을 취한다면 노드의 변화를 알리기 위한 비용을 많이 절감시킬 수 있다.</p>\n<p>따라서 전략은 표현하고 있는 트리에 따라서, 혹은 변경사항들이 트리의 위쪽이나 아래쪽에 어떻게 알려져야 하는지에 따라서 달라질 수 있다.\n핵심은 노드 삽입 전략을 둘 다 선택해서는 안 되고, 단 하나만을 선택해야 한다는 것이다.</p>\n<hr>\n<h1 id=\"변경-사항이-적용되는-방식-how-changes-are-applied\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%98%EB%8A%94-%EB%B0%A9%EC%8B%9D-how-changes-are-applied\" aria-label=\"변경 사항이 적용되는 방식 how changes are applied permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항이 적용되는 방식 (How changes are applied)</h1>\n<p>클라이언트 라이브러리는 Applier 인터페이스에 대한 구현을 제공한다.\n그중 하나가 Android UI에서 사용되는 UiApplier다.\nUiApplier는 “노드 적용”의 의미를 내포하며, 디바이스 스크린에서 볼 수 있는 구성 요소를 어떻게 생성하는지 보여주는 완벽한 예시다.</p>\n<p>구현체를 살펴보면 별로 거창하지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">class</span> <span class=\"token function\">UiApplier</span><span class=\"token punctuation\">(</span>\n    root<span class=\"token operator\">:</span> LayoutNode\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> AbstractApplier<span class=\"token operator\">&lt;</span>LayoutNode<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">insertTopDown</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> LayoutNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Ignored.</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">insertBottomUp</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> LayoutNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">insertAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">removeAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onClear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        root<span class=\"token punctuation\">.</span><span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>owner <span class=\"token keyword\">as</span><span class=\"token operator\">?</span> AndroidComposeView<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">clearInvalidObservations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>가장 먼저 볼 수 있는 것은 Applier 인터페이스의 제네릭 타입 N이 LayoutNode로 바뀌었다는 것이다.\n이는 렌더링될 UI 노드를 나타내기 위해 Compose UI가 선택한 노드 타입이다.</p>\n<p>다음으로 주목해야 할 점은 AbstractApplier를 상속받는 형태다.\n이는 방문한 노드를 스택에 저장하는 기본 구현체다.\n트리 하단에서 새 노드를 방문할 때마다 스택에 추가하고, 방문자가 위로 이동할 때마다 마지막으로 방문한 노드를 스택 상단에서 제거한다.\n일반적으로 여러 Applier 간에 공통적으로 사용되는 스펙이기 때문에 추상 클래스로 만든 것이다.</p>\n<p>Android의 경우 노드 삽입이 상향식으로만 수행되기 때문에 UiApplier에서 insertTopDown이 무시되는 것을 확인할 수 있다.\n노드 선택 전략은 둘 중 하나를 선택하는 것이 중요하다.\n이 경우 새 하위 항목이 삽입될 때마다 중복되는 노드 알림을 방지하려면 상향식 전략이 더 적합하다.</p>\n<p>노드를 삽입, 제거, 이동하는 방법은 모두 노드 자체에 위임된다.\nLayoutNode는 Compose UI가 UI 노드를 모델링하는 방법이므로 상위 노드와 하위 노드에 관한 모든 것을 알고 있다.\n노드를 삽입한다는 것은 해당 노드를 주어진 위치의 새 부모 노드에 연결하는 것을 의미한다.\n노드를 이동한다는 것은 본질적으로 부모 노드의 자식 노드들을 재정렬하는 것을 의미한다.\n노드를 제거한다는 것은 단순히 목록에서 해당 노드를 제거하는 것을 의미한다.</p>\n<p>변경사항 적용이 끝나면 <code class=\"language-text\">onEndChanges()</code>를 호출할 수 있다.\n이는 최종적인 요구사항을 루트 노드 소유자에게 위임한다.\n변경사항을 적용하기 전에 항상 <code class=\"language-text\">onBeginChanges()</code>가 먼저 호출된다고 가정되므로 <code class=\"language-text\">onEndChanges()</code>는 마지막에 호출해야 한다.</p>\n<p><code class=\"language-text\">onEndChanges()</code>가 호출된 시점에서 모든 보류 중인 무효화된 관찰들이 해제된다.\n이 스냅샷 관찰들은 읽고 의존하는 값이 변경될 때 자동으로 레이아웃이나 화면에 그리는 작업을 다시 호출하기 위한 것이다.\n트리에서 노드가 추가되거나 삽입되거나 교체되거나 이동되는 것이 레이아웃 크기의 측정이나 구성 등에 어떻게 영향을 미칠 수 있는지 생각해보자.</p>\n<hr>\n<h1 id=\"노드-연결-및-그리기-attaching-and-drawing-the-nodes\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%EC%97%B0%EA%B2%B0-%EB%B0%8F-%EA%B7%B8%EB%A6%AC%EA%B8%B0-attaching-and-drawing-the-nodes\" aria-label=\"노드 연결 및 그리기 attaching and drawing the nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 연결 및 그리기 (Attaching and drawing the nodes)</h1>\n<p>트리에 노드를 삽입하면 어떻게 화면에 나타날까?\n노드는 스스로 연결하고 그리는 방법을 알고 있다.</p>\n<p>UiApplier가 LayoutNode에게 삽입을 위임하면 다음 순서로 진행된다.\n조건 확인 (부모 노드 없는지 등), Z 인덱스 정렬된 자식 목록 invalidate, 부모 노드와 Owner에 연결, invalidate 수행.</p>\n<p>Owner는 트리의 루트에 존재한다.\nComposable 트리를 안드로이드 뷰 시스템과 연결하는 통합 계층이다.\nAndroidComposeView(표준 View)로 구현된다.\n모든 레이아웃, 그리기, 입력, 접근성은 Owner를 통해 연결된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACKUlEQVR42mNgoAv4/58RRCnO/ixuvfJPrdO6P3WOa//UWq743WKy6KcOWE39fybiDYQq1l77U997//9/6af//08/9e9P0Kn//y02/4kGydnv/89Cukt3/udmuPzfVOnIfy/Dg1+DGc78N+c5918U2RfE+ZiBAaz4NWeS1H+hgt7/qtVT/+rWzfwvVjT1J3+2EURNPRMJBkIUv1Ro0v+rM+nff6uZ///ZzPzz33j2/88qbWAv/7evZyHBQIh3NkyeI3U2tMvjPkOs5m3WOO1LNrX227pm60F8jMfL/xlCmUH0c9mK8PfKdcc/abdu/6TVsuedWv2WHRbJQsiufqZe2/FJrfkYUM22zxotB1/KVfdjGgh1/lu5qtL/xpP/f7fs//XXbur/b6rN746LRYiD5M4wpLGC6A+yNWv+W0z7/92q/8d/2+n/P8rXHcRMJUDb6+3tWWYyMLCuyGs0nWuTKLosuVJvkW+OYj0DA1M91HWrGBiYJwqZ8a3KbrScyKDCtyKz1nRBaKE0UIqxHjmSHitXxL437fj60ab3xXuzzpvn5HK13hm2Hv1g0/vyg0X37xdaDYXreAOE3+u3vfpo0/f8vVXPq0fKlbnvjNsufbDte/nOvPPXU/WaKLiBz5SqTD7otXYBNbS+0WqsuyKaJfFWq6H4vX572wedlr7n6tUOi8Rdud/rNLd81Gtteafb3HFfvtzhjXZj1Xu9ttZ32i29z5RrjWmSbQGL/PrNKxYmiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4\"\n        title=\"\"\n        src=\"/static/c65103cb98020ebdff04da2997ed8ae7/37523/4.png\"\n        srcset=\"/static/c65103cb98020ebdff04da2997ed8ae7/e9ff0/4.png 180w,\n/static/c65103cb98020ebdff04da2997ed8ae7/f21e7/4.png 360w,\n/static/c65103cb98020ebdff04da2997ed8ae7/37523/4.png 720w,\n/static/c65103cb98020ebdff04da2997ed8ae7/302a4/4.png 1080w,\n/static/c65103cb98020ebdff04da2997ed8ae7/07a9c/4.png 1440w,\n/static/c65103cb98020ebdff04da2997ed8ae7/84bc0/4.png 3176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>LayoutNode는 Owner와 연결되어야 화면에 나타난다.\nOwner는 setContent 호출 시 설정된다.\nActivity, Fragment, ComposeView에서 setContent를 호출하면 AndroidComposeView가 생성되어 View 계층에 연결되고 Owner로 설정된다.</p>\n<hr>\n<h1 id=\"composition\" style=\"position:relative;\"><a href=\"#composition\" aria-label=\"composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition</h1>\n<p>Composer가 Composition에 대한 참조를 가지고 있어서 Composer가 Composition을 생성하고 소유한다고 생각할 수 있다.\n하지만 실제로는 그 반대다.\nComposition이 생성되면 Composer는 스스로 구축한다.\nComposer는 currentComposer 메커니즘을 통해 접근할 수 있으며, Composition이 관리하는 트리를 생성하고 업데이트하는 데 사용된다.</p>\n<p>클라이언트 라이브러리는 두 가지 진입점을 통해 Jetpack Compose Runtime에 접근한다.</p>\n<p>Composable 함수 작성: 관련된 모든 정보를 방출하고 런타임과 연결한다.\nsetContent: 대상 플랫폼과의 통합 계층. Composition이 생성되고 시작된다. Composable 함수는 Composition 프로세스 없이는 실행되지 않기 때문에 필요하다.</p>\n<hr>\n<h1 id=\"composition-생성하기-creating-a-composition\" style=\"position:relative;\"><a href=\"#composition-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0-creating-a-composition\" aria-label=\"composition 생성하기 creating a composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition 생성하기 (Creating a Composition)</h1>\n<p>Android에서는 <code class=\"language-text\">ViewGroup.setContent</code> 호출로 새 composition을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doSetContent</span><span class=\"token punctuation\">(</span>\n    owner<span class=\"token operator\">:</span> AndroidComposeView<span class=\"token punctuation\">,</span>\n    parent<span class=\"token operator\">:</span> CompositionContext<span class=\"token punctuation\">,</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Composition <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> original <span class=\"token operator\">=</span> <span class=\"token function\">Composition</span><span class=\"token punctuation\">(</span><span class=\"token function\">UiApplier</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> wrapped <span class=\"token operator\">=</span> <span class=\"token function\">WrappedComposition</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">,</span> original<span class=\"token punctuation\">)</span>\n    wrapped<span class=\"token punctuation\">.</span><span class=\"token function\">setContent</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> wrapped\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>WrappedComposition은 Composition을 AndroidComposeView에 연결하는 데코레이터다.\n안드로이드 Context 정보를 CompositionLocal로 제공한다.\nUiApplier는 트리의 루트 LayoutNode를 가리킨다.\n클라이언트 라이브러리가 Applier 구현을 선택한다.</p>\n<p>VectorPainter는 자신만의 Composition을 생성한다.\nVectorApplier를 사용하며 벡터 트리의 루트 노드(VNode)를 가리킨다.\nSubcomposeLayout도 자체 Composition을 유지한다. 측정 단계에서 내용을 하위 구성할 수 있다.</p>\n<p>상위 CompositionContext를 전달하면 새 composition을 기존 composition에 논리적으로 연결한다.\ninvalidation과 CompositionLocal이 전체에서 동일하게 작동한다.\nrecomposition 컨텍스트로 변경사항을 적용할 CoroutineContext를 지정할 수 있다.\n제공하지 않으면 EmptyCoroutineContext가 사용된다.</p>\n<p>Composition은 더 이상 필요하지 않으면 <code class=\"language-text\">composition.dispose()</code>로 폐기해야 한다.</p>\n<hr>\n<h1 id=\"초기-composition-과정-the-initial-composition-process\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0-composition-%EA%B3%BC%EC%A0%95-the-initial-composition-process\" aria-label=\"초기 composition 과정 the initial composition process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기 Composition 과정 (The initial Composition process)</h1>\n<p><code class=\"language-text\">composition.setContent(content)</code>가 호출되면 슬롯 테이블이 데이터로 채워진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">setContent</span><span class=\"token punctuation\">(</span>content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>composable <span class=\"token operator\">=</span> content\n    parent<span class=\"token punctuation\">.</span><span class=\"token function\">composeInitial</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> composable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>상위로 계속 위임하다가 결국 Recomposer가 초기 composition을 수행한다.</p>\n<p>모든 State 객체의 현재 값을 스냅샷으로 취합한다.\n이 스냅샷은 가변적이지만 동시성에 안전하다.\nState 변경사항은 해당 객체에만 발생하고 나중에 전역 상태와 원자적으로 동기화된다.\n<code class=\"language-text\">snapshot.enter(block)</code> 안에서만 State 값 수정 가능하다.\nRecomposer는 State 읽기/쓰기 관찰자를 전달해서 composition에 알린다.</p>\n<p><code class=\"language-text\">composition.composeContent(content)</code>가 실행되고 Composer가 실제 composition을 수행한다.\n완료되면 <code class=\"language-text\">snapshot.apply()</code>로 변경사항을 전역 상태에 전파한다.</p>\n<p>진행 중이면 재진입 불가. 보류 중인 invalidation을 복사하고, isComposing을 true로 설정한다.\n<code class=\"language-text\">startRoot()</code> → <code class=\"language-text\">startGroup</code> → content 람다 호출 → <code class=\"language-text\">endGroup</code> → <code class=\"language-text\">endRoot()</code> 순으로 진행한다.\n완료 후 <code class=\"language-text\">isComposing</code>을 <code class=\"language-text\">false</code>로 변경하고 임시 데이터를 삭제한다.</p>\n<hr>\n<h1 id=\"초기-composition-후-변경-사항-적용-applying-changes-after-initial-composition\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0-composition-%ED%9B%84-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EC%A0%81%EC%9A%A9-applying-changes-after-initial-composition\" aria-label=\"초기 composition 후 변경 사항 적용 applying changes after initial composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기 Composition 후 변경 사항 적용 (Applying changes after initial Composition)</h1>\n<p>초기 composition 이후 Applier는 <code class=\"language-text\">composition.applyChanges()</code> 프로세스 중에 기록된 모든 변경사항을 적용하라는 알림을 받는다.</p>\n<p><code class=\"language-text\">applier.onBeginChanges()</code>를 호출하고 모든 변경사항을 실행한다.\n필요한 Applier와 SlotWriter 인스턴스를 각 변경사항에 전달한다.\n마지막으로 모든 변경사항이 적용된 후 <code class=\"language-text\">applier.onEndChanges()</code>를 호출한다.</p>\n<p>등록된 모든 RememberedObserver를 전달하므로 RememberObserver 계약을 구현하는 모든 클래스는 composition에 들어가거나 나갈 때 알림을 받을 수 있다.\n<code class=\"language-text\">LaunchedEffect</code>나 <code class=\"language-text\">DisposableEffect</code> 같은 항목이 RememberedObserver를 구현하므로 composition 내의 Composable 수명 주기에 대한 이펙트를 제한할 수 있다.</p>\n<p>그 직후 모든 사이드 이펙트들은 기록된 순서대로 실행된다.</p>\n<hr>\n<h1 id=\"composition에-대한-추가-정보-additional-information-about-the-composition\" style=\"position:relative;\"><a href=\"#composition%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%B3%B4-additional-information-about-the-composition\" aria-label=\"composition에 대한 추가 정보 additional information about the composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition에 대한 추가 정보 (Additional information about the Composition)</h1>\n<p>Composition은 보류 중인 invalidation을 인지하고 있다.\n<code class=\"language-text\">isComposing</code> 플래그로 현재 composition 수행 중인지 알고 있어서 invalidation을 즉시 적용하거나 연기할 수 있다.</p>\n<p>런타임은 ControlledComposition에 의존한다.\nRecomposer가 invalidation과 recomposition을 조율할 수 있게 해준다.</p>\n<p>Composition은 관찰 중인 객체들이 변경되면 recomposition을 강제할 수 있다.\n상위 composition에서 CompositionLocal이 변경되면 하위 composition도 recomposition된다.</p>\n<p>오류 발견 시 composition을 중단하고 Composer를 재설정한다.\ncurrentRecomposeScope가 recomposition을 요구하지 않으면 건너뛴다.</p>\n<hr>\n<h1 id=\"recomposer-the-recomposer\" style=\"position:relative;\"><a href=\"#recomposer-the-recomposer\" aria-label=\"recomposer the recomposer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer (The Recomposer)</h1>\n<p>Recomposer는 ControlledComposition을 제어한다.\n필요할 때 recomposition을 트리거하고 변경사항들을 적용한다.\ncomposition이나 recomposition할 스레드와 변경사항을 적용할 스레드를 결정한다.</p>\n<hr>\n<h1 id=\"recomposer-생성-spawning-the-recomposer\" style=\"position:relative;\"><a href=\"#recomposer-%EC%83%9D%EC%84%B1-spawning-the-recomposer\" aria-label=\"recomposer 생성 spawning the recomposer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer 생성 (Spawning the Recomposer)</h1>\n<p>루트 composition의 부모가 Recomposer가 된다.</p>\n<p>Android의 <code class=\"language-text\">ViewGroup.setContent</code>를 호출하면 WindowRecomposerFactory가 Recomposer를 생성한다.\n생성된 Recomposer는 수명 주기를 인식해서 뷰 트리가 연결되지 않으면 취소된다.</p>\n<p>AndroidUiDispatcher는 Choreographer와 메인 Looper의 핸들러와 연결된다.\nMonotonicFrameClock과도 연결되어 프레임 렌더링을 조정한다.</p>\n<p>PausableMonotonicFrameClock을 생성한다.\nWindow가 보이지 않을 때 이벤트 전달을 일시 중지할 수 있다.</p>\n<p>Recomposer 인스턴스화 시 CoroutineContext를 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> contextWithClock <span class=\"token operator\">=</span> currentThreadContext <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>pausableClock <span class=\"token operator\">?:</span> EmptyCoroutineContext<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> recomposer <span class=\"token operator\">=</span> <span class=\"token function\">Recomposer</span><span class=\"token punctuation\">(</span>effectCoroutineContext <span class=\"token operator\">=</span> contextWithClock<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 컨텍스트는 변경사항을 적용하고 <code class=\"language-text\">LaunchedEffect</code>에서 이펙트를 실행하는 데 사용된다.</p>\n<p>뷰 트리 수명 주기에 관찰자를 연결한다.\n<code class=\"language-text\">onCreate</code> 시 <code class=\"language-text\">recomposer.runRecomposeAndApplyChanges()</code>로 recomposition 작업을 시작한다.\n<code class=\"language-text\">onStart</code>/<code class=\"language-text\">onStop</code> 시 이벤트 재개/일시 중지, <code class=\"language-text\">onDestroy</code> 시 Recomposer 종료.</p>\n<p>이 함수는 invalidation을 기다리고 recomposition한 후 변경사항을 적용한다.</p>\n<hr>\n<h1 id=\"recomposition-프로세스-recomposition-process\" style=\"position:relative;\"><a href=\"#recomposition-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-recomposition-process\" aria-label=\"recomposition 프로세스 recomposition process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposition 프로세스 (Recomposition process)</h1>\n<p><code class=\"language-text\">recomposer.runRecomposeAndApplyChanges()</code> 호출 시 invalidation을 기다리다가 발생하면 자동으로 recomposition한다.</p>\n<p>먼저 변경사항 전파 프로세스에 관찰자를 등록한다.\n상태 변경 시 자동으로 recomposition을 트리거한다.</p>\n<p>Recomposer는 모든 Composition을 invalidate하고 모든 것이 변경되었다고 가정한다.\n이전 변경사항은 추적되지 않았으니 처음부터 기록한다.\n보류 중인 invalidation이 유입될 때까지 작업을 지연한다.</p>\n<p><code class=\"language-text\">parentFrameClock.withFrameNanos {}</code>를 호출하고 다음 프레임을 기다린다.\n블록 내에서 모노리틱 클럭 프레임을 애니메이션 같은 대기자에게 전달한다.\n이로 인해 새로운 invalidation이 발생할 수 있다.</p>\n<p>보류 중인 모든 스냅샷에 대해 invalidation을 수행한다.\n마지막 recomposition 이후 수정된 모든 상태 값을 가져와 보류 중인 recomposition으로 기록한다.</p>\n<p>각 composition에 대해 recomposition을 수행하고 변경사항 적용을 보류 목록에 추가한다.\nRecomposition은 Composition 상태(슬롯 테이블)와 구체화된 트리(Applier)에 필요한 모든 변경을 다시 계산하는 것이다.\n값 변경으로 다시 composition을 수행해야 하는 잠재적인 recomposition을 찾아내고 작업으로 예약한다.\n적용할 변경사항이 있는 모든 Composition을 검토하고 <code class=\"language-text\">composition.applyChanges()</code>를 호출한다.</p>\n<hr>\n<h1 id=\"recomposition의-동시성-concurrent-recomposition\" style=\"position:relative;\"><a href=\"#recomposition%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-concurrent-recomposition\" aria-label=\"recomposition의 동시성 concurrent recomposition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposition의 동시성 (Concurrent recomposition)</h1>\n<p>Recomposer는 recomposition을 동시에 수행할 수 있는 기능이 있다.\nCompose UI는 이 기능을 사용하지 않지만 다른 클라이언트 라이브러리는 필요에 따라 사용할 수 있다.\n<code class=\"language-text\">runRecomposeConcurrentlyAndApplyChanges</code> 함수로 recomposition을 동시에 대응할 수 있다.\n상태 스냅샷 invalidation을 기다리고 자동으로 recomposition을 트리거하는 suspend 함수다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">runRecomposeConcurrentlyAndApplyChanges</span><span class=\"token punctuation\">(</span>\n    recomposeCoroutineContext<span class=\"token operator\">:</span> CoroutineContext\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">runRecomposeAndApplyChanges</code>와의 차이점은 외부에서 제공되는 CoroutineContext를 사용하여 invalidation된 Composition의 recomposition을 수행한다는 점이다.</p>\n<p>전달된 컨텍스트로 자체 CoroutineScope를 생성하고 이를 사용하여 필요한 모든 recomposition을 동시에 수행하기 위한 하위 작업을 생성하고 조정한다.</p>\n<hr>\n<h1 id=\"recomposer의-상태-recomposer-states\" style=\"position:relative;\"><a href=\"#recomposer%EC%9D%98-%EC%83%81%ED%83%9C-recomposer-states\" aria-label=\"recomposer의 상태 recomposer states permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer의 상태 (Recomposer states)</h1>\n<p>Recomposer는 수명 주기를 나타내는 일련의 상태를 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> State <span class=\"token punctuation\">{</span>\n    ShutDown<span class=\"token punctuation\">,</span>\n    ShuttingDown<span class=\"token punctuation\">,</span>\n    Inactive<span class=\"token punctuation\">,</span>\n    InactivePendingWork<span class=\"token punctuation\">,</span>\n    Idle<span class=\"token punctuation\">,</span>\n    PendingWork\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 상태의 의미는 다음과 같다.</p>\n<p><strong>ShutDown</strong>: Recomposer가 취소되고 정리 작업이 완료되었다. 더 이상 사용할 수 없다.</p>\n<p><strong>ShuttingDown</strong>: Recomposer가 취소되었지만 여전히 정리 작업 중이다. 더 이상 사용할 수 없다.</p>\n<p><strong>Inactive</strong>: Recomposer는 Composer의 invalidation을 무시하고 recomposition을 트리거하지 않는다. Recomposition 관찰을 시작하려면 <code class=\"language-text\">runRecomposeAndApplyChanges</code>를 호출해야 한다. 생성 후 Recomposer의 초기 상태다.</p>\n<p><strong>InactivePendingWork</strong>: Recomposer가 비활성 상태이지만 이미 프레임을 기다리는 보류 중인 이펙트가 있을 가능성이 있다. 프레임은 Recomposer가 실행을 시작하자마자 생성된다.</p>\n<p><strong>Idle</strong>: Recomposer가 composition 및 스냅샷 invalidation을 추적하고 있지만 현재 수행할 작업이 없다.</p>\n<p><strong>PendingWork</strong>: Recomposer가 보류 중인 작업에 대해 알림을 받았으며 이미 작업을 수행 중이거나 수행할 기회를 기다리고 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","frontmatter":{"date":"2025.12.07","title":"3장 - Compose 런타임 (The Compose runtime)","categories":"ComposeInternals","author":"Winter","emoji":null},"fields":{"slug":"/composeinternals/3-the-compose-runtime/"}},"prev":{"id":"de5557fe-3243-5d29-8bd9-e0f4eaa98089","html":"<blockquote>\n<p>러프하게 초안 정리 상태</p>\n</blockquote>\n<h1 id=\"코루틴-빌더\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4-%EB%B9%8C%EB%8D%94\" aria-label=\"코루틴 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴 빌더</h1>\n<p>중단 함수는 컨티뉴에이션 객체를 다른 중단 함수로 전달해야 한다.\n(4장에서 다뤘는데, 중단 함수들의 콜스택과 연결되는 개념이다)</p>\n<p>그래서 일반 함수가 중단 함수를 호출 할수는 없지만\n중단 함수는 일반 함수를 실행할 수 있다.</p>\n<p>우리는 지금까지\n중단 함수는 코루틴을 실행할 수 있으며\n코루틴은 함수를 일시중단 할 수 있다고 배웠다.</p>\n<p>그렇다면 중단 함수는 처음에 어떻게 실행 되는가?\n이것을 시작하는 지점이 코루틴 빌더다.</p>\n<p>계층으로 표현해본다면 이런 느낌?</p>\n<ul>\n<li>코루틴 빌더\n<ul>\n<li>중단 함수 or 코루틴</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"launch-빌더\" style=\"position:relative;\"><a href=\"#launch-%EB%B9%8C%EB%8D%94\" aria-label=\"launch 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>launch 빌더</h2>\n<p>새로운 일시중단 가능한 분기를 생성한다.\nlaunch 는 몇 번이든 호출하여 새로운 분기를 만들 수 있다.</p>\n<h2 id=\"runblocking-빌더\" style=\"position:relative;\"><a href=\"#runblocking-%EB%B9%8C%EB%8D%94\" aria-label=\"runblocking 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>runBlocking 빌더</h2>\n<p>이 빌더가 실행된 스레드가 중단된다.</p>\n<h2 id=\"async-빌더\" style=\"position:relative;\"><a href=\"#async-%EB%B9%8C%EB%8D%94\" aria-label=\"async 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async 빌더</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">async <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 비동기 태스크</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>비동기 태스크를 async 블록으로 감싸면 비동기 태스크가 실행되며 Deferred 타입을 반환한다.\ndeferred 객체의 await() 을 호출하면 결과 값을 반환 받을수 있다.\nawait() 를 특정 시점에서 병렬로 호출하는 응용이 가능하다.</p>\n<h2 id=\"coroutinescope-사용하기\" style=\"position:relative;\"><a href=\"#coroutinescope-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"coroutinescope 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>coroutineScope 사용하기</h2>\n<h1 id=\"코루틴-컨텍스트\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8\" aria-label=\"코루틴 컨텍스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴 컨텍스트</h1>\n<h2 id=\"coroutinecontext-인터페이스\" style=\"position:relative;\"><a href=\"#coroutinecontext-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"coroutinecontext 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CoroutineContext 인터페이스</h2>\n<p>Job, CoroutineName, CoroutineDispatcher 와 같은\n원소나 원소의 집합을 나타내는 인터페이스다.</p>\n<h2 id=\"컨텍스트-더하기\" style=\"position:relative;\"><a href=\"#%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%8D%94%ED%95%98%EA%B8%B0\" aria-label=\"컨텍스트 더하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컨텍스트 더하기</h2>\n<p>val ctx1 = CoroutineName(“one”)\nval ctx2 = CoroutineName(“two”)</p>\n<p>ctx1 + ctx2</p>\n<p>덧셈식으로 더할 수 있으며\n새로운 원소 ctx2 가 기존 원소를 대체할 수 있다.</p>\n<h2 id=\"비어있는-코루틴-컨텍스트\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8\" aria-label=\"비어있는 코루틴 컨텍스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비어있는 코루틴 컨텍스트</h2>\n<p>EmptyCoroutineContext</p>\n<h2 id=\"코루틴-컨텍스트와-빌더\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%A3%A8%ED%8B%B4-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%EB%B9%8C%EB%8D%94\" aria-label=\"코루틴 컨텍스트와 빌더 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코루틴 컨텍스트와 빌더</h2>\n<h1 id=\"잡과-자식-코루틴-기다리기\" style=\"position:relative;\"><a href=\"#%EC%9E%A1%EA%B3%BC-%EC%9E%90%EC%8B%9D-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B8%B0%EB%8B%A4%EB%A6%AC%EA%B8%B0\" aria-label=\"잡과 자식 코루틴 기다리기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잡과 자식 코루틴 기다리기</h1>\n<p><strong>Job 이란?</strong>\nJob 은 수명을 가지고 있으며 취소 가능하다.\nJob 의 수명은 상태로 나타낸다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACkElEQVR42sVU22uSYRxebWyDHauLHBHEt9ih1YqiLupCCKp/YCPY3YL6B7ouYXTXxYJoC0YImheJMkXxgIiUJnNqU+Zhns/icYnHlOzreQeKioIR0Qc/vpff+37P7/d7nuf9Bgb+9yOXy2cQNw0Gww2TyXRNqVTeUigUCzRNn+4bBIdPkbfNZhsvFAr+arVas9vtJavVWigWi6VKpfIjEonc/5PGTgA1Gs1oNpvdKJfLmx6PZxMFtlHgdT6ff+P3++fbOiAtdwaLxeo5Bp/PH2az2dOtBf/qAeAU4gJZr66uDrZthkIhChw883q96z6f70k0Gl13uVxPg8HgikgkmkAnoyTIOp1Or2E8FsZ9ZbFYXjqdzo1EIvE8EAgwmoDHx8drqVSKPjw8rDscjl8AquMgDWC/Wq1e2t3dvUgCHF6q1WopCEG73e6fEKYej8froIeOxWKPmoB7e3uTBwcHS+huzmg03jObzcuouIguKbKv0+km9Hr9WbJGV3PIL6L4dcRdFJ0H+BXkx7paQyqVMmQy2Ugr2SqVakosFi+35E9E4XK5kz1FaRiTGJfYg6wbKhPuAHqutbBWqz2D4lRrru8OUWBcIBBQeDPA7ycIYsaI+xj9G8z9FXxbk8nkw64dCoXCmU5AUoyojKs2BW4/AmQf4n0BdwTsM9ZGiPKga4dkZCg63YcPexubw+GM8Xi8BVhkViKRXIUA5/HBIJPJHOosinMU9i+DUwqTzBKeEcNtoLlc7jH8RHxYAjeVo6Oj7xijDF4MAGmCYsQRjGYBdzSsVSA/CHyTAQ3VTCaz0gQE2G3EDoDe4tK/gx+3cGs+IMcinTbOQZQh5F4AYAfCbOHcNtbvccvY4XD4zj/5Yf4GIDb9dRulM7oAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/481286ca0c2d6eb302ec320e3d578fa6/37523/0.png\"\n        srcset=\"/static/481286ca0c2d6eb302ec320e3d578fa6/e9ff0/0.png 180w,\n/static/481286ca0c2d6eb302ec320e3d578fa6/f21e7/0.png 360w,\n/static/481286ca0c2d6eb302ec320e3d578fa6/37523/0.png 720w,\n/static/481286ca0c2d6eb302ec320e3d578fa6/302a4/0.png 1080w,\n/static/481286ca0c2d6eb302ec320e3d578fa6/07a9c/0.png 1440w,\n/static/481286ca0c2d6eb302ec320e3d578fa6/1321a/0.png 3086w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>잡의 상태를 확인하기 위해서는 <code class=\"language-text\">isActive</code>, <code class=\"language-text\">isCompleted</code>, <code class=\"language-text\">isCancelled</code> 프로퍼티를 사용하면 된다.</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>isActive</th>\n<th>isCompleted</th>\n<th>isCancelled</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>New (optional initial state)</td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n<tr>\n<td>Active (default initial state)</td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n<tr>\n<td>Completing (transient state)</td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n<tr>\n<td>Cancelling (transient state)</td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">true</code></td>\n</tr>\n<tr>\n<td>Cancelled (final state)</td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">true</code></td>\n</tr>\n<tr>\n<td>Completed (final state)</td>\n<td><code class=\"language-text\">false</code></td>\n<td><code class=\"language-text\">true</code></td>\n<td><code class=\"language-text\">false</code></td>\n</tr>\n</tbody>\n</table>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABqElEQVR42r2Syy8DURTGB30/EAsSgrCoRCxEWNkQia1FN1hIENV2HpogHiFWQhCxUlSIEGlR2umLir1qIwQL/Cno595pOy0bkYhJvpybme/+zplzDqPjAvhLMf8GVHMhqNJScmFJGi74M1DDijAKQej57EstuVjKH6NK8KCCP0K14EYl70YJfwaDEJL9BhIL6TkXuBB5Qf6wD0Vpk54ToWJDaHDso4nbQKOwjRZuHa0jTgL3gLGIUFh9kldt96PA6gctSgaCPPPhZzCDpzAQE81OL3SsxdC7ew/L4SMGDp7QunIN82YC3Vs36HHF0b97C7Mzhr6dBGqmogQuSkmY948kvkNpprLRMEwzUdQR0Vg+HoFp9hK101FY9u9gP3xAlzMOwfOI+rkrKG3+FJDiMtDF8xcwQ2cSVMsGoCAmhTUlWgGN+VYRzRMetE/soW3Mhc7JHVQ4TqFmU72UfjkXunTxKkOp9BlxAXlwWhv5bvOi2H4Co90LHev/2kMJmkzK0NXLV+RZfGTagS8TzCoobYKGrBSVLmedZGAKCrylocukUhVt9C8X+xMldRJz1E6XrgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/4b408a31e407236aee179777c392489b/37523/cover.png\"\n        srcset=\"/static/4b408a31e407236aee179777c392489b/e9ff0/cover.png 180w,\n/static/4b408a31e407236aee179777c392489b/f21e7/cover.png 360w,\n/static/4b408a31e407236aee179777c392489b/37523/cover.png 720w,\n/static/4b408a31e407236aee179777c392489b/0a867/cover.png 986w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","frontmatter":{"date":"2026.02.08","title":"코루틴 취소, 예외처리, 스코프 함수 (Coroutine DEEP DIVE)","categories":"Coroutine","author":"Winter","emoji":null},"fields":{"slug":"/coroutine-deep-dive/2-coroutine-builder-context-job-and-wait-children/"}},"site":{"siteMetadata":{"siteUrl":"https://www.winter-love.dev","comments":{"utterances":{"repo":"winter-love-dev/winter-love-dev.github.io"}}}}},"pageContext":{"slug":"/coroutine-deep-dive/1-understnad-kotlin-coroutine/","nextSlug":"/composeinternals/3-the-compose-runtime/","prevSlug":"/coroutine-deep-dive/2-coroutine-builder-context-job-and-wait-children/"}},"staticQueryHashes":["1073350324","1321836341","3350743975","339315159","3586530715","988760642"],"slicesMap":{}}
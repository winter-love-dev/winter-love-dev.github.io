{"componentChunkName":"component---src-templates-content-template-js","path":"/composeinternals/2-the-compose-compiler/","result":{"data":{"cur":{"id":"d9b8b773-3000-5ecd-83f2-9993680a657e","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<p>참고. compose architecture</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.555555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAArklEQVR42mNgAIL///8zAjETCDNAAYyPJMaIIQbUx1APZIMwiA0DB14dm7bn8eEHe54efrz37dHITWmbuE6fOX3l6NGjN0+dOnXvzJkzFidPnrQEsu8DxW6dOX/hwv8rWTx6i7/nOqz9+9Rl/d+7Zst/r4QbuO/F0Wk77u57sPP+PoiB9UADT5++cvDgwZvHjx+HG3jixIn7hw4dunXqzNkL/18iDHTdgGYgNb0MAMdIqi4GQCyQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/7970e338a20dbbf6b503a293a6823b5f/37523/0.png\"\n        srcset=\"/static/7970e338a20dbbf6b503a293a6823b5f/e9ff0/0.png 180w,\n/static/7970e338a20dbbf6b503a293a6823b5f/f21e7/0.png 360w,\n/static/7970e338a20dbbf6b503a293a6823b5f/37523/0.png 720w,\n/static/7970e338a20dbbf6b503a293a6823b5f/302a4/0.png 1080w,\n/static/7970e338a20dbbf6b503a293a6823b5f/07a9c/0.png 1440w,\n/static/7970e338a20dbbf6b503a293a6823b5f/58e49/0.png 4296w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 챕터를 읽기전에…\nCompose Compiler가 어떻게 동작하는지 내 기준 꽤 깊이 있게 살펴본다. 크게 세 부분으로 나뉜다.</p>\n<p><strong>Compose 어노테이션들</strong>  @Composable부터 @Stable, @Immutable까지 각 어노테이션이 무엇을 의미하고 왜 필요한지.</p>\n<p><strong>정적 분석과 검사</strong> 컴파일 단계에서 코드를 검증하고 오류를 잡아내는 과정.</p>\n<p><strong>코드 생성과 변환</strong> IR 낮추기(Lowering)를 통해 우리가 작성한 코드가 어떻게 변환되는지. Composer 주입, 비교 전파, 그룹 생성 등 실제 최적화 기법들.</p>\n<p>마음의 준비를 하자.\n내용이 많고 기술적인 용어들이 마구 언급되며, 챕터 자체의 분량이 꽤 길다.</p>\n<hr>\n<blockquote>\n<p><strong>IR:</strong> Intermediate Representation, Kotlin 컴파일러가 소스파일을 해석하는 하나의 과정.</p>\n</blockquote>\n<blockquote>\n<p><strong>Compose Compiler:</strong> Kotlin 컴파일러 플러그인. Composable 함수를 변환하는 역할.</p>\n</blockquote>\n<blockquote>\n<p><strong>Composer:</strong> 런타임중 트리의 형태를 빌드하거나 업데이트하는 객체.</p>\n</blockquote>\n<h1 id=\"compose-컴파일러-the-compose-compiler\" style=\"position:relative;\"><a href=\"#compose-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-the-compose-compiler\" aria-label=\"compose 컴파일러 the compose compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 컴파일러 (The Compose compiler)</h1>\n<p>Kotlin 에서 코드 생성이라고 하면 보통 kapt, KSP 를 떠올린다.\n하지만 Compose Compiler 는 KSP 같은 어노테이션 프로세서가 아니라 “Kotlin 컴파일러” 의 플러그인이다.</p>\n<p><strong>둘의 차이:</strong> <br/>\nKSP: 컴파일 전에 실행. 새 코드만 추가 가능. <br/>\n컴파일러 플러그인: 컴파일 중에 실행. 기존 코드 수정 가능. <br/></p>\n<p><a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#%ED%98%B8%EC%B6%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-calling-context\">이전 1장 글에서 봤던 Composer 파라미터 주입</a>\n이 바로 “기존 코드 수정”의 예시다. KSP 로는 불가능.</p>\n<p>Compose Compiler 는 IR (Intermediate Representation) 단계에서 코드를 변환한다.\nIR 은 소스 코드가 최종 결과물로 변환되기 전 중간 단계다.\n이 단계에서 Compose Compiler 는 우리가 작성한 Composable 함수를 Runtime 이 원하는 형태로 마음대로 바꿔버린다.</p>\n<p>예를 들어 우리가 작성한 <code class=\"language-text\">fun Header()</code> 는 컴파일 후에는 <code class=\"language-text\">fun Header($composer: Composer)</code> 로 변환된다.\n이게 IR 변환이다.</p>\n<p>핵심: IR 단계에서 코드를 변환하니까 우리 눈에 안 보이는 일들이 일어날 수 있다.</p>\n<p>@Composable 어노테이션은 단순 마커가 아니다. 함수의 타입 자체를 바꾼다.</p>\n<p>일반 함수 타입: <code class=\"language-text\">(String) -> Unit</code> <br/>\nComposable 함수 타입: <code class=\"language-text\">@Composable (String) -> Unit</code> <br/></p>\n<p>타입이 다르니까 컴파일러가 규칙을 강제할 수 있다.\n일반 함수에서 Composable 함수를 호출하면 컴파일 에러가 나는 이유다.\n그럼 타입을 바꾸면 뭐가 좋은가? Composable 함수에게 “메모리”가 생긴다.</p>\n<p>“메모리”가 생긴다는 의미: @Composable 이 붙으면 그 함수는 다음과 같이 동작하게 된다.</p>\n<p>remember 사용 가능 (값을 기억할 수 있음), Composer 와 슬롯 테이블 사용 가능,\n고유한 ID 를 할당받음 (1장의 위치 기억법), 트리 내 위치를 가짐,\n라이프사이클을 가짐 (recomposition 되어도 상태 유지 가능).</p>\n<p>이 모든 게 “메모리”다.\nComposable 함수가 실행될 때마다 매번 새로 시작하는 게 아니라, 이전 실행을 “기억”하고 있다는 뜻이다.\n결과적으로 Composable 함수는 노드를 방출해서 트리를 구성할 수 있게 된다.</p>\n<p>요약: @Composable 은 타입을 바꾸고, 타입이 바뀌면 메모리를 갖게 되고, 메모리가 있으니까 트리의 일부가 될 수 있다.</p>\n<hr>\n<h1 id=\"compose-어노테이션들-compose-annotations\" style=\"position:relative;\"><a href=\"#compose-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EB%93%A4-compose-annotations\" aria-label=\"compose 어노테이션들 compose annotations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 어노테이션들 (Compose annotations)</h1>\n<p>Compose Compiler가 코드를 변환하려면 먼저 어떤 함수가 Composable인지, 어떤 최적화를 적용해야 하는지 알아야 한다.\n이를 위해 어노테이션을 사용한다.</p>\n<p><strong>Compose Compiler의 작동 시점</strong>: Compose Compiler는 Kotlin 컴파일 과정 중 프론트엔드 단계에서 동작한다.\n이 단계에서 소스 코드를 분석하고 검증한다.</p>\n<p><strong>컴파일러가 확인하는 것들:</strong> <code class=\"language-text\">@Composable</code> 어노테이션이 붙은 함수들을 찾기,\nComposable 함수가 제약을 잘 지키고 있는지 검증 (다른 Composable에서만 호출되는지 등),\n타입 시스템이 Composable 함수를 일반 함수와 다르게 처리하도록 만들기</p>\n<p><strong>추가 어노테이션들</strong>: <code class=\"language-text\">@Composable</code> 외에도 Compose는 여러 어노테이션을 제공한다.\n이 어노테이션들은 특정 상황에서 추가 검사를 하거나 런타임 최적화를 활성화하는 역할을 한다.</p>\n<p>예를 들어 어떤 함수는 결과를 캐싱해도 되고, 어떤 함수는 안정적인 입력만 받아야 하고,\n어떤 함수는 리컴포지션을 Skip해도 된다는 힌트를 컴파일러에게 줄 수 있다.</p>\n<p>이런 어노테이션들은 모두 Compose Runtime 라이브러리에서 제공된다.</p>\n<hr>\n<h1 id=\"composable\" style=\"position:relative;\"><a href=\"#composable\" aria-label=\"composable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Composable</h1>\n<p>가장 중요한 어노테이션이다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%98%EB%AF%B8-the-meaning-of-composable-functions\">1장에서 이미 다뤘지만 (Composable 함수의 의미)</a>,\n컴파일러 관점에서 다시 한번 정리한다.</p>\n<p><strong>Compose Compiler vs 어노테이션 프로세서</strong>: 일반적인 어노테이션 프로세서: 새로운 코드만 생성 가능, 기존 코드를 직접 수정할 수 없음.</p>\n<p><strong>Compose Compiler:</strong> IR(중간 표현)을 직접 변환, 기존 코드를 수정할 수 있음.</p>\n<p><code class=\"language-text\">@Composable</code> 어노테이션이 붙으면 컴파일러가 해당 함수를 직접 변환한다.\n가장 중요한 변경은 <strong>함수의 타입이 바뀐다</strong>는 것이다.</p>\n<p><strong>타입 변경으로 얻는 것들</strong>: 타입이 바뀌면 컴파일러가 Composable 함수에 특별한 제약을 강제할 수 있다.\nComposable 함수는 다른 Composable 함수에서만 호출 가능하다는 규칙 같은 것들 말이다.\n하지만 제약만 생기는 게 아니다. <code class=\"language-text\">@Composable</code>을 통해 함수는 “메모리”를 갖게 된다.</p>\n<p><strong>메모리를 가진다는 의미:</strong>\n<code class=\"language-text\">remember</code>를 사용해서 값을 저장하고 재사용할 수 있음,\n<code class=\"language-text\">Composer</code>와 슬롯 테이블을 활용할 수 있음,\n라이프사이클을 가짐 (리컴포지션 되어도 상태 유지 가능),\n고유한 정체성(ID)을 부여받음 (<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#%EC%9C%84%EC%B9%98-%EA%B8%B0%EC%96%B5%EB%B2%95-positional-memoization\">위치 기억법에서 다뤘음</a>),\n노드를 Composition으로 방출할 수 있음,\nCompositionLocals 처리 가능.</p>\n<p><strong>Composable 함수의 본질</strong>: Composable 함수는 데이터를 트리의 노드로 변환한다.\n이 노드가 UI 노드일 수도 있고, 다른 종류의 노드일 수도 있다.\nCompose Runtime은 UI에만 국한되지 않는다.\n범용적인 트리 구조를 다루는 시스템이며, 우리가 어떻게 사용하느냐에 따라 UI가 될 수도, 다른 무언가가 될 수도 있다.</p>\n<hr>\n<h1 id=\"composablecompilerapi\" style=\"position:relative;\"><a href=\"#composablecompilerapi\" aria-label=\"composablecompilerapi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ComposableCompilerApi</h1>\n<p>Compose 컴파일러 전용 API라는 것을 표시하는 어노테이션이다.\n“이건 컴파일러가 내부적으로 쓰는 거니까 일반 개발자는 건드리지 마세요” 라는 경고 표시다.</p>\n<hr>\n<h1 id=\"internalcomposeapi\" style=\"position:relative;\"><a href=\"#internalcomposeapi\" aria-label=\"internalcomposeapi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@InternalComposeApi</h1>\n<p>Compose 내부에서만 사용하는 API라는 표시다.\nKotlin의 <code class=\"language-text\">internal</code> 키워드는 같은 모듈 안에서만 접근 가능하다.\n하지만 Compose는 여러 모듈로 나뉘어 있어서 모듈 간에 내부 API를 공유해야 할 때가 있다.\n<code class=\"language-text\">@InternalComposeApi</code>는 이런 경우에 사용한다.\n“Compose 내부에서는 쓰지만, 외부 개발자는 쓰지 마세요. 언제든 바뀔 수 있어요”라는 의미다.\nstable 버전에 포함되어도 내부 구현은 계속 바뀔 수 있기 때문에 이런 표시가 필요하다.</p>\n<hr>\n<h1 id=\"disallowcomposablecalls\" style=\"position:relative;\"><a href=\"#disallowcomposablecalls\" aria-label=\"disallowcomposablecalls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@DisallowComposableCalls</h1>\n<p>특정 람다 안에서 Composable 함수 호출을 금지하는 어노테이션이다.\n<strong>왜 필요한가?</strong> 대표적인 예시가 <code class=\"language-text\">remember</code>다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  <span class=\"token function\">remember</span><span class=\"token punctuation\">(</span>\n    calculation<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span> currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> calculation<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">remember</code>는 <code class=\"language-text\">calculation</code> 람다를 최초 1회만 실행하고 결과를 저장한다.\nrecomposition 시에는 저장된 값을 그냥 반환한다.\n만약 <code class=\"language-text\">calculation</code> 안에서 Composable 함수를 호출하면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> <span class=\"token keyword\">data</span> <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 🚨 만약 가능하다면?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">forEach</code>의 람다는 <code class=\"language-text\">@Composable</code>로 표시되어 있지 않지만,\n<code class=\"language-text\">MyScreen</code>이 Composable이므로 안에서 <code class=\"language-text\">Text</code>를 호출할 수 있다.\n이건 <code class=\"language-text\">forEach</code> 같은 경우에는 유용하지만, <code class=\"language-text\">remember</code> 같은 경우에는 문제가 된다.\n그래서 명시적으로 금지해야 한다.</p>\n<p><strong>전파성</strong>: <code class=\"language-text\">@DisallowComposableCalls</code>가 붙은 람다 안에서 또 다른 inline 람다를 호출하면,\n컴파일러는 그 람다에도 <code class=\"language-text\">@DisallowComposableCalls</code>를 요구한다.\n이 어노테이션은 주로 Compose Runtime 같은 라이브러리를 만들 때 사용한다.\n일반 앱 개발에서는 거의 쓸 일이 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span>\n    list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> item <span class=\"token operator\">-></span> item <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>  <span class=\"token comment\">// map의 람다도 금지됨</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h1 id=\"readonlycomposable\" style=\"position:relative;\"><a href=\"#readonlycomposable\" aria-label=\"readonlycomposable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ReadOnlyComposable</h1>\n<p><code class=\"language-text\">@ReadOnlyComposable</code> 이 붙은 Composable 함수는 composition 에 쓰지 않고 읽기만 한다는 의미다.\n본문 내 중첩된 모든 Composable 호출에도 적용된다.\n일반적인 Composable 함수는 컴파일러가 본문을 “그룹” 으로 감싸서 방출한다.\n그룹은 나중에 recomposition 할 때 데이터를 어떻게 정리하거나 이동시킬지에 대한 정보를 담고 있다.</p>\n<p><strong>그룹이 뭔가?</strong> 텍스트에서 시작과 끝을 가리키는 두 개의 포인터를 떠올려보자.\n모든 그룹에는 소스 코드 위치 키가 있고, 이 키로 위치 기억법을 적용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>둘 다 Text 함수지만 if 와 else 는 서로 다른 고유성을 가진다.\n그룹의 키가 이 고유성을 구분한다.\n이동 가능한 그룹은 고유한 키를 가지고 있어서 부모 그룹 내에서 재정렬될 수 있다.</p>\n<p>그런데 composition 에 쓰이지 않는 Composable 은 데이터가 교체되거나 이동되지 않으므로 그룹이 필요없다.\n@ReadOnlyComposable 은 이런 불필요한 코드 생성을 방지한다.</p>\n<p>실제 예시로는 CompositionLocal 을 통해 읽는 값들이 있다.\nMaterial 라이브러리의 Colors, Typography, isSystemInDarkTheme() 함수, LocalContext, LocalConfiguration 등이다.\n이런 값들은 단순히 읽기만 하지 쓰지 않는다.</p>\n<p>요약: 읽기만 하는 Composable 은 그룹이 필요없으니 성능 최적화를 위해 명시한다.</p>\n<hr>\n<h1 id=\"nonrestartablecomposable\" style=\"position:relative;\"><a href=\"#nonrestartablecomposable\" aria-label=\"nonrestartablecomposable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@NonRestartableComposable</h1>\n<p>@NonRestartableComposable 이 붙으면 해당 Composable 함수는 재시작이 불가능해진다.\n모든 Composable 이 기본적으로 재시작 가능한 건 아니다.\n인라인 Composable 이나 반환 타입이 Unit 이 아닌 Composable 은 원래 재시작할 수 없다.\n이 어노테이션을 추가하면 컴파일러가 recomposition 중에 함수를 재구성하거나 생략하는 데 필요한 보일러플레이트 코드를 생성하지 않는다.\n언제 쓰나? 다른 Composable 에 의해 recomposition 될 가능성이 희박한 경우다.\n논리가 거의 없어서 스스로 invalidation 시키는 게 의미 없는 함수들이다.\n이런 함수는 상위 Composable 에 의해서만 recomposition 되면 충분하다.\n실제 사용 사례는 매우 드물다.\n정확성을 위해 필요한 건 아니지만, 특수한 경우에 성능 최적화 기법으로 사용할 수 있다.</p>\n<p>요약: 재시작이 필요없는 Composable 에 붙여서 불필요한 코드 생성을 방지한다.</p>\n<hr>\n<h1 id=\"stablemarker\" style=\"position:relative;\"><a href=\"#stablemarker\" aria-label=\"stablemarker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@StableMarker</h1>\n<p>Compose Runtime 은 타입의 안정성을 나타내기 위해 몇 가지 어노테이션을 제공한다. <code class=\"language-text\">@StableMarker</code>, <code class=\"language-text\">@Immutable</code>, <code class=\"language-text\">@Stable</code>.</p>\n<p><code class=\"language-text\">@StableMarker</code> 는 <code class=\"language-text\">@Immutable</code> 과 <code class=\"language-text\">@Stable</code> 에 사용되는 메타 어노테이션이다.\n어노테이션을 위한 어노테이션이라고 보면 된다. <code class=\"language-text\">@StableMarker</code> 로 마킹된 타입은 다음 요구 사항을 만족해야 한다.\nequals 결과가 동일한 두 인스턴스에 대해 항상 동일하다,\npublic 프로퍼티가 변경되면 composition 에 알린다,\n모든 public 프로퍼티가 안정적이다.</p>\n<p>이 요구사항을 만족하면 컴파일러가 최적화할 수 있다.\n입력값이 안 바뀌었다는 걸 확신할 수 있으므로 recomposition을 Skip할 수 있다.</p>\n<p><code class=\"language-text\">@Immutable</code> 이나 <code class=\"language-text\">@Stable</code> 로 마킹된 모든 타입도 위 요구 사항을 만족해야 한다.\n둘 다 <code class=\"language-text\">@StableMarker</code> 를 사용하기 때문이다. 중요한 건 이게 컴파일러에게 하는 “약속” 이라는 점이다.\n컴파일 시 유효성 검사를 하지 않는다.\n요구 사항을 충족하는지는 개발자가 책임진다.\n대부분의 경우 Compose Compiler 가 알아서 타입의 안정성을 추론한다.\n굳이 어노테이션을 달지 않아도 컴파일러가 안정적인 타입으로 취급한다는 뜻이다.</p>\n<p>하지만 두 가지 경우엔 명시적으로 달아야 한다.\n<strong>인터페이스나 추상 클래스에서 구현체가 반드시 안정적이어야 한다고 강제하고 싶을 때.</strong>\n이 어노테이션은 컴파일러와의 약속이자 구현을 위한 요구 사항이 된다.\n구현체가 내부적으로 mutable 하지만 public API 는 안정적이어서 안정적인 타입으로 취급하고 싶을 때.\n예를 들어 내부 캐시는 변하지만 외부로 보이는 값은 변하지 않는 경우다.</p>\n<p>요약: <code class=\"language-text\">@StableMarker</code> 는 타입의 안정성을 컴파일러에게 약속하는 메타 어노테이션이다.</p>\n<hr>\n<h1 id=\"immutable\" style=\"position:relative;\"><a href=\"#immutable\" aria-label=\"immutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Immutable</h1>\n<p>한번 생성되면 절대 변하지 않는 타입을 표시하는 어노테이션이다.\nKotlin의 <code class=\"language-text\">val</code> 보다 강력한 약속으로서 재할당을 막지만, 불변성을 보장하진 않는다.\n<code class=\"language-text\">val</code>로 선언된 프로퍼티가 mutable한 데이터 구조를 참조하면 내용은 바뀔 수 있다.\n<strong><code class=\"language-text\">@Immutable</code>은 이런 <code class=\"language-text\">val</code>보다 훨씬 강력한 불변성의 보장이다.</strong>\n<strong>생성 후 모든 public 프로퍼티가 절대 안 바뀐다는 약속이다.</strong>\nKotlin은 언어 차원에서 불변성을 보장하는 메커니즘이 없기 때문에 이 어노테이션이 필요하다.</p>\n<p>다음 조건을 모두 만족하는 클래스에 사용할 수 있다. <strong>모든 프로퍼티가 <code class=\"language-text\">val</code>, 커스텀 getter가 없음 (매번 다른 값을 반환할 수 있으니까), 모든 프로퍼티가 불변 타입 (primitive 타입 또는 <code class=\"language-text\">@Immutable</code> 타입).</strong>\n대표적인 예시는 모든 프로퍼티가 <code class=\"language-text\">val</code>인 데이터 클래스다.</p>\n<p><strong>최적화 효과</strong>: Compose Runtime은 <code class=\"language-text\">@Immutable</code> 타입을 보면 값이 절대 안 바뀐다고 가정한다.\n이 확신 덕분에 스마트 recomposition과 recomposition Skip 같은 최적화를 적극적으로 할 수 있다.</p>\n<p><strong>@StableMarker와의 관계</strong>: <code class=\"language-text\">@Immutable</code>은 <code class=\"language-text\">@StableMarker</code>를 포함한다.\n불변 타입은 외부로 노출된 값이 절대 변경되지 않기 때문에, <code class=\"language-text\">@StableMarker</code>의 모든 요구사항을 자동으로 만족한다.\n불변 타입은 값이 변경되지 않으므로 composition에게 변경을 알릴 필요도 없다.</p>\n<hr>\n<h1 id=\"stable\" style=\"position:relative;\"><a href=\"#stable\" aria-label=\"stable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Stable</h1>\n<p><code class=\"language-text\">@Immutable</code>보다 약한 약속이다.\n적용 대상에 따라 의미가 달라진다.\n<strong>타입에 적용하는 경우, 타입이 mutable이지만 안정적이라는 표시다.</strong>\n완전히 불변은 아니지만 <code class=\"language-text\">@StableMarker</code>의 요구사항은 만족한다는 의미다.\n다시 한번 정리하면 <code class=\"language-text\">@StableMarker</code>의 요구사항: <strong>equals 일관성, 프로퍼티 변경 시 composition에 알림, 모든 public 프로퍼티가 안정적.</strong></p>\n<p><strong>함수나 프로퍼티에 적용하는 경우</strong>, 같은 입력에 대해 항상 같은 결과를 반환한다는 약속이다.\n이는 함수의 파라미터가 모두 안정적인 타입이거나 primitive 타입일 때만 가능하다.\n대표적인 예시는 public API는 불변처럼 보이지만 내부는 mutable인 경우다.  예를 들어 private한 mutable 상태를 가지고 있지만,\npublic으로 노출되는 API는 불변적으로 동작하거나 <code class=\"language-text\">MutableState</code>로 내부 프로퍼티를 구현했지만,\n외부에서는 읽기 전용으로만 노출되는 경우.</p>\n<p><strong>최적화 효과</strong>: Composable 함수의 모든 파라미터가 안정적인 타입이면,\nCompose는 위치 기억법을 사용해서 이전 호출과 파라미터를 비교한다.\n모든 값이 동일하면 recomposition을 생략한다.</p>\n<p><strong>주의사항</strong>: 이 어노테이션은 컴파일러와의 약속이다.\n요구사항을 만족하지 않는데 어노테이션을 달면 런타임 오류가 발생할 수 있다.\n확신이 없다면 사용하지 않는 것이 좋다.\n대부분의 경우 컴파일러가 자동으로 안정성을 추론하므로 어노테이션 없이도 잘 동작한다.</p>\n<p><strong>@Immutable과의 차이</strong>: 사실 현재는 Compose Compiler는 <code class=\"language-text\">@Immutable</code>과 <code class=\"language-text\">@Stable</code>을 동일하게 취급한다.\n둘 다 스마트 recomposition과 Skip 최적화를 동일하게 활성화한다.\n그럼에도 두 어노테이션이 따로 존재하는 이유는 미래를 위해서다.\n각자 다른 의미를 가지므로, 향후 Compose가 발전하면서 다르게 처리될 수 있다.\n올바른 어노테이션을 사용하면 미래의 최적화 혜택을 받을 수 있다.</p>\n<hr>\n<blockquote>\n<p><strong>라이브 리터럴 (Live Literals):</strong> 코드의 상수 값(문자열, 숫자 등)을 리컴파일 없이 실시간으로 변경할 수 있게 해주는 기능. Android Studio의 Compose 미리보기에서 텍스트나 색상을 수정하면 즉시 반영되는 것이 이 기능 덕분.</p>\n</blockquote>\n<h1 id=\"컴파일러-확장-등록-registering-compiler-extensions\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%ED%99%95%EC%9E%A5-%EB%93%B1%EB%A1%9D-registering-compiler-extensions\" aria-label=\"컴파일러 확장 등록 registering compiler extensions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일러 확장 등록 (Registering Compiler extensions)</h1>\n<p>Compose Compiler 플러그인이 가장 먼저 하는 일은 Kotlin 컴파일러에 자신을 등록하는 것이다.\n<code class=\"language-text\">ComponentRegistrar</code>라는 메커니즘을 사용해서 Kotlin 컴파일 파이프라인에 끼어든다.\n<code class=\"language-text\">ComposeComponentRegistrar</code>가 일련의 컴파일러 익스텐션들을 등록한다.</p>\n<p><strong>익스텐션의 역할:</strong> 라이브러리 사용을 쉽게 만들기, 런타임에 필요한 코드 생성, Composable 함수 변환.\n이 익스텐션들은 Kotlin 컴파일러와 함께 실행된다.</p>\n<p><strong>컴파일러 플래그:</strong> Compose Compiler는 컴파일러 플래그를 통해 추가 기능을 활성화할 수 있다.</p>\n<p><strong>활성화 가능한 기능들:</strong>\n라이브 리터럴 (Live Literals): 코드 수정 시 즉시 반영,\n소스 정보 포함: Android Studio가 composition 검사 가능,\n<code class=\"language-text\">remember</code> 최적화,\nKotlin 버전 호환성 검사 무시,\nIR 변환 과정에서 디버깅용 메서드 생성.\n이런 플래그들을 설정해서 원하는 기능을 켜고 끌 수 있다.</p>\n<hr>\n<h1 id=\"정적-분석-static-analysis\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EB%B6%84%EC%84%9D-static-analysis\" aria-label=\"정적 분석 static analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 분석 (Static analysis)</h1>\n<p>컴파일러 플러그인이 가장 먼저 하는 일은 린팅(linting)이다.\n소스 코드를 스캔해서 잘못된 부분을 찾아내는 작업이다.\nCompose Compiler는 어노테이션이 올바르게 사용되고 있는지 검사한다.\n“올바르게”의 기준은 Compose Runtime이 기대하는 방식이다.</p>\n<p><code class=\"language-text\">@Composable</code> 함수가 일반 함수에서 호출되는지,\n<code class=\"language-text\">@Immutable</code> 타입이 실제로 불변인지,\n<code class=\"language-text\">@DisallowComposableCalls</code> 람다 안에서 Composable을 호출하는지 같은 것들을 검사한다.\n검사는 컴파일러의 프론트엔드 단계에서 한다.\n코드가 IR로 변환되기 전에 먼저 검증한다는 의미다.\n개발자가 빠르게 피드백을 받을 수 있다.</p>\n<hr>\n<h1 id=\"정적-검사기-static-checkers\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EA%B2%80%EC%82%AC%EA%B8%B0-static-checkers\" aria-label=\"정적 검사기 static checkers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 검사기 (Static Checkers)</h1>\n<p>등록된 익스텐션 중 일부는 정적 검사기다.\n개발자가 코드를 작성하는 동안 잘못된 부분을 실시간으로 알려준다.</p>\n<p>Compose Compiler는 함수 호출, 타입, 선언에 대한 검사기를 익스텐션으로 등록한다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%86%8D%EC%84%B1-properties-of-composable-functions\">1장에서 다룬 Composable 함수의 제약들</a>\n이 검사기들에 의해 검증된다.\n개발자가 요구사항을 위반하면 즉시 IDE에 보고된다.</p>\n<p>Kotlin 컴파일러는 다양한 검사기를 제공한다.\n클래스 인스턴스화, 타입, 함수 호출, deprecated 호출, 계약(contracts), 클로저 캡처, 중위 호출, 코루틴 호출, 연산자 호출 등을 검사할 수 있다.\n컴파일러 플러그인은 이런 검사기들을 활용해서 소스 코드의 모든 요소를 정적 분석하고, 상황에 따라 경고나 오류를 보고한다.</p>\n<p>모든 검사기는 컴파일러의 프론트엔드 단계에서 실행된다.\n속도가 빠르고 CPU를 많이 소모하지 않는다.\n개발자가 코드를 입력하는 동안 무거운 검사가 실행되면 IDE가 버벅이기 때문이다.\n빠르고 가벼운 검사기가 필요하다.</p>\n<hr>\n<blockquote>\n<p><strong>PSI (Program Structure Interface):</strong> Kotlin 컴파일러가 소스 코드의 구조를 표현하는 트리. 함수, 클래스, 변수 등 모든 코드 요소가 노드로 표현됨.</p>\n</blockquote>\n<h1 id=\"호출-검사-call-checks\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%B6%9C-%EA%B2%80%EC%82%AC-call-checks\" aria-label=\"호출 검사 call checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호출 검사 (Call checks)</h1>\n<p>Compose Compiler가 등록한 검사기 중 하나가 호출 검사기다.\nComposable 함수가 올바른 위치에서 호출되는지 검증한다.\n검사기는 PSI 트리를 방문자 패턴으로 탐색한다.\nPSI는 프론트엔드 컴파일러 단계의 언어 구조를 모델링한 것으로, 구문적이고 정적인 코드 이해 방식이다.</p>\n<p>단일 노드만 분석하는 것으론 부족한 경우가 많다.\nComposable 함수가 어디서 호출되는지 알려면 더 넓은 컨텍스트가 필요하기 때문이다.\n컴파일러는 컨텍스트 추적(context trace)을 통해 방문 경로의 정보를 기록하고,\n람다식이나 try/catch 구문 같은 관련 항목들을 탐색한다.</p>\n<p><code class=\"language-text\">@DisallowComposableCalls</code>로 마킹된 람다 내에서 Composable 함수 호출이 발생하면,\n컨텍스트 추적에 정보를 기록하고 IDE에 오류를 보고한다.\n컨텍스트 추적은 전반적인 분석을 위한 정보를 기록할 수 있는 가변 구조다.</p>\n<p>각 Composable 함수 호출마다 컴파일러는 PSI 트리를 방문해서 호출자, 호출자의 호출자를 확인한다.\n모든 요구사항이 충족되었는지 검증하는 것이다.\n호출자는 람다식, 함수, 프로퍼티, try/catch 블록, 클래스, 파일 등 다양할 수 있다.</p>\n<p>인라인 함수도 중요하게 고려된다.\n인라인 람다의 호출자가 Composable이면 그 람다 안에서도 Composable 함수를 호출할 수 있어야 하기 때문이다.\nCompose Compiler는 Composable 함수를 호출하는 모든 인라인 람다가 호출 스택 어딘가에서 Composable 함수로 둘러싸여 있는지 확인한다.</p>\n<p>검사기는 금지만 하는 게 아니다.\n누락된 <code class=\"language-text\">@Composable</code> 어노테이션을 감지하면 개발자에게 추가하도록 제안한다.\nComposable 함수가 람다 내에서 호출되면 그 람다에 <code class=\"language-text\">@Composable</code>을 추가하라고 제안하는 식이다.\n<code class=\"language-text\">@ReadOnlyComposable</code> 어노테이션이 달린 함수는 다른 읽기 전용 Composable만 호출할 수 있다.\n그렇지 않으면 composition에서 읽기만 가능하고 쓰기는 불가능하다는 최적화 계약을 위반하게 된다.</p>\n<p>Jetpack Compose는 Composable 함수의 참조(reference) 사용을 지원하지 않는다.\n이런 사용도 호출 검사에서 차단한다.</p>\n<hr>\n<h1 id=\"타입-검사-type-checks\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC-type-checks\" aria-label=\"타입 검사 type checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 검사 (Type checks)</h1>\n<p>함수뿐만 아니라 타입에도 <code class=\"language-text\">@Composable</code> 어노테이션을 달 수 있다.\nCompose Compiler는 타입 추론과 관련된 검사를 수행한다.\n<code class=\"language-text\">@Composable</code> 어노테이션이 달린 타입을 예상했는데 실제로는 어노테이션이 없는 타입이 발견되면 오류를 보고한다.\n오류 메시지는 추론된 타입과 예상되는 타입을 어노테이션과 함께 출력해서 차이점을 명확하게 보여준다.\n함수 호출 검사와 유사한 방식이다.</p>\n<hr>\n<h1 id=\"선언-검사-declaration-checks\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%96%B8-%EA%B2%80%EC%82%AC-declaration-checks\" aria-label=\"선언 검사 declaration checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선언 검사 (Declaration checks)</h1>\n<p>호출 위치와 타입 검사만으론 부족하다.\n엘리먼트의 선언 위치도 검사해야 한다.\n프로퍼티, 프로퍼티 접근자, 함수 선언, 함수 파라미터 같은 것들이 분석 대상이다.\n프로퍼티, getter, 함수는 Composable로 어노테이션 되어 있어도 재정의될 수 있다.\nCompose Compiler는 이런 요소들이 재정의될 때 <code class=\"language-text\">@Composable</code> 어노테이션이 유지되는지 확인해서 일관성을 유지한다.</p>\n<p>Composable 함수가 suspend 함수인지도 검사한다.\nComposable 함수에 suspend는 지원되지 않기 때문이다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#suspend-%ED%95%A8%EC%88%98%EC%99%80%EC%9D%98-%EC%9C%A0%EC%82%AC%EC%84%B1-similarities-with-suspend-functions\">1장에서 설명했듯이 (Suspend 함수와의 유사성)</a>\nsuspend와 <code class=\"language-text\">@Composable</code>은 완전히 다른 개념이며 함께 사용할 수 없다.\nmain 함수를 Composable로 만드는 것도 금지된다.\nComposable 프로퍼티의 backing 필드 선언도 금지된다.</p>\n<hr>\n<h1 id=\"진단-제지기-diagnostic-suppression\" style=\"position:relative;\"><a href=\"#%EC%A7%84%EB%8B%A8-%EC%A0%9C%EC%A7%80%EA%B8%B0-diagnostic-suppression\" aria-label=\"진단 제지기 diagnostic suppression permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진단 제지기 (Diagnostic suppression)</h1>\n<p>컴파일러 플러그인은 진단 제지기를 등록해서 특정 상황의 진단을 음소거할 수 있다.\n일반적으로 Kotlin 컴파일러가 허용하지 않는 코드를 생성하거나 지원할 때 필요하다.\nCompose는 <code class=\"language-text\">ComposeDiagnosticSuppressor</code>를 등록해서 일부 언어 제한을 우회한다.\n특수한 유즈 케이스를 활성화하기 위해서다.</p>\n<p><strong>인라인 람다의 어노테이션 제약 우회</strong>. Kotlin은 인라인 람다에 BINARY나 RUNTIME 보존 타입 어노테이션을 사용하는 것을 금지한다.\n인라인 람다는 컴파일 타임에 호출자 쪽으로 인라인 되므로 어디에도 저장되지 않는다.\n따라서 어노테이션을 저장할 대상이 사라진다.</p>\n<p><strong>일반 Kotlin 코드에서는 이런 오류가 발생한다.</strong>\n“해당 람다식은 인라인 된 매개변수이므로, 이 어노테이션은 어디에도 저장할 수 없습니다.”\n하지만 Compose Compiler는 <code class=\"language-text\">@Composable</code> 어노테이션인 경우에만 이 검사를 제지한다.\n덕분에 호출 시점에서 람다에 <code class=\"language-text\">@Composable</code>을 붙일 수 있다.\n인라인 함수를 선언할 때만 <code class=\"language-text\">@Composable</code>을 붙일 필요가 없어진다.\n함수가 더 유연한 계약을 가질 수 있다.</p>\n<p><strong>함수 타입 파라미터 이름 지정 우회</strong>. Kotlin은 함수 타입의 파라미터에 이름을 지정하는 것을 허용하지 않는다.\n하지만 <code class=\"language-text\">@Composable</code>로 어노테이션 된 함수 타입은 가능하다.\n<code class=\"language-text\">@Composable</code> 어노테이션을 제거하면 다음 오류가 발생한다:\n“함수 유형에는 매개변수에 명명하는 것이 허용되지 않습니다.”</p>\n<p><strong>expect 클래스 제약 우회</strong>. Kotlin 멀티플랫폼의 expect 클래스 멤버에도 동일한 제약 완화가 적용된다.\nJetpack Compose는 멀티플랫폼을 목표로 하므로, <code class=\"language-text\">@Composable</code>로 어노테이션 된 expect 함수와 프로퍼티에 대해서 이런 유연성을 허용해야 한다.</p>\n<hr>\n<h1 id=\"런타임-버전-검사-runtime-version-check\" style=\"position:relative;\"><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84-%EB%B2%84%EC%A0%84-%EA%B2%80%EC%82%AC-runtime-version-check\" aria-label=\"런타임 버전 검사 runtime version check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>런타임 버전 검사 (Runtime version check)</h1>\n<p>코드 생성 단계로 넘어가기 전에 실행되는 작업을 보자.\n코드 생성 직전에 가장 먼저 하는 일은 Compose Runtime 버전을 확인하는 것이다.\nCompose Compiler는 지원하는 최소 버전의 Runtime이 필요하다.\nRuntime이 누락되지 않았는지, 버전이 너무 오래되지 않았는지 검사한다.\n각 Compiler 버전은 지원하는 최소 Runtime 버전이 있고, 그보다 높은 여러 버전을 지원한다.</p>\n<p>이것은 두 번째 버전 검사다.\n첫 번째는 Kotlin 컴파일러 버전을 검사하고, 그 다음이 Compose Runtime 버전 검사다.</p>\n<hr>\n<h1 id=\"코드-생성-code-generation\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1-code-generation\" aria-label=\"코드 생성 code generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 생성 (Code generation)</h1>\n<p>마지막으로 Compose Compiler가 코드 생성 단계로 넘어간다.\n이는 어노테이션 프로세서와 컴파일러 플러그인의 공통점이다.\n둘 다 런타임 라이브러리가 사용할 편리한 코드를 생성하거나 합성하는 데 자주 활용된다.</p>\n<hr>\n<h1 id=\"코틀린-ir-the-kotlin-ir\" style=\"position:relative;\"><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0-ir-the-kotlin-ir\" aria-label=\"코틀린 ir the kotlin ir permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코틀린 IR (The Kotlin IR)</h1>\n<p>컴파일러 플러그인은 IR(Intermediate Representation, 중간 표현)에 접근할 수 있다.\nIR은 목표 플랫폼에 대한 최종 코드를 생성하기 전 단계의 언어 표현이다.\n컴파일러 플러그인은 IR을 통해 개발자가 작성한 소스 코드를 수정할 수 있다.\n파라미터를 몰래 교체하고, 새 파라미터를 추가하고, 코드 구조를 재구성할 수 있다.\n이는 Kotlin 컴파일러의 백엔드 단계에서 발생한다.\nCompose가 각 Composable 함수에 <code class=\"language-text\">Composer</code> 파라미터를 주입하는 것도 이 과정에서 일어난다.</p>\n<p>컴파일러 플러그인은 다양한 형태로 코드를 생성할 수 있다.\nJVM만 목표로 한다면 바이트코드를 생성하면 되지만, Kotlin 팀은 모든 플랫폼을 위한 하나의 통합 백엔드를 만들고 있다.\nIR을 생성하는 것이 더 의미 있는 이유다.</p>\n<p>IR은 목표 플랫폼에 관계없이 존재하는 언어 요소의 중간 표현이다.\nIR을 생성하면 Jetpack Compose가 생성하는 코드가 멀티플랫폼이 될 수 있다.\nCompose Compiler 플러그인은 <code class=\"language-text\">IrGenerationExtension</code>의 구현체를 등록해서 IR을 생성한다.\n이는 Kotlin 컴파일러의 공통 IR 백엔드가 제공하는 익스텐션이다.\nKotlin IR에 대한 심도 있는 학습은 이 책의 범위를 벗어난다고 함. (휴…)</p>\n<hr>\n<blockquote>\n<p><strong>낮추기 (Lowering):</strong> 고수준 프로그래밍 개념을 저수준 개념으로 변환하는 작업. 예를 들어 <code class=\"language-text\">for</code> 루프를 <code class=\"language-text\">while</code>과 인덱스 변수로 변환하는 것. 컴파일러가 최종 기계어 생성을 위해 코드를 단순화하는 과정.</p>\n</blockquote>\n<h1 id=\"낮추기-lowering\" style=\"position:relative;\"><a href=\"#%EB%82%AE%EC%B6%94%EA%B8%B0-lowering\" aria-label=\"낮추기 lowering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>낮추기 (Lowering)</h1>\n<p>낮추기(lowering)는 고급 프로그래밍 개념을 더 낮은 수준의 원자적 개념으로 변환하는 작업이다.\n정규화의 한 형태로 이해할 수 있다.\nKotlin IR은 매우 고급 개념을 표현할 수 있다.\n하지만 목표 플랫폼(JVM 바이트코드, 자바스크립트, LLVM IR)으로 변환하려면 가장 낮은 수준의 형태로 변환해야 한다.</p>\n<p>Compose Compiler도 라이브러리가 지원하는 개념의 수준을 낮춰서 런타임이 이해할 수 있는 표현으로 정규화한다.\n이 과정은 Compose Compiler 플러그인의 코드 생성 단계에서 진행된다.\nIR 트리의 모든 엘리먼트를 방문하고 런타임 요구사항에 맞게 IR을 조정한다.</p>\n<p><strong>낮추기 단계에서 일어나는 주요 작업들:</strong></p>\n<p>클래스 안정성 추론과 메타데이터 추가. 런타임이 클래스 안정성을 이해하는 데 필요한 정보를 추가한다.</p>\n<p>라이브 리터럴 변환. 소스 코드의 변경 사항을 리컴파일 없이 런타임에 반영할 수 있도록 라이브 리터럴 표현식을 가변 상태 인스턴스 접근으로 변환한다.</p>\n<p>Composer 파라미터 주입. Composable 함수에 암시적인 Composer 파라미터를 삽입하고, 모든 Composable 호출에 전달한다.</p>\n<p>Composable 함수 본문 래핑. 컨트롤 플로우를 위한 다양한 그룹 생성(교체 가능한 그룹, 이동 가능한 그룹), 디폴트 파라미터 지원 구현, recomposition Skip 학습, 상태 변경 정보 전파 등을 수행한다.</p>\n<hr>\n<h1 id=\"클래스-안정성-추론-inferring-class-stability\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%95%88%EC%A0%95%EC%84%B1-%EC%B6%94%EB%A1%A0-inferring-class-stability\" aria-label=\"클래스 안정성 추론 inferring class stability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 안정성 추론 (Inferring class stability)</h1>\n<p>스마트 recomposition은 Composable의 입력값이 변경되지 않았고 안정적일 때 recomposition을 생략하는 것이다.\n안정성이 중요한 이유는 Compose Runtime이 입력값을 안전하게 읽고 비교할 수 있다는 것을 의미하기 때문이다.</p>\n<p>안정적인 타입의 특성은 세 가지다.\n<strong>equals 호출이 항상 동일한 결과를 반환한다.</strong>\n<strong>프로퍼티 변경 시 composition에 알림을 준다.</strong>\n<strong>모든 public 프로퍼티가 원시 타입이거나 안정적이다.</strong></p>\n<p>원시 타입, String, 함수형 타입은 기본적으로 안정적이다. 불변이기 때문이다.\n불변이 아니어도 <code class=\"language-text\">MutableState</code> 같은 타입은 <code class=\"language-text\">@Stable</code> 어노테이션으로 안정적이라고 표시할 수 있다.\nCompose는 클래스 안정성을 자동으로 추론한다.\n모든 클래스를 방문해서 <code class=\"language-text\">@StabilityInferred</code> 주석과 <code class=\"language-text\">$stable</code> 합성값을 추가한다.\n런타임 시 클래스 안정성을 결정하는 데 사용된다.\n추론 대상은 일반 클래스와 데이터 클래스다. 열거형, 인터페이스, 어노테이션 같은 건 제외된다.\n클래스의 모든 필드가 읽기 전용이고 안정적이면 안정적이라고 추론한다.</p>\n<p>제네릭 타입 매개변수는 런타임에 결정된다.\n<code class=\"language-text\">class Foo&lt;T>(val value: T)</code>에서 Foo의 안정성은 T의 안정성에 의존한다.\nCompose Compiler는 비트마스크를 사용해서 런타임 시 추론한다.\n내부 가변 상태도 클래스를 불안정하게 만든다.\n<code class=\"language-text\">private var count</code> 같은 필드가 있으면 불안정하다.\nCompose Compiler는 보수적으로 추론한다.\n증명할 수 있는 것만 안정적으로 간주한다.\n인터페이스는 구현을 모르므로 불안정하다.\n<code class=\"language-text\">List&lt;T></code>도 가변적인 <code class=\"language-text\">ArrayList</code>로 구현될 수 있으므로 불안정하다.</p>\n<p>개발자가 더 많은 정보를 가지고 있다면 <code class=\"language-text\">@Stable</code> 어노테이션을 명시적으로 표기할 수 있다.</p>\n<hr>\n<h1 id=\"라이브-리터럴-활성화-enabling-live-literals\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%99%9C%EC%84%B1%ED%99%94-enabling-live-literals\" aria-label=\"라이브 리터럴 활성화 enabling live literals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라이브 리터럴 활성화 (Enabling live literals)</h1>\n<p>이 부분의 글은 구현 세부사항에 가까우며 지속적으로 변경될 수 있다.</p>\n<p>라이브 리터럴은 Compose 도구가 미리 보기에서 변경사항을 리컴파일 없이 실시간으로 반영하게 해주는 기능이다.\n컴파일러 플래그로 활성화할 수 있다. v1은 <code class=\"language-text\">liveLiterals</code>, v2는 <code class=\"language-text\">liveLiteralsEnabled</code>다.\nCompose Compiler는 상수 표현식을 <code class=\"language-text\">MutableState</code>에서 값을 읽는 형태로 변환한다.\n런타임은 프로젝트를 리컴파일할 필요 없이 변경사항을 즉시 감지할 수 있다.\n이 변환은 단순히 개발자 경험 개선을 위한 것이다.\n성능에 민감한 코드의 속도를 크게 저하시킬 수 있으므로 릴리스 빌드에서는 절대 활성화하면 안 된다.</p>\n<p>Compose Compiler는 상수 표현식이 사용된 파일마다 <code class=\"language-text\">LiveLiterals$ClassName</code>이라는 싱글톤 클래스를 생성한다.\n각 상수 표현식에 대한 고유 ID를 생성하고, 상수들을 <code class=\"language-text\">MutableState</code> 프로퍼티의 getter를 통해 획득하도록 변환한다.\n런타임은 생성된 키를 이용해서 변환된 상수값을 획득한다.</p>\n<p>예시를 들면,\n원본 코드에서 <code class=\"language-text\">print(\"Hello World\")</code>는 <code class=\"language-text\">print(LiveLiterals$FooKt.getString$...()()</code>로 변환된다.\n<code class=\"language-text\">LiveLiterals$FooKt</code> 싱글톤 안에 <code class=\"language-text\">MutableState</code> 프로퍼티와 getter 함수가 생성된다.\n상수값이 <code class=\"language-text\">MutableState</code>로 래핑되어 실시간으로 변경 감지가 가능해진다.</p>\n<hr>\n<blockquote>\n<p><strong>메모이제이션 (Memoization):</strong> 캐싱의 한 유형. 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 줄임.</p>\n</blockquote>\n<blockquote>\n<p><strong>도넛 홀 스킵 (Donut-hole skipping):</strong> 트리의 중간 레벨을 건너뛰고 실제로 값을 사용하는 말단 노드에서만 recompose하는 최적화. 도넛의 구멍처럼 중간을 건너뛴다는 의미.</p>\n</blockquote>\n<h1 id=\"compose-람다식-기억법-compose-lambda-memoization\" style=\"position:relative;\"><a href=\"#compose-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EA%B8%B0%EC%96%B5%EB%B2%95-compose-lambda-memoization\" aria-label=\"compose 람다식 기억법 compose lambda memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 람다식 기억법 (Compose lambda memoization)</h1>\n<p>Composable 함수에 전달된 람다식을 최적화한다.</p>\n<p><strong>Non-composable 람다식</strong>: 값을 캡처하는 람다식은 remember로 자동으로 감싸진다.\n캡처하는 값이 안정적이면 그 값을 기반으로 람다식을 기억한다.\n런타임은 캡처 값이 일치하면 기존 람다식을 재사용한다.\n값을 캡처하지 않는 람다식은 Kotlin이 싱글톤으로 최적화한다.</p>\n<p><strong>Composable 람다식</strong>: Composable 람다식도 기억된다.\n컴파일러가 <code class=\"language-text\">composableLambda()</code> 팩토리 함수로 변환해서 composition에 저장한다.\n값을 캡처하지 않으면 싱글톤으로 최적화된다.\nComposable 람다식은 State처럼 구현되어 **“도넛 홀 스킵”**이 가능하다.\n트리의 높은 위치에서 람다를 업데이트해도, 실제로 사용되는 낮은 위치에서만 recompose한다.</p>\n<hr>\n<p>그림: Composer injection</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABpElEQVR42k1Ru0oDURC9aqXgC9GsGj9DuyhEBGtBsbG1ttNGLANa2ajxGTAiBsTSSpA8drO7ubtkLWIS8yQii6AJRtAkcD2zQcjCYYa555yZnWFCiC7Lsly2bUuEQqEglUqliUwmM8Dow7sDxroqlcpIsVgc7+RSrNfrUi6Xc5EXSyQSg4qifEajUQE0I5HITzKZpPycTEDqJl+fzzccDodNVVUFYgO8FnStWCzWJC15kBeTZbmXc74PnBiGcaRp2iE3jOATV1bZ3tuYJ9T0Tgcbs3MhW7JMvsm5cQHhEfh+AmlISx7kxVKpVH88HrfQqQTk0C0blZXqs/qwNXP5tbHyKMTSvRDzV+/rSfnxOiIrNngvQB4GedKQFpNb5OVMiKkOgACKZ8Cppus3PB5b69stSAu3Ta/3ruFZPM64E6qyrWl6kHgY4lzXdQLlAfIol8u9zg5ReEWXb6AKfIAk0OigfZP2Dv1+/yDeUJZ/EWnnNRjXsLsq8m/ycHZIl8H/T6TT6UnTNCcpZrPZKeRDzpWXRQ/bgSl4uPwoDub+53WCPOjKf3cgdZorW7kbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"\"\n        src=\"/static/bfc10e70c12030487c2ac5ce2383b9dd/37523/1.png\"\n        srcset=\"/static/bfc10e70c12030487c2ac5ce2383b9dd/e9ff0/1.png 180w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/f21e7/1.png 360w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/37523/1.png 720w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/302a4/1.png 1080w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/07a9c/1.png 1440w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/cbc84/1.png 5160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1 id=\"composer-주입하기-injecting-the-composer\" style=\"position:relative;\"><a href=\"#composer-%EC%A3%BC%EC%9E%85%ED%95%98%EA%B8%B0-injecting-the-composer\" aria-label=\"composer 주입하기 injecting the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer 주입하기 (Injecting the Composer)</h1>\n<p>Compose Compiler가 모든 Composable 함수에 Composer라는 합성 매개변수를 추가한다.\n기존 Composable 함수를 완전히 대체한다.\n이 매개변수는 코드의 모든 Composable 함수 호출에 전달된다.\n트리의 어느 지점에서나 항상 사용할 수 있게 된다.\nComposable 람다식 호출도 포함된다.</p>\n<p>Composer 파라미터를 추가하면 함수의 타입이 변하므로 타입 리매핑 작업도 필요하다.\nComposer 주입 덕분에 모든 하위 트리에서 Composer를 사용할 수 있다.\nComposable 트리를 구체화하고 업데이트된 상태로 유지하는 데 필요한 모든 정보를 제공한다.\nComposable이 아닌 인라인 람다는 변환하지 않는다.\n컴파일 타임에 호출자 쪽으로 인라인되면서 사라지기 때문이다.\nexpect 함수도 변환하지 않는다.\n타입 해결 시 actual 함수로 처리하고, actual 함수를 변환한다.</p>\n<hr>\n<h1 id=\"비교-전파-comparison-propagation\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%90-%EC%A0%84%ED%8C%8C-comparison-propagation\" aria-label=\"비교 전파 comparison propagation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비교 전파 (Comparison propagation)</h1>\n<p>Composable 함수에는 <code class=\"language-text\">$composer</code> 외에 <code class=\"language-text\">$changed</code>라는 매개변수도 추가된다.\n현재 Composable의 입력 매개변수가 이전 composition 이후 변경되었는지 알려주는 메타데이터다.\n런타임은 이를 통해 recomposition을 생략할 수 있다.\n<code class=\"language-text\">$changed</code> 매개변수는 함수의 입력 매개변수 각각에 대한 조건을 비트로 인코딩한다.\n비트 연산으로 처리하는 것이 프로세서 구조상 수월하기 때문이다.\n이 메타데이터 덕분에 부분적인 최적화가 가능하다.</p>\n<p>입력 매개변수가 정적이면 equals() 비교를 생략할 수 있다.\nString 리터럴이나 상수 같은 경우, 컴파일 타임에 값을 알 수 있으므로 런타임에서 비교할 필요가 없다.\n매개변수가 마지막 composition 이후 변경되지 않았거나, 상위 트리에서 이미 비교 작업을 수행했다면 다시 비교할 필요가 없다.\n매개변수 상태는 “확실하게” 변경될 필요가 없는 것으로 간주된다.</p>\n<p>매개변수 상태가 “불확실”한 경우도 있다.\n런타임은 equals()로 매개변수 값을 비교하고 슬롯 테이블에 저장한다.\n이 경우 <code class=\"language-text\">$changed</code>는 디폴트 값인 0이 되고, 런타임에게 모든 매개변수 비교 작업을 수행하도록 지시한다.</p>\n<p>Composable 함수 본문에는 <code class=\"language-text\">$dirty</code> 변수가 추가된다.\n매개변수가 변경되었는지 저장하는 변수다.\n값이 “dirty”로 간주되면 함수 본문을 실행하고 recomposition이 발생한다.\n그렇지 않으면 recomposition을 생략한다.\n입력 상태가 어떻게 변화하는지 정보를 전달하면 계산 시간과 메모리를 절약할 수 있다.\n매개변수를 매번 저장하고 비교하는 것은 슬롯 테이블 공간을 차지하기 때문이다.</p>\n<p>모든 Composable 함수는 트리 아래로 전달된 모든 매개변수에 대한 정보를 전달해야 할 책임이 있다.\n이것을 “비교 전파(comparison propagation)“라고 한다.\n입력값이 변경되었거나, 정적이거나, 무엇이든 매개변수에 대한 정보를 알고 있다면 하위 Composable 함수에게 <code class=\"language-text\">$changed</code>로 전달한다.</p>\n<p><code class=\"language-text\">$changed</code> 비트마스크는 매개변수가 안정적인지 불안정한지도 인코딩한다.\n<code class=\"language-text\">List&lt;T></code> 같은 광범위한 타입도 <code class=\"language-text\">listOf(1, 2)</code> 같은 안정적인 값이면 recomposition을 생략할 수 있다.</p>\n<hr>\n<h1 id=\"디폴트-매개변수-default-parameters\" style=\"position:relative;\"><a href=\"#%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-default-parameters\" aria-label=\"디폴트 매개변수 default parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디폴트 매개변수 (Default parameters)</h1>\n<p>각 Composable 함수에 <code class=\"language-text\">$default</code>라는 메타데이터가 매개변수로 추가된다.\nKotlin의 디폴트 매개변수 기능은 Composable 함수에서 사용할 수 없다.\nComposable 함수는 디폴트 표현식을 함수 범위(생성된 그룹) 내에서 실행해야 하기 때문이다.</p>\n<p>Compose는 이 문제를 해결하기 위한 대안을 제공한다.\n각 매개변수의 인덱스를 비트마스킹으로 매핑하는 <code class=\"language-text\">$default</code> 매개변수를 추가한다.\n<code class=\"language-text\">$changed</code> 매개변수와 동일한 방식이다.\n<code class=\"language-text\">$default</code> 매개변수는 각 입력 매개변수에 대해 호출자가 값을 제공하는지 여부를 알려준다.\n최종적으로 디폴트 값을 사용할지, 호출자가 넘긴 값을 사용할지 결정한다.\n비트마스킹을 통해 확인하고, 호출자가 값을 제공하지 않았으면 디폴트 값을 사용한다.</p>\n<hr>\n<h1 id=\"교체-가능한-그룹-replaceable-groups\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B2%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-replaceable-groups\" aria-label=\"교체 가능한 그룹 replaceable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교체 가능한 그룹 (Replaceable groups)</h1>\n<p>Composable 람다식은 팩토리 함수로 감싸진다.\n팩토리 함수는 키로 교체 가능한 그룹을 시작하고, 람다식 본문을 감싸고, 그룹을 닫는다.\n시작과 끝 호출 사이에서 composition을 관련 정보로 업데이트한다.\nComposable 함수의 호출도 동일하게 처리된다.\n<code class=\"language-text\">@NonRestartableComposable</code>로 재시작 불가능하다고 마킹된 함수도 교체 가능한 그룹을 생성한다.</p>\n<p>그룹은 트리와 같은 구조다.\n각 그룹은 원하는 만큼 자식 그룹을 가질 수 있다.\nComposable 함수가 다른 Composable 함수를 호출하면 컴파일러는 그 함수에도 그룹을 삽입한다.\nComposable 호출은 위치에 기반하기 때문에 정체성이 보존된다.\n조건부 로직의 서로 다른 두 Text 호출은 런타임이 다르다고 이해할 수 있다.\n조건부 논리를 수행하는 Composable 함수도 교체 가능한 그룹을 발행한다.\n조건이 전환되면 교체될 수 있는 그룹을 슬롯 테이블에 저장한다.</p>\n<hr>\n<h1 id=\"이동-가능한-그룹-movable-groups\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%8F%99-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-movable-groups\" aria-label=\"이동 가능한 그룹 movable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이동 가능한 그룹 (Movable groups)</h1>\n<p>이동 가능한 그룹은 정체성을 잃지 않고 재정렬이 가능한 그룹이다.\n<code class=\"language-text\">key</code> 함수 내부에서 Composable 함수를 호출하는 경우에 활용된다.\n<code class=\"language-text\">key</code> 함수로 Composable을 감싸면 고유한 정체성이 보장되고 이동 가능한 그룹이 생성된다.\n각 Composable 함수마다 정체성을 해치지 않으면서 호출 순서를 변경할 수 있다.\n컴파일러는 <code class=\"language-text\">startMovableGroup()</code> / <code class=\"language-text\">endMovableGroup()</code>으로 그룹을 생성한다.\n리스트 중간에 항목이 추가되거나 삭제되어도 각 항목의 정체성이 유지된다.</p>\n<hr>\n<h1 id=\"재시작-가능한-그룹-restartable-groups\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-restartable-groups\" aria-label=\"재시작 가능한 그룹 restartable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재시작 가능한 그룹 (Restartable groups)</h1>\n<p>재시작 가능한 그룹은 가장 흥미로운 그룹 중 하나다.\n재시작 가능한 Composable 함수에만 삽입된다.\n재시작 가능한 그룹도 Composable 호출을 감싸지만, end 함수 호출이 약간 다르다.\nnullable한 값을 반환한다.\nComposable 함수가 어떤 상태도 읽지 않으면 null을 반환한다.\nrecomposition이 필요 없다는 의미다.\n런타임에 재구성하는 방법을 가르칠 필요가 없다.</p>\n<p>null이 아닌 값을 반환하면 컴파일러는 람다식을 생성한다.\n이 람다식은 Composable을 “재시작”(다시 실행)하는 방법을 런타임에 가르친다.\n<code class=\"language-text\">endRestartGroup()?.updateScope()</code>로 범위를 갱신해서 recomposition을 트리거한다.\n동일한 새 호출을 감싸고 recomposition 범위를 업데이트한다.\n재시작 가능한 그룹은 상태를 읽는 모든 Composable 함수에 대해 생성된다.</p>\n<p><strong>그룹 생성 규칙</strong>: 블록이 항상 정확하게 1회만 실행되면 그룹이 필요 없다.\n조건부 논리에서 블록 집합 중 하나가 단 한 번 실행되는 경우(if문, when문), 각 블록 주위에 교체 가능한 그룹을 삽입한다.\n이동 가능한 그룹은 key Composable 함수 호출의 본문에서만 사용된다.</p>\n<hr>\n<h1 id=\"klib과-미끼-생성-klib-and-decoy-generation\" style=\"position:relative;\"><a href=\"#klib%EA%B3%BC-%EB%AF%B8%EB%81%BC-%EC%83%9D%EC%84%B1-klib-and-decoy-generation\" aria-label=\"klib과 미끼 생성 klib and decoy generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Klib과 미끼 생성 (Klib and decoy generation)</h1>\n<p>Compose Compiler는 멀티플랫폼(.klib)과 Kotlin/JS를 위한 특별한 지원을 추가했다.\nJS에서는 종속성에 대한 IR이 역직렬화되는 방식 때문에 문제가 생긴다.\nIR이 변환되면 타입 시그니처와 일치하지 않게 된다.\nCompose가 Composable 함수에 합성 매개변수를 추가하기 때문이다.\nJVM에서는 함수의 IR을 직접 교체하지만, Kotlin/JS에서는 다르게 처리한다.\n함수를 교체하는 대신 복사본을 생성한다.</p>\n<p>기존 함수 선언은 유지한 채로 Kotlin 메타데이터의 각 함수와 IR 사이를 연결한다.\n코드의 모든 참조는 여전히 잘 동작한다.\nCompose가 필요에 따라 복사본의 IR을 조정한다.\n런타임에서 기존 함수와 복사본을 구분하기 위해 복사본 함수 이름에 <code class=\"language-text\">$composable</code> 접미사가 추가된다.\n원본 함수는 decoy로 남고 호출되면 예외를 던진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","excerpt":"Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 (관련글) 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도. 참고. compose architecture  이 챕터를 읽기전에…\nCompose Compiler가 어떻게 동작하는지 내 기준 꽤 깊이 있게 살펴본다. 크게 세 부분으로 나뉜다. Compose 어노테이션들  @Composable부터 @Stable, @Immutable까지 각 어노테이션이 무엇을 의미하고 왜 필요한지. 정적 분석과 검사 컴파일 단계에서 코드를 검증하고 오류를 잡아내는 과정. 코드 생성과 변환 IR 낮추기(Lowering)를 통해 우리가 작성한 코드가 어떻게 변환되는지. Composer 주입, 비교 전파, 그룹 생성 등 실제 최적화 기법들. 마음의 준비를 하자…","frontmatter":{"date":"2025.11.23","title":"2장 - Compose 컴파일러 (The Compose compiler)","categories":"ComposeInternals","author":"Winter","emoji":null,"thumbnail":{"publicURL":"/static/5314d2a18f59617ee9c2723cac41e942/cover.png"},"articleDescription":null,"articleKeywords":null,"articleModifiedDate":null},"fields":{"slug":"/composeinternals/2-the-compose-compiler/"}},"next":{"id":"dfa35101-0b88-5fbb-b5d4-4848e77e4795","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<h1 id=\"composable-함수의-의미-the-meaning-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%98%EB%AF%B8-the-meaning-of-composable-functions\" aria-label=\"composable 함수의 의미 the meaning of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 의미 (The meaning of Composable functions)</h1>\n<p>Composable 함수는 Jetpack Compose 의 가장 기본적인 요소이며 처음부터 올바른 관념으로 받아들이는 게 좋다.\nComposable 함수를 처음부터 제대로 이해하려면 일반 함수와 다른 관점으로 봐야 한다.</p>\n<p>일반 함수: 반환 값이 결과임. 보통 한 번 실행되면 끝.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> input <span class=\"token operator\">*</span> <span class=\"token number\">2</span></code></pre></div>\n<p>Composable 함수: Node 데이터를 방출해서 컴포지션 하는것이 결과임. 입력 값의 변화에 따라 반복적으로 재실행됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Input<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Unit</code></pre></div>\n<p>컴포저블 함수의 실행 결과로 생성되는 데이터는 하나의 노드(Node)로 간주되어 방출(Emitting)하는 Action이 실행되고,\n노드는 UI 를 나타내는 Composable 트리(Tree) 구조의 구성 요소로 업데이트 된다.\n이 업데이트 동작은 우리가 컴포즈에서 흔히 접하는 용어인 “컴포지션(Composition)” 이라고 부르는 것이다.</p>\n<p>정리하면 컴포저블 함수를 실행하는 목적은 컴포지션을 통해 트리를 생성 및 업데이트하는 것이다. (컴포지션 유형: Node 를 트리의 구성 요소로 삽입, 제거, 교체, 이동)</p>\n<p>다음은 Side Effect 에 관한 이야기다.\n컴포저블 함수는 Input 값이 바뀔 때마다 몇 번이고 재실행 된다.\n재실행의 부수 효과(Side Effect)로 노드 방출이 일어나며 UI 트리는 항상 최신화 된다.</p>\n<p>우리가 자주 접하는 단어인 Recomposition 도 이 대목에서 다시 이해해볼 수 있다.\n함수에 Input 되는 값이 바뀌었다. 즉 리컴포지션 되었다.</p>\n<p><strong>요약: Composable을 실행한다의 의미: Composition</strong></p>\n<hr>\n<blockquote>\n<p><strong>Compose Runtime:</strong> 실행 중에 UI 트리를 관리하고 최적화하는 시스템.</p>\n</blockquote>\n<h1 id=\"composable-함수의-속성-properties-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%86%8D%EC%84%B1-properties-of-composable-functions\" aria-label=\"composable 함수의 속성 properties of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 속성 (Properties of Composable functions)</h1>\n<p><code class=\"language-text\">@Composable</code> 어노테이션은 단순 마커가 아니라 함수에 특정 제약과 규칙을 부여한다.\n이 제약으로 Compose Runtime 은 코드 실행에 대한 “확실성”을 갖게 되고, 다음과 같은 최적화 기법이 적용된다.</p>\n<ul>\n<li>병렬 Composition: 독립적인 Composable 들을 동시에 실행</li>\n<li>임의 순서 실행: 순서를 바꿔도 결과가 같으면 자유롭게 재배치</li>\n<li>스마트 Recomposition: 변경된 부분만 재실행</li>\n<li>위치 기억법 (Positional Memoization): 이전 결과를 재사용</li>\n</ul>\n<p>핵심: <code class=\"language-text\">@Composable</code> 어노테이션의 의미는 “제약을 주는 대신 최적화를 얻는다”는 것.</p>\n<p>Composable 함수 최적화는 “이 함수는 부수 효과가 없다”, “이 함수들은 서로 독립적이다”\n같은것을 미리 확신할 수 있어야 특정 조건 및 동작을 추론할 수 있다.\n이 확실성으로 다양한 실행 전략(execution strategy) 또는 평가 기법(evaluation techniques)에 따라\n사전에 특정 조건 및 동작을 추론하여 최적화 기법이 적용되는 것이다.</p>\n<hr>\n<blockquote>\n<p><strong>Compose Compiler:</strong> Kotlin 컴파일러 플러그인. Composable 함수를 변환하는 역할.</p>\n</blockquote>\n<blockquote>\n<p><strong>IR:</strong> Intermediate Representation, Kotlin 컴파일러가 소스파일을 해석하는 하나의 과정.</p>\n</blockquote>\n<blockquote>\n<p><strong>Composer:</strong> 런타임중 트리의 형태를 빌드하거나 업데이트하는 객체.</p>\n</blockquote>\n<h1 id=\"호출-컨텍스트-calling-context\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%B6%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-calling-context\" aria-label=\"호출 컨텍스트 calling context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호출 컨텍스트 (Calling context)</h1>\n<p>Compose Compiler 는 Composable 함수에 엄격한 제약을 하나 부과하는데,\nComposable 함수는 오로지 다른 Composable 함수에서만 호출할 수 있다는 것이다.\n때문에 코루틴처럼 호출 컨텍스트(Calling context)가 필수이다.</p>\n<p>이 제약은 트리가 오직 Composable 함수로 구성되게 보장하게 된다.\n또한 <strong>Composer</strong> 가 트리를 따라 하향 전달될 수 있다는 점 또한 보장된다.</p>\n<p><strong>Compose Compiler</strong> 는 컴파일 타임에 IR 을 가로채어\n우리가 작성한 원본 Composable 함수를 다른 코드로 변환한다.</p>\n<p>원본 소스코드</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n    modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> lastname<span class=\"token punctuation\">,</span> \n      style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>변환된 소스코드</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    $composer<span class=\"token operator\">:</span> Composer<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n  <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n    modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">,</span>\n      $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> lastname<span class=\"token punctuation\">,</span>\n      style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1<span class=\"token punctuation\">,</span>\n      $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>원본 소스코드에서 변환된 코드를 보면 <strong>Composer</strong> 라는 객체를 주입하는 파라미터가 추가된걸 알 수 있다.\n그리고 내부에 선언된 <code class=\"language-text\">Column</code>, <code class=\"language-text\">Text</code> 에도 <code class=\"language-text\">$composer</code> 라는 객체가 전달되게 코드가 변환 되었는데,\nComposer 라는 객체는 이와 같이 트리 내에서 모든 Composable 로 전달 되도록 변환되고\n이것이 Compose Compiler 가 하는 일 중 하나이다.</p>\n<p>Composer 의 실행 과정을 좀 더 자세히 풀어보면,\nComposable 함수가 실행되면 Node 를 트리로 방출(emitting)한다.\nInput 값이 변경되면 Composable 함수가 재실행된다 (Recomposition)\nCompose Runtime 은 트리를 하향 순회하면서 변경 사항을 확인한다.\n이 때 트리의 형태를 빌드하거나 업데이트 하는 역할이 <strong>Composer</strong> 인 것.</p>\n<hr>\n<blockquote>\n<p><strong>멱등성:</strong> 같은 입력에 대해 항상 같은 결과를 내는 성질.</p>\n</blockquote>\n<h1 id=\"멱등성-idempotent\" style=\"position:relative;\"><a href=\"#%EB%A9%B1%EB%93%B1%EC%84%B1-idempotent\" aria-label=\"멱등성 idempotent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멱등성 (Idempotent)</h1>\n<p>Composable 함수는 반드시 멱등성을 가져야 한다.\n같은 입력값으로 여러번 실행해도 동일한 노드 트리를 생성해야 한다는 뜻이다.</p>\n<p>멱등성이 중요한 이유는 Composable 의 핵심 최적화 기법인 <strong>리컴포지션 스킵(Skip)</strong> 때문이다.</p>\n<p>Composable 함수는 입력값이 바뀌면 재실행(Recomposition) 된다.\n그런데 앱 전체를 매번 다시 그리면 UI 를 그리는 성능상 비효율적이다.</p>\n<p>Compose Runtime 은 트리를 아래로 순회하면서 <strong>입력값이 바뀐 노드만</strong> 다시 실행하고\n<strong>입력값이 안 바뀐 노드는 건너뛴다(Skip)</strong></p>\n<p>멱등성이 보장되면 Compose Runtime 은 다음과 같이 가정할 수 있게된다.\n“같은 입력값이면 같은 결과를 낼 것임”,\n“이미 메모리에 결과가 있으니 다시 실행 안해도 됨”.\n결과: Skip</p>\n<p>이렇게 불필요한 재실행을 생략해서 성능을 최적화 한다.</p>\n<hr>\n<h1 id=\"통제되지-않은-사이드-이펙트-방지-free-of-uncontrolled-side-effects\" style=\"position:relative;\"><a href=\"#%ED%86%B5%EC%A0%9C%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%EB%B0%A9%EC%A7%80-free-of-uncontrolled-side-effects\" aria-label=\"통제되지 않은 사이드 이펙트 방지 free of uncontrolled side effects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통제되지 않은 사이드 이펙트 방지 (Free of uncontrolled side effects)</h1>\n<p>사이드 이펙트 (Side Effect):\n호출되는 함수의 제어를 벗어나서 발생할 수 있는 예상치 못한 모든 동작.\n로컬 캐시에서 데이터 읽기, 네트워크 요청 작업, 전역변수 설정 변경 등 예상치 못한 모든 동작.\n즉 Composable 함수 내부적인 요인에 의해서만 발생하는게 아니라 외부 요인으로 인한 Side Effect 가 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">EventsFeed</span><span class=\"token punctuation\">(</span>networkService<span class=\"token operator\">:</span> EventsNetworkService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> events <span class=\"token operator\">=</span> networkService<span class=\"token punctuation\">.</span><span class=\"token function\">loadAllEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  LazyColumn <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">items</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> event <span class=\"token operator\">-></span>\n      <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드의 문제점: 함수가 호출될 때마다 네트워크 요청이 실행된다는 것이다.</p>\n<p>앞서 언급했듯이 Composable 함수는 Input 값이 바뀌면 재실행된다.\n그런데 재실행이 언제, 몇 번 일어날지는 Compose Runtime 이 결정한다. 우리가 통제할 수 없다.</p>\n<p>예를 들어</p>\n<ul>\n<li>화면 회전하면 재실행</li>\n<li>다른 State 가 바뀌어도 재실행</li>\n<li>심지어 최적화를 위해 멀티 스레드로 병렬 실행 가능</li>\n</ul>\n<p>결과적으로 loadAllEvents() 가 우리 의도와 상관없이 수십 번 호출될 수 있다.\n이게 바로 “통제되지 않은 사이드 이펙트” 문제다.</p>\n<p>Compose Runtime 은 Composable 함수가 <strong>예측 가능하기를(결정론적인)</strong> 기대하는데\n사이드 이펙트가 포함되면 예측이 불가능해진다.</p>\n<p>또 다른 문제: 실행 순서 의존</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">MainScreen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Header</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       \n  <span class=\"token function\">ProfileDetail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">EventList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Header()</code> 가 먼저 실행되고, 그 다음 <code class=\"language-text\">ProfileDetail()</code> 이 실행되겠지? <strong>“NO”</strong></p>\n<p>Compose Compiler 는 이 함수들을 순서를 바꿔서 실행할 수도 있고 동시에 병렬로 실행할 수도 있다.\n따라서 Header 에서 변수 세팅하고, Profile 에서 읽기 같은 로직은 의도대로 작동하지 않는다.</p>\n<p>그럼 어떻게 해야 하나? 우리는 모든 Composable 함수를 stateless 하게 만들수 있게 노력해야 한다.\nComposable 함수는 최대한 “멍청하게” 만들어야 한다.\n모든 필요한 데이터는 파라미터로 받고, 함수 안에서는 받은 데이터로 UI 그리기만 하게 만들자.</p>\n<p>그럼 네트워크 요청은 어디서 하나? Effect Handler 를 사용한다. 추후 챕터에서 다룰거라고 함.</p>\n<p>정리. Composable 함수 안에서 네트워크 요청, DB 접근 같은 걸 직접 하면 안 됨.\n왜? 함수가 언제든 여러 번 실행될 수 있어서.</p>\n<p>해결책: Effect Handler 사용.</p>\n<hr>\n<h1 id=\"재시작-가능-restartable\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EA%B0%80%EB%8A%A5-restartable\" aria-label=\"재시작 가능 restartable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재시작 가능 (Restartable)</h1>\n<p>일반적인 코틀린 함수는 콜스택 (call stack) 상으로 단 한 번만 호출된다.\nComposable 함수는 recomposition 으로 여러번 다시 시작될 수 있다.</p>\n<p>Compose Runtime 은 Tree 를 항상 최신 상태로 유지하기 위해 어떤 노드를 재시작할지 선택적으로 판단한다.\nComposable 함수는 관찰하는 상태(state)에 기반하여 반작용적으로 재실행되게 설계되었다.</p>\n<p>Compose Compiler 는 State 를 읽는 (stateful) Composable 함수를 찾아\nCompose Runtime 에게 재시작 하는 방법을 알려주는 코드를 생성한다.\nstateless 한 함수는 재시작할 필요가 없기 때문에 이런 Composable 함수엔 재시작 하는 방법을 가르쳐주지 않는다고 한다.</p>\n<hr>\n<h1 id=\"빠른-실행-fast-execution\" style=\"position:relative;\"><a href=\"#%EB%B9%A0%EB%A5%B8-%EC%8B%A4%ED%96%89-fast-execution\" aria-label=\"빠른 실행 fast execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빠른 실행 (Fast execution)</h1>\n<p>Composable 함수들은 직접적으로 UI 를 구축하거나 반환하지 않는다.\nComposable 은 단순히 Tree 구조를 구축 및 업데이트 하기위한 데이터(Node) 를 방출할 뿐이다.\n이 매커니즘으로 Composable 은 빠르게 실행될 수 있고 Compose Runtime 이 몇 번이고 실행할 수 있게 해준다.\n이 재실행 과정은 애니메이션의 각 프레임 만큼이나 자주 발생할수도 있다고 한다.</p>\n<p>개발자가 지켜야 할 규칙: Compose Runtime 은 Composable 이 빠르게 실행된다고 가정한다.\n따라서 Network, DB, 메모리 캐싱 등 비용이 큰 작업은 코루틴으로 처리 되어야 한다는 말임.\n해당 작업들은 라이프 사이클에 대응할 수 있는 (lifecycle aware) 이펙트 핸들러에서 처리 되어야 하는데 이 내용은 나중에 다룬다고.</p>\n<hr>\n<blockquote>\n<p><strong>메모이제이션 (Memoization):</strong> 캐싱의 한 유형. 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 줄임.</p>\n</blockquote>\n<blockquote>\n<p><strong>위치 기억법:</strong> 함수 메모이제이션의 한 형태이다.</p>\n</blockquote>\n<h1 id=\"위치-기억법-positional-memoization\" style=\"position:relative;\"><a href=\"#%EC%9C%84%EC%B9%98-%EA%B8%B0%EC%96%B5%EB%B2%95-positional-memoization\" aria-label=\"위치 기억법 positional memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위치 기억법 (Positional memoization)</h1>\n<p>함수 실행 결과를 캐싱해서 같은 입력에 대해 다시 계산하지 않는 기법.</p>\n<p>일반적인 함수의 메모이제이션 방법: 함수의 이름, 타입, 파라미터의 조합으로 고유한 키를 생성하고 다시 실행될 때 이 키를 이용해서 메모이제이션 여부를 판단한다.</p>\n<p>Composable 함수: 위의 일반적인 방법  + 소스 코드 위치(고유 키) 생성.\n하지만 같은 함수여도 호출 위치가 다르면 UI Tree 상 다른 고유 키로 취급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">MyComposable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 부모 트리\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 1</span>\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 2</span>\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 3</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>같은 <code class=\"language-text\">Text(\"Hello\")</code>지만, 소스 코드 위치가 다르므로 각각 다른 ID를 받는다.\n입력값이 바뀌지 않으면 이 id는 recomposition 시 Skip 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">TalksScreen</span><span class=\"token punctuation\">(</span>talks<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Talk<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Column <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>talk <span class=\"token keyword\">in</span> talks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">Talk</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드가 문제인 이유: Compose Runtime 입장에서 함수에 고유 ID 를 할당하기 어려운 케이스임.</p>\n<p>처음엔 <code class=\"language-text\">Talk</code> 가 생성된만큼 ID 가 생성되어 각각의 <code class=\"language-text\">Talk</code> item 을 구분할 수 있긴 하다.\nList 순서상 맨 끝에 새로운 item 이 추가 되어도 모든 item 은 각자의 고유한 ID 를 잘 유지할 수 있다.</p>\n<p>문제는 List 순서상 중간의 아이템이 추가되거나 삭제 된다면?\n해당 위치 이후의 item 들은 Composable 의 위치가 바뀌며 각자의 고유 ID 를 잃게되고 결과적으로 전부 recomposition 된다.</p>\n<p>업데이트가 생략 되었어야 할 Composable 함수들이 전부 recomposition 을 하게 되었으니 리스트가 길면 길수록 비효율적이게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">TalksScreen</span><span class=\"token punctuation\">(</span>talks<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Talk<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Column <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>talk <span class=\"token keyword\">in</span> talks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">key</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> Unique key 추가\n        <span class=\"token function\">Talk</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 방법처럼 Key 로 Composable 각자에 고유한 ID 를 직접 부여해서 트리 내 각자의 위치를 유지하게 할 수 있다.\n위에 말한 비효율 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">FilteredImage</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> filters <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span> <span class=\"token function\">computeFilters</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">ImageWithFiltersApplied</span><span class=\"token punctuation\">(</span>filters<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">ImageWithFiltersApplied</span><span class=\"token punctuation\">(</span>filters<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Filter<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">remember</code> 는 <code class=\"language-text\">computeFilters(path)</code> 를 실행하고 결과 저장, path 가 바뀌지 않으면 <code class=\"language-text\">remember</code> 에 저장된 값을 재사용.\n해당 방법으로 recomposition Skip.</p>\n<p>핵심: Composable 은 호출 위치로 고유 ID 를 가짐.\n입력값의 변화가 없다면 해당 위치의 Composable 은 recomposition 을 Skip 한다.\n반복문에서는 <code class=\"language-text\">Key()</code> 로 명시적인 ID 지정 필요.\n함수 내부의 계산 결과를 캐싱하려면 <code class=\"language-text\">remember</code> 함수를 사용하자.</p>\n<hr>\n<h1 id=\"suspend-함수와의-유사성-similarities-with-suspend-functions\" style=\"position:relative;\"><a href=\"#suspend-%ED%95%A8%EC%88%98%EC%99%80%EC%9D%98-%EC%9C%A0%EC%82%AC%EC%84%B1-similarities-with-suspend-functions\" aria-label=\"suspend 함수와의 유사성 similarities with suspend functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Suspend 함수와의 유사성 (Similarities with suspend functions)</h1>\n<p>suspend 와 Compose 함수는 비슷한 제약을 가진다.</p>\n<p><strong>Coroutine:</strong> suspend 함수는 다른 suspend 함수에서 호출될 수 있다. <br/>\n<strong>Compose:</strong> Composable 함수는 다른 Composable 함수에서 호출될 수 있다.</p>\n<p>때문에 이 둘은 호출 컨텍스트가 필요하다.\n이 제약으로 suspend 는 suspend 끼리, Composable 역시 Composable 끼리 묶일 수 있게 보장해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// Coroutine 함수 변환 전</span>\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">publishTweet</span><span class=\"token punctuation\">(</span>tweet<span class=\"token operator\">:</span> Tweet<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Post <span class=\"token operator\">=</span> <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token comment\">// Coroutine 함수 변환 후</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">publishTweet</span><span class=\"token punctuation\">(</span>\n    tweet<span class=\"token operator\">:</span> Tweet<span class=\"token punctuation\">,</span> \n    callback<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>Post<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Unit</code></pre></div>\n<p>둘 다 암시적인 파라미터를 추가한다는 점에서 유사하다.</p>\n<p>핵심 차이점: <br/>\n<strong>Continuation:</strong> Kotlin Runtime 으로부터 다양한 중단점에서 실행을 중단, 재개에 대한 정보를 담고 있는 객체. 본질적으론 일반 함수와 똑같이 한 번 실행되면 끝이다. <br/>\n<strong>Composer:</strong> Compose Runtime 으로부터 여러번 실행되는 이벤트에 반응하며 항상 UI Tree 를 최신 상태로 유지하게 만들기 위한 객체.</p>\n<p>“한 번 실행하고 중단, 재개 / 상태 변화에 반응해서 계속 재실행”</p>\n<p>유사하긴 하지만 완전히 다른 문제를 해결하니 각자의 매커니즘이 필요하다.</p>\n<hr>\n<h1 id=\"composable-함수의-색깔-the-color-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%83%89%EA%B9%94-the-color-of-composable-functions\" aria-label=\"composable 함수의 색깔 the color of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 색깔 (The color of Composable functions)</h1>\n<p>서로 다른 종류의 함수는 잘 섞이지 않는다는 이야기다.</p>\n<p>동기 함수에서 비동기 함수를 직접 호출할 수 없고, 일반 함수에서 suspend 함수를 직접 호출할 수 없듯이.\n그리고 일반 함수에서 Composable 함수를 직접 호출할 수 없듯이.</p>\n<p>이렇게 함수들이 서로 다른 “색깔”을 가진 것처럼 분리되어 있다고 해서 함수 컬러링이라고 부른다.</p>\n<p>Composable 함수는 다른 Composable 함수에서만 호출 가능하다. 일반 함수와 섞으려면 통합점이 필요하다 (예: <code class=\"language-text\">setContent</code>)</p>\n<p>왜 이런 제약이 있을까? Composable 함수는 일반 함수와 완전히 다른 목적을 가지기 때문.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">SpeakerList</span><span class=\"token punctuation\">(</span>speakers<span class=\"token operator\">:</span> List<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Column <span class=\"token punctuation\">{</span>\n        speakers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 일반 함수인데?</span>\n            <span class=\"token function\">Speaker</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Composable 호출 가능</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">forEach</code>는 일반 함수인데 어떻게 안에서 Composable을 호출할 수 있을까? <strong>inline</strong> 때문이라고 한다. <code class=\"language-text\">forEach</code> 같은 컬렉션 연산자는 inline 으로 선언되어 있다.\ninline 함수는 호출 시점에 코드가 그대로 복사되어 들어간다. 결국 <code class=\"language-text\">Speaker(it)</code>는 <code class=\"language-text\">SpeakerList</code> 본문 안에서 호출되는 것과 같다. 둘 다 Composable이니까 문제없다.\ninline 덕분에 함수 컬러링 문제를 우회하고 자연스러운 코드를 작성할 수 있다.</p>\n<p>함수 컬러링은 문제일까? 오히려 장점이라고 한다. 컴파일러와 런타임이 “colored 함수”를 특별하게 처리할 수 있기 때문이다.</p>\n<p>suspend 함수는 비동기 non-blocking 프로그래밍을 가능하게 한다.\nComposable 함수는 재시작 가능(Restartable), 생략 가능(Skippable), 반응형(Reactive)이다.\n일반 함수에는 없는 이런 특별한 기능을 얻는 대가로 “색깔”이라는 제약이 생긴 것이다.</p>\n<hr>\n<h1 id=\"composable-함수-타입-composable-function-types\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-composable-function-types\" aria-label=\"composable 함수 타입 composable function types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수 타입 (Composable function types)</h1>\n<p><code class=\"language-text\">@Composable</code> 어노테이션은 함수의 타입 자체를 변경한다.</p>\n<p>일반 함수 타입: <code class=\"language-text\">(T) -> A</code> <br/>\nComposable 함수 타입: <code class=\"language-text\">@Composable (T) -> A</code></p>\n<p><code class=\"language-text\">@Composable</code>이 타입의 일부가 된다는 뜻이다.</p>\n<p>Composable 람다: 일반 람다를 선언하듯이 Composable 람다도 선언할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// Composable 람다를 프로퍼티로 저장</span>\n<span class=\"token keyword\">val</span> textComposable<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n        text <span class=\"token operator\">=</span> it<span class=\"token punctuation\">,</span>\n        style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">textComposable</span><span class=\"token punctuation\">(</span>lastname<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 저장한 람다 사용</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 Composable 람다를 재사용할 수 있다.</p>\n<p>Scope가 있는 Composable 타입: 특정 Composable 안에서만 사용 가능하도록 범위를 제한할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> BoxScope<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit  <span class=\"token comment\">// BoxScope 안에서만</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Layout</span><span class=\"token punctuation\">(</span>\n        content <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> BoxScopeInstance<span class=\"token punctuation\">.</span><span class=\"token function\">content</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">BoxScope.() -> Unit</code>은 Box 안에서만 호출 가능한 람다를 의미한다.\n이 덕분에 특정 Composable 내부에서만 쓸 수 있는 함수를 만들 수 있다.</p>\n<p>왜 타입이 중요한가? 타입이 다르면 컴파일러가 다르게 처리할 수 있다.</p>\n<p><code class=\"language-text\">@Composable</code> 타입 덕분에 컴파일 시점에 잘못된 호출 검증 가능 (일반 함수에서 Composable 호출 시 에러),\n런타임이 Composable 함수를 특별하게 처리 가능 (재시작, Skip 등),\n타입 시스템으로 제약을 강제할 수 있음.</p>\n<p>Composable 함수가 일반 함수와 완전히 다른 타입인 이유다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","frontmatter":{"date":"2025.11.14","title":"1장 - Composable 함수들 (Composable functions) 내맘대로 정리","categories":"ComposeInternals","author":"Winter","emoji":null},"fields":{"slug":"/composeinternals/1-composable-functions/"}},"prev":{"id":"6fe9521a-0f0a-595b-86c6-4e10e47f1d74","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<p>주당 1챕터씩 작성하려 했으나 1주가 미뤄졌다. 회사 일이 바쁘고 주말에 지침 이슈. <del>(게으름 이슈)</del> 연말 휴가때 좀 몰아서 읽어야겠다.</p>\n<p>이번 3 장은 Compose Runtime의 핵심 동작 원리를 다룬다.</p>\n<ul>\n<li>슬롯 테이블과 변경 목록이 어떻게 composition 상태를 관리하는지</li>\n<li>Composer가 어떻게 변경사항을 기록하고 Applier가 어떻게 이를 실제 트리에 적용하는지</li>\n<li>Recomposer가 어떻게 전체 recomposition 프로세스를 조율하는지 살펴본다</li>\n</ul>\n<p>컴파일러가 코드를 변환하는 방법을 다뤘던 2장과 달리, 이번 장은 런타임에서 실제로 UI가 어떻게 만들어지고 업데이트되는지 메커니즘을 살펴본다.</p>\n<p><a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/\">이전 2장 컴포즈 컴파일러</a>\n도 만만치 않았지만, 이번 3장은 분량이 2배다.\n예시코드와 그림들이 전보다 많기 때문에 장수가 더 많아진 감도 있다.\n이전 장도 이해하고 요약하기 위해 마음의 준비가 필요했지만, 이번 장은 2배 정도의 노력이 더 필요했다.</p>\n<hr>\n<blockquote>\n<p><strong>슬롯 테이블 (Slot Table):</strong> Composition의 현재 상태를 저장하는 메모리 구조. 모든 Composable 호출의 위치, 파라미터, 기억된 값 등을 추적.</p>\n</blockquote>\n<blockquote>\n<p><strong>변경 목록 (List of Changes):</strong> 노드 트리에 실제로 적용할 변경사항을 담은 목록. 패치 파일처럼 동작.</p>\n</blockquote>\n<h1 id=\"슬롯-테이블과-변경-목록-the-slot-table-and-the-list-of-changes\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%A1%AF-%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-%EB%B3%80%EA%B2%BD-%EB%AA%A9%EB%A1%9D-the-slot-table-and-the-list-of-changes\" aria-label=\"슬롯 테이블과 변경 목록 the slot table and the list of changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬롯 테이블과 변경 목록 (The slot table and the list of changes)</h1>\n<p>슬롯 테이블은 composition의 현재 상태를 저장한다.\nComposable 호출의 위치, 파라미터, 기억된 값, CompositionLocal 등 모든 정보가 여기 담긴다.</p>\n<p>변경 목록은 실제 노드 트리에 적용할 변경사항이다.\n패치 파일처럼 동작한다.</p>\n<p>슬롯 테이블 = 상태 기록, 변경 목록 = 변경 적용.</p>\n<p>Composer가 슬롯 테이블의 정보를 보고 변경 목록을 생성한다.\nApplier가 변경 목록을 트리에 적용한다.\nRecomposer가 언제, 어디서 할지 결정한다.</p>\n<hr>\n<blockquote>\n<p><strong>갭 버퍼 (Gap Buffer):</strong> 텍스트 에디터에서 사용하는 자료구조. 데이터 중간에 빈 공간(갭)을 두고, 갭을 이동시키면서 효율적으로 삽입/삭제.</p>\n</blockquote>\n<blockquote>\n<p><strong>앵커 (Anchor):</strong> 슬롯 테이블에서 특정 위치를 가리키는 포인터. 빠른 접근을 위해 사용.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 132.7777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAACwklEQVR42tWVS08TURzFEUjEhYlxYUx0rcRHxPgF3Llh4fcxhp2s+QQ1JsbQWvqEQkKhuiGtBWtCmjQ8hEIKhXZoO6/O496/5z+2gCg4NTHGSadzJ2nPnN89597p6/ubBxFduujs+1dH98n9W1tbr46OjuK1Wm2y3lBD9aYWqitKsF6vh6vV6ttEInGrS3IhZmc42Gq1crgnwZ/aF6KvCb6V/GXbtjk3N/eg859+X4KHh4dL/GfTIVvPvXb11AvXNHTHsm2paao2MzNzj384NjbmS3CgUqlkWbClakJtKqQqVVI1TZqmSZgKs1fBwWazeYKcfknyzTMSdvs7smX1jnxwcJDtIAvj8yTp6XEyDUM6jkuq2jJjsdh9/mEwGBzwJbi/v591HIcajYYwLAfCkjQgW5ZFiqL0joy5yu3u7lI6nRb5/Cf6+CFDCwsLslQqER6kT09PP49EIk9wXjtTufOR2SH6KLa3t6lQKNDa2prksa7rZjweH45Go1fh9PG5Tk8LoryeIBIVQGURxpeGYfDVhMM7gUBgCAV/5EvwNPLy8jJlMifIKHZ7dnZ2mAWTyeRIN5yfVs1Zh1JKQh8FAiIW2tnZkXt7exyOOTU15TnEHI74cshz2G63CVcBbEIveSxVVeXxaeSncHclHA7fgOvrP7j8FfL8/LyHDHQey2KxyCl7yBMTE5fRx1HeKFi46/bcHnKxsdsI9I7T9hxijaPYau/I2KaynC7mTUCIhb05ZHEgt1Op1N2eQmFkBHKcMnB57CG7rnss6Lc2x7sNHAnsjZw2d1J2AvKQFxcXh7BJ+EOG0BKwaWNjw0Y4LgTdzc1NB3WSeICGlB8C96bvYmNF5NjZ6uqqWF9fp3w+TysrK97SE0LwWh7tuvT1TimXy+NwmUSRQ0g8jHUcxvg9gokg6Xfo3e3f7jZ/8pr9v9/L3wAorHGwx9AzBwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/4116c0c7c14607c1bcf48477d184be33/37523/0.png\"\n        srcset=\"/static/4116c0c7c14607c1bcf48477d184be33/e9ff0/0.png 180w,\n/static/4116c0c7c14607c1bcf48477d184be33/f21e7/0.png 360w,\n/static/4116c0c7c14607c1bcf48477d184be33/37523/0.png 720w,\n/static/4116c0c7c14607c1bcf48477d184be33/302a4/0.png 1080w,\n/static/4116c0c7c14607c1bcf48477d184be33/07a9c/0.png 1440w,\n/static/4116c0c7c14607c1bcf48477d184be33/08c33/0.png 1570w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1 id=\"슬롯-테이블-심층-분석-the-slot-table-in-depth\" style=\"position:relative;\"><a href=\"#%EC%8A%AC%EB%A1%AF-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%8B%AC%EC%B8%B5-%EB%B6%84%EC%84%9D-the-slot-table-in-depth\" aria-label=\"슬롯 테이블 심층 분석 the slot table in depth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>슬롯 테이블 심층 분석 (The slot table in depth)</h1>\n<p>슬롯 테이블은 갭 버퍼 개념을 바탕으로 한다.\n빠른 선형 접근에 최적화된 데이터 구조다.</p>\n<p>두 개의 배열로 구성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">var</span> groups <span class=\"token operator\">=</span> <span class=\"token function\">IntArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> slots <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>groups 배열은 그룹 메타데이터를 저장한다. 부모-자식 관계, 그룹 타입 등의 정보다.\nslots 배열은 실제 composition 데이터를 저장한다. Any? 타입이므로 모든 종류의 값을 담을 수 있다.</p>\n<p><a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#%EA%B5%90%EC%B2%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-replaceable-groups\">2장에서 봤듯이 (교체 가능한 그룹)</a>\n컴파일러는 Composable 함수 본문을 그룹으로 감싼다.\n그룹은 Composable 함수에 고유 ID를 부여하고 관련 정보를 감싼다.\n그룹 타입은 재시작 가능한 그룹, 이동 가능한 그룹, 교체 가능한 그룹, 재사용 가능한 그룹이 있다.\n부모 그룹이 먼저 나오고 자식 그룹이 뒤따른다. 선형 구조로 그룹 트리를 모델링한다.</p>\n<p>갭은 테이블에서 이동 가능한 범위 포인터다.\n데이터를 읽고 쓸 위치를 결정한다.\n조건부 로직에서 조건이 바뀌면 갭이 그룹 시작 위치로 돌아가서 기존 슬롯을 덮어쓴다.</p>\n<p>SlotReader는 테이블에서 데이터를 읽는다. 여러 개의 Reader가 동시에 읽을 수 있다.\nSlotWriter는 테이블에 데이터를 쓴다. 하나의 Writer만 활성화될 수 있다.\n동시 읽기/쓰기를 막아서 경쟁 상태를 방지한다.\nReader는 방문자처럼 작동한다. 현재 그룹, 위치, 부모, 슬롯 등을 추적하면서 배열을 탐색한다.\nWriter는 그룹과 슬롯을 추가, 교체, 이동, 제거한다. 갭을 이동시키면서 어디에 쓸지 결정한다.</p>\n<p>앵커는 특정 인덱스를 가리키는 포인터다. 빠른 접근을 위해 사용된다.\n앵커가 가리키는 위치 앞에서 그룹이 이동/교체/삽입/제거되면 앵커도 업데이트된다.</p>\n<hr>\n<h1 id=\"변경-목록-the-list-of-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EB%AA%A9%EB%A1%9D-the-list-of-changes\" aria-label=\"변경 목록 the list of changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 목록 (The list of changes)</h1>\n<p>Composition이 발생할 때마다 Composable 함수들이 실행되고 방출된다.\n방출이란 슬롯 테이블을 업데이트하고, 지연된 변경사항을 생성하는 것이다.\n이 변경사항들이 목록 형태로 저장된다.</p>\n<p>새로운 변경 목록은 슬롯 테이블에 이미 저장된 값을 바탕으로 생성된다.\n트리의 어떤 변경사항이라도 composition의 현재 상태에 의존하기 때문이다.</p>\n<p>예를 들어 노드를 이동한다고 생각해보자.\n테이블에서 해당 노드가 이전에 어디 있었는지 확인하고, 그 위치의 슬롯을 제거한 다음 새 위치에 다시 작성해야 한다.</p>\n<p>Composable 함수가 방출될 때마다 슬롯 테이블을 확인하고, 현재 정보에 따라 지연된 변경사항을 생성하고, 변경 목록에 추가한다.\n나중에 composition이 끝나면 변경 목록의 내용들이 실제로 실행되면서 구체화된다.\n그때가 슬롯 테이블을 최신 정보로 실제 업데이트하는 순간이다.\n실행을 기다리는 작업을 미리 생성해두는 것만으로 방출 과정이 매우 빠르다.</p>\n<p>변경 목록이 적용된 직후, 구체화된 노드 트리를 업데이트하기 위해 Applier에게 알린다.</p>\n<p>Recomposer는 이 과정을 조율한다.\n어떤 스레드에서 composition/recomposition 할지, 어떤 스레드에서 변경사항을 적용할지 결정한다.\n변경사항을 적용하는 스레드는 LaunchedEffect가 사이드 이펙트를 실행하는 디폴트 컨텍스트가 되기도 한다.</p>\n<p>이제 Composer를 살펴볼 차례다.</p>\n<hr>\n<h1 id=\"composer\" style=\"position:relative;\"><a href=\"#composer\" aria-label=\"composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer</h1>\n<p>주입된 $composer는 우리가 작성하는 Composable 함수를 Compose Runtime에 연결하는 역할을 한다.\n<a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#composer-%EC%A3%BC%EC%9E%85%ED%95%98%EA%B8%B0-injecting-the-composer\"><code class=\"language-text\">$composer</code>가 어떻게 주입 되는지는 2장에서 자세히 다뤘다.</a></p>\n<hr>\n<h1 id=\"composer-키우기-feeding-the-composer\" style=\"position:relative;\"><a href=\"#composer-%ED%82%A4%EC%9A%B0%EA%B8%B0-feeding-the-composer\" aria-label=\"composer 키우기 feeding the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer 키우기 (Feeding the Composer)</h1>\n<p>트리의 메모리 표현에 노드가 어떻게 추가되는지 살펴보자.\nLayout Composable을 예로 들 수 있다.\nLayout은 Compose UI의 모든 UI 컴포넌트의 기반이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Layout</span><span class=\"token punctuation\">(</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    modifier<span class=\"token operator\">:</span> Modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">,</span>\n    measurePolicy<span class=\"token operator\">:</span> MeasurePolicy\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> density <span class=\"token operator\">=</span> LocalDensity<span class=\"token punctuation\">.</span>current\n    <span class=\"token keyword\">val</span> layoutDirection <span class=\"token operator\">=</span> LocalLayoutDirection<span class=\"token punctuation\">.</span>current\n    ReusableComposeNode<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n        factory <span class=\"token operator\">=</span> ComposeUiNode<span class=\"token punctuation\">.</span>Constructor<span class=\"token punctuation\">,</span>\n        update <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>measurePolicy<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetMeasurePolicy<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>density<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetDensity<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>layoutDirection<span class=\"token punctuation\">,</span> ComposeUiNode<span class=\"token punctuation\">.</span>SetLayoutDirection<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        skippableUpdate <span class=\"token operator\">=</span> <span class=\"token function\">materializerOf</span><span class=\"token punctuation\">(</span>modifier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        content <span class=\"token operator\">=</span> content\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Layout은 LayoutNode를 composition에 방출하기 위해 ReusableComposeNode를 사용한다.\n즉각 노드를 생성하고 추가하는 것처럼 보이지만, 실제로는 “적절한 시기에 노드를 생성, 초기화, 삽입하는 방법”을 런타임에게 가르친다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">></span> <span class=\"token function\">ReusableComposeNode</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">noinline</span> factory<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">,</span>\n    update<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> Updater<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">noinline</span> skippableUpdate<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> SkippableUpdater<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">,</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">startReusableNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">createNode</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Updater</span><span class=\"token punctuation\">(</span>currentComposer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// initialization</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">startReplaceableGroup</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x7ab4aae9</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">content</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">endReplaceableGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">endNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>currentComposer 인스턴스에 모든 것을 위임하는 형태다.\n교체 가능한 그룹으로 Composable 함수 본문을 감싼다.\ncontent 람다 내부에서 방출된 모든 자식들은 이 교체 가능한 그룹의 자식으로 저장된다.\n다른 모든 Composable 함수도 동일한 방출 작업을 수행한다.\nremember를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  <span class=\"token function\">remember</span><span class=\"token punctuation\">(</span>calculation<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span>\n    currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span>invalid <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> calculation<span class=\"token punctuation\">)</span></code></pre></div>\n<p>remember는 제공된 람다가 반환한 값을 composition에 캐싱하기 위해 currentComposer를 사용한다.\ninvalid 매개변수는 값을 강제로 업데이트한다.</p>\n<p>cache 함수는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  Composer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span>invalid<span class=\"token operator\">:</span> Boolean<span class=\"token punctuation\">,</span> block<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">rememberedValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>invalid <span class=\"token operator\">||</span> it <span class=\"token operator\">===</span> Composer<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">val</span> value <span class=\"token operator\">=</span> <span class=\"token function\">block</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">updateRememberedValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n            value\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> it\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> T\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 composition(슬롯 테이블)에서 값을 검색한다.\n찾을 수 없으면 변경사항을 방출해서 값 업데이트를 예약한다.\n있으면 그대로 반환한다.</p>\n<hr>\n<h1 id=\"변경-사항-모델링-modeling-the-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EB%AA%A8%EB%8D%B8%EB%A7%81-modeling-the-changes\" aria-label=\"변경 사항 모델링 modeling the changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항 모델링 (Modeling the Changes)</h1>\n<p>currentComposer에 위임된 모든 방출 작업은 Change로 모델링되어 변경 목록에 추가된다.\nChange는 현재 Applier와 SlotWriter에 접근할 수 있는 지연된 함수다.\n작성자는 한 번에 하나만 활성화될 수 있다는 걸 기억하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">typealias</span> Change <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n    applier<span class=\"token operator\">:</span> Applier<span class=\"token punctuation\">,</span>\n    slots<span class=\"token operator\">:</span> SlotWriter<span class=\"token punctuation\">,</span>\n    rememberManager<span class=\"token operator\">:</span> RememberManager\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit</code></pre></div>\n<p>이런 변경사항들은 변경 목록에 추가된다. 다시 말해 기록된다.\n“방출”이라는 행위는 본질적으로 이런 Change들을 생성하는 것이다.\nChange는 슬롯 테이블에서 노드를 추가, 제거, 교체, 이동할 수 있는 지연된 람다식이며, 결과적으로 Applier에 변경사항을 알린다.\n궁극적으로 Applier를 통해 구체화된다.</p>\n<p>따라서 “변경사항 방출”, “변경사항 기록”, “변경사항 스케줄링”은 모두 같은 의미다.\nComposition이 끝나면 일련의 Composable 함수들이 호출되고, 모든 변경사항이 기록된다.\n그 후 Applier에 의해 모든 변경사항들이 일괄 적용된다.\nComposition 자체는 Composition 클래스로 모델링된다.</p>\n<hr>\n<h1 id=\"작성-시기-최적화-optimizing-when-to-write\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EC%84%B1-%EC%8B%9C%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94-optimizing-when-to-write\" aria-label=\"작성 시기 최적화 optimizing when to write permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>작성 시기 최적화 (Optimizing when to write)</h1>\n<p>새로운 노드를 삽입하는 것은 Composer에게 위임된다.\nComposer가 composition에 새로운 노드를 삽입하는 과정에 참여하고 있을 때, Compose는 항상 그 사실을 알고 있다.\n이런 경우 Composer는 변경사항을 변경 목록에 추가하지 않는다.\n곧바로 슬롯 테이블에 변경사항을 작성한다.\n그 외의 경우에는 변경사항이 변경 목록에 기록되고 지연된다.\n아직 적용할 시점이 아니기 때문이다.</p>\n<hr>\n<h1 id=\"쓰기-및-읽기-그룹-writing-and-reading-groups\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EA%B8%B0-%EB%B0%8F-%EC%9D%BD%EA%B8%B0-%EA%B7%B8%EB%A3%B9-writing-and-reading-groups\" aria-label=\"쓰기 및 읽기 그룹 writing and reading groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰기 및 읽기 그룹 (Writing and reading groups)</h1>\n<p>Composition이 완료되면 <code class=\"language-text\">composition.applyChanges()</code>가 호출된다.\n트리를 구체화하고 변경사항이 슬롯 테이블에 기록된다.</p>\n<p>Composer는 데이터, 노드, 그룹 등 다양한 유형의 정보를 작성할 수 있다.\n단순화를 위해 궁극적으로 모든 항목은 그룹 형태로 저장된다.\n그룹들은 서로 다른 그룹 필드로 차별화된다.</p>\n<p>Composer는 모든 그룹을 “시작”하고 “종료”할 수 있다.\n쓰기 작업 중이면 슬롯 테이블에서 “그룹 생성”과 “그룹 제거”를 의미한다.\n읽기 작업 중이면 SlotReader가 읽기 포인터를 그룹 외부로 이동한다.</p>\n<p>Composable 트리의 노드는 삽입뿐만 아니라 제거되거나 이동될 수도 있다.\n그룹을 제거한다는 것은 그룹과 모든 슬롯을 테이블에서 제거하는 것이다.\nComposer는 SlotReader를 재배치하고 해당 그룹을 건너뛰게 하며, 모든 노드를 Applier에서 제거한다.\n모든 수정 작업은 일괄 적용을 위해 예약(기록)되어야 한다.\n모든 변경사항이 동시에 반영되어야 의미 있기 때문이다.\nComposer는 제거된 그룹에 대한 모든 보류 중인 invalidation을 폐기한다.</p>\n<p>모든 그룹이 재시작/교체/이동/재사용 가능한 형태로 분류되는 것은 아니다.\n예를 들어 디폴트 값을 둘러싸는 블록도 매우 특정한 그룹으로 분류된다.\n<code class=\"language-text\">model: Model = remember { DefaultModel() }</code> 같은 형태다.</p>\n<p>Composer가 그룹을 시작하려고 할 때 다음과 같은 일이 발생한다.\n값들을 삽입하는 과정이면 곧바로 슬롯 테이블에 작성한다.\n보류 중인 작업이 있으면 변경사항 적용 시 모두 기록한다. 대상 그룹이 이미 존재하면 재사용한다.\n그룹이 다른 위치에 있으면(이동됨) 모든 슬롯을 이동하는 동작이 기록된다.\n새 그룹이면(테이블에 없음) 삽입 모드로 이동해서 중간 insertTable에 작성한 후 최종 테이블에 삽입을 예약한다.\n삽입 중도 아니고 보류 중인 작성 작업도 없으면 그룹 읽기를 시작한다.</p>\n<p>그룹 재사용은 흔하다.\n이미 존재하는 노드는 재사용할 수 있다.\nApplier에 의해 노드 이동 작업은 발행(기록)하지만, 생성과 초기화 작업은 생략한다.</p>\n<p>노드의 속성에 업데이트가 필요하면 그 업데이트 동작도 Change로 기록된다.</p>\n<hr>\n<h1 id=\"값-기억하기-remembering-values\" style=\"position:relative;\"><a href=\"#%EA%B0%92-%EA%B8%B0%EC%96%B5%ED%95%98%EA%B8%B0-remembering-values\" aria-label=\"값 기억하기 remembering values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>값 기억하기 (Remembering values)</h1>\n<p>Composer는 값을 composition에 기억하고(슬롯 테이블에 기록), 나중에 업데이트할 수 있다.\n마지막 composition으로부터 값이 변경되었는지 비교는 remember 함수가 호출되는 즉시 수행된다.\n하지만 업데이트 작업은 Composer가 값을 이미 삽입하는 중이 아니라면 Change로 기록된다.\n업데이트할 값이 RememberObserver인 경우 Composer는 암시적 Change도 기록한다.\ncomposition의 기억 작업을 추적하기 위해서다.\n나중에 기억하고 있는 모든 값을 다시 잊어야 할 때 사용한다.</p>\n<hr>\n<blockquote>\n<p><strong>RecomposeScope:</strong> Composition의 나머지 부분과 독립적으로 재구성될 수 있는 영역.</p>\n</blockquote>\n<h1 id=\"재구성-범위-recompose-scopes\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B5%AC%EC%84%B1-%EB%B2%94%EC%9C%84-recompose-scopes\" aria-label=\"재구성 범위 recompose scopes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재구성 범위 (Recompose scopes)</h1>\n<p>Composer를 통해 발생하는 또 다른 기능은 스마트 recomposition을 가능하게 하는 범위 재구성이다.\n이는 재시작 가능한 그룹과 직접 관련이 있다.\n재시작 가능한 그룹이 생성될 때마다 Composer는 RecomposeScope를 생성하고 이를 Composition의 currentRecomposeScope로 설정한다.</p>\n<p>RecomposeScope는 Composable의 recomposition을 수동으로 invalidate하고 트리거하는 데 사용할 수 있다.\ninvalidate는 <code class=\"language-text\">composer.currentRecomposeScope().invalidate()</code>와 같이 Composer를 통해 요청된다.\n재구성을 위해 Composer는 슬롯 테이블을 해당 그룹의 시작 위치에 배치한 다음 재구성 블록을 호출한다.\nComposable 함수가 다시 호출되어 한 번 더 방출되므로 Composer에게 테이블의 기존 데이터를 재정의하도록 요청한다.</p>\n<p>Composer는 invalidate된 모든 재구성 범위의 스택을 유지한다.\n다음 recomposition에서 트리거되어야 하는 보류 중인 범위들이다.\ncurrentRecomposeScope는 실제로 이 재구성 범위 스택을 통해 생성된다.</p>\n<p>RecomposeScope가 항상 활성화되는 것은 아니다.\nCompose가 Composable 함수 내에서 상태 스냅샷 읽기와 관련된 작업을 발견했을 경우에만 발생한다.\n이 경우 Composer는 RecomposeScope를 used로 표시한다.\n그러면 Composable 함수 끝에 삽입된 “end” 호출이 더 이상 null을 반환하지 않고 뒤따르는 recomposition 람다를 활성화한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// After compiler inserts boilerplate</span>\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> $composer<span class=\"token operator\">:</span> Composer<span class=\"token punctuation\">,</span> $changed<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    $composer<span class=\"token punctuation\">.</span><span class=\"token function\">startRestartGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    $composer<span class=\"token punctuation\">.</span><span class=\"token function\">endRestartGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">updateScope</span> <span class=\"token punctuation\">{</span> next <span class=\"token operator\">-></span>\n        <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">,</span> $changed <span class=\"token operator\">or</span> <span class=\"token number\">0b1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>endRestartGroup 함수 호출의 ? 문자 뒤를 보자.\nComposer는 재구성이 필요할 때 현재 상위 그룹의 invalidate된 하위 그룹을 모두 recomposition할 수 있다.\n그렇지 않은 경우 SlotReader가 그룹을 마지막까지 생략할 수 있다.\n(<a href=\"https://winter-love.dev/composeinternals/2-the-compose-compiler/#%EB%B9%84%EA%B5%90-%EC%A0%84%ED%8C%8C-comparison-propagation\">2장의 비교 전파 섹션 참고</a>)</p>\n<hr>\n<h1 id=\"composer와-사이드-이펙트-sideeffects-in-the-composer\" style=\"position:relative;\"><a href=\"#composer%EC%99%80-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-sideeffects-in-the-composer\" aria-label=\"composer와 사이드 이펙트 sideeffects in the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer와 사이드 이펙트 (SideEffects in the Composer)</h1>\n<p>Composer는 사이드 이펙트도 기록할 수 있다.\n사이드 이펙트는 항상 composition 이후에 실행된다.\n트리에 대한 변경사항 적용이 완료된 시점에 호출 가능한 함수 형태로 기록된다.\n이는 Composable 함수 외부에서 발생하는 이펙트를 나타내므로 Composable의 라이프사이클과 완전히 무관하다.\nComposition을 떠날 때 실행 중인 작업을 자동 취소하거나 recomposition에 이펙트를 재시도하는 것 같은 작업은 담당하지 않는다.\n이런 유형의 이펙트는 슬롯 테이블에 저장되지 않기 때문에 composition이 실패하면 간단히 폐기된다.</p>\n<hr>\n<h1 id=\"compositionlocals-저장-storing-compositionlocals\" style=\"position:relative;\"><a href=\"#compositionlocals-%EC%A0%80%EC%9E%A5-storing-compositionlocals\" aria-label=\"compositionlocals 저장 storing compositionlocals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CompositionLocals 저장 (Storing CompositionLocals)</h1>\n<p>Composer는 CompositionLocals를 등록하고 키를 통해 해당 값을 획득하는 방법을 제공한다.\n<code class=\"language-text\">CompositionLocal.current</code> 호출은 이에 의존한다.\nCompositionLocals의 Provider(공급자)와 공급되는 값은 모두 슬롯 테이블에 그룹 형태로 저장된다.</p>\n<hr>\n<h1 id=\"소스-정보-저장-storing-source-information\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EC%8A%A4-%EC%A0%95%EB%B3%B4-%EC%A0%80%EC%9E%A5-storing-source-information\" aria-label=\"소스 정보 저장 storing source information permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소스 정보 저장 (Storing source information)</h1>\n<p>Composer는 composition 중에 수집된 내용을 CompositionData 형태로 소스 정보를 저장한다.\n각종 Compose 툴에서 활용할 수 있도록 하기 위해서다.</p>\n<hr>\n<blockquote>\n<p><strong>Subcomposition:</strong> 독립적인 invalidation을 지원하기 위해 별도로 생성된 composition. 상위 composition과 CompositionContext로 연결됨.</p>\n</blockquote>\n<h1 id=\"compositioncontext를-이용한-composition-연결-linking-compositions-via-compositioncontext\" style=\"position:relative;\"><a href=\"#compositioncontext%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-composition-%EC%97%B0%EA%B2%B0-linking-compositions-via-compositioncontext\" aria-label=\"compositioncontext를 이용한 composition 연결 linking compositions via compositioncontext permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CompositionContext를 이용한 Composition 연결 (Linking Compositions via CompositionContext)</h1>\n<p>CompositionContext는 단일 composition에는 없지만 composition과 subcomposition 트리에 존재한다.</p>\n<p>Subcomposition은 독립적인 invalidation을 지원하기 위해 현재 컨텍스트에서 별도의 composition을 구성하려는 의도로 생성된 인라인 타입의 composition이다.\n상위 CompositionContext 참조를 통해 상위 composition과 연결된다.</p>\n<p>CompositionContext는 composition과 subcomposition을 하나의 트리로 연결하기 위해 존재한다.\nCompositionLocal과 invalidation이 마치 단일 composition에 속한 것처럼 투명하게 트리 아래로 전파되는 것을 보장한다.\nCompositionContext 자체도 슬롯 테이블에 그룹의 한 유형으로 기록된다.</p>\n<p>Subcomposition은 일반적으로 <code class=\"language-text\">rememberCompositionContext</code>를 통해 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">rememberCompositionContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CompositionContext <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">buildContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수는 슬롯 테이블의 현재 위치에 새 composition을 기억하거나, 이미 기억된 경우 이를 반환한다.\nVectorPainter, Dialog, SubcomposeLayout, Popup 같은 별도의 composition이 필요한 위치에서 subcomposition을 만드는 데 사용된다.\nAndroid View를 Composable 트리에 통합하기 위해 사용하는 wrapper인 AndroidView도 마찬가지다.</p>\n<hr>\n<h1 id=\"현재-상태-스냅샷에-접근--accessing-the-current-state-snapshot\" style=\"position:relative;\"><a href=\"#%ED%98%84%EC%9E%AC-%EC%83%81%ED%83%9C-%EC%8A%A4%EB%83%85%EC%83%B7%EC%97%90-%EC%A0%91%EA%B7%BC--accessing-the-current-state-snapshot\" aria-label=\"현재 상태 스냅샷에 접근  accessing the current state snapshot permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>현재 상태 스냅샷에 접근  (Accessing the current State snapshot)</h1>\n<p>Composer는 현재 스냅샷에 대한 참조를 가지고 있다.\n이는 현재 스레드에 대한 가변적인 상태 및 기타 상태 객체들이 반환하는 값의 스냅샷과 유사하다.\n모든 상태 객체는 스냅샷에서 명시적으로 변경되지 않는 한 스냅샷이 생성되었을 때와 동일한 값을 갖는다.</p>\n<hr>\n<h1 id=\"노드-탐색-navigating-the-nodes\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%83%90%EC%83%89-navigating-the-nodes\" aria-label=\"노드 탐색 navigating the nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 탐색 (Navigating the nodes)</h1>\n<p>노드 트리 탐색은 Applier에 의해 수행되지만 직접적으로 수행되지는 않는다.\n구독자에 의해 탐색되는 노드의 모든 위치를 기록하고 downNodes 배열에 기록함으로써 수행된다.\n노드 탐색이 실현되면 downNodes에 있는 모든 하향 노드 정보를 Applier에 전달된다.\n하향 노드 탐색이 수행되기 전에 상향 노드 탐색이 수행되는 경우에는 downNodes 스택에서 제거하여 탐색 경로를 단축한다.</p>\n<hr>\n<h1 id=\"구독자와-작성자의-동기화-유지--keeping-reader-and-writer-in-sync\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EB%8F%85%EC%9E%90%EC%99%80-%EC%9E%91%EC%84%B1%EC%9E%90%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%9C%A0%EC%A7%80--keeping-reader-and-writer-in-sync\" aria-label=\"구독자와 작성자의 동기화 유지  keeping reader and writer in sync permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구독자와 작성자의 동기화 유지  (Keeping reader and writer in sync)</h1>\n<p>구독자와 작성자의 동기화 유지는 low-level에서 이루어지는 작업이다.\n특정 그룹을 삽입, 삭제, 이동할 수 있으므로 작성자의 그룹 위치는 변경사항이 적용될 때까지 일시적으로 구독자의 위치와 다를 수 있다.</p>\n<p>이 차이를 추적하기 위해 델타를 유지 관리한다.\n델타는 삽입, 삭제, 이동에 따라 업데이트되며 “작성자와 구독자의 현재 슬롯 위치를 정확하게 일치시키기 위해 이동해야 하는 실현되지 않은 거리”를 반영한다.</p>\n<p>구독자와 작성자 간의 동기화는 Compose Runtime 라이브러리의 ComposerChangeListWriter에서 수행된다.\n이 클래스 내에는 writersReaderDelta 변수가 존재하고, 구독자와 작성자 간의 슬롯 위치를 지속적으로 계산하는 함수들이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">var</span> writersReaderDelta<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">moveReaderRelativeTo</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    writersReaderDelta <span class=\"token operator\">+=</span> location <span class=\"token operator\">-</span> reader<span class=\"token punctuation\">.</span>currentGroup\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">moveReaderToAbsolute</span><span class=\"token punctuation\">(</span>location<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    writersReaderDelta <span class=\"token operator\">=</span> location\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수들은 구독자와 작성자 간의 격차를 추적하기 위해 Composer에 의해 지속적으로 호출된다.\n그룹 생성이 시작되거나 값에 업데이트가 발생할 때마다 realizeOperationLocation 함수를 실행시켜 거리 간격을 정확하게 일치시킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">realizeOperationLocation</span><span class=\"token punctuation\">(</span>forParent<span class=\"token operator\">:</span> Boolean <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> location <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>forParent<span class=\"token punctuation\">)</span> reader<span class=\"token punctuation\">.</span>parent <span class=\"token keyword\">else</span> reader<span class=\"token punctuation\">.</span>currentGroup\n    <span class=\"token keyword\">val</span> distance <span class=\"token operator\">=</span> location <span class=\"token operator\">-</span> writersReaderDelta\n    <span class=\"token function\">runtimeCheck</span><span class=\"token punctuation\">(</span>distance <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string-literal singleline\"><span class=\"token string\">\"Tried to seek backward\"</span></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>distance <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        changeList<span class=\"token punctuation\">.</span><span class=\"token function\">pushAdvanceSlotsBy</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">)</span>\n        writersReaderDelta <span class=\"token operator\">=</span> location\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h1 id=\"변경-사항-적용하기-applying-the-changes\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-applying-the-changes\" aria-label=\"변경 사항 적용하기 applying the changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항 적용하기 (Applying the changes)</h1>\n<p>이번 챕터에서 여러 번 언급했듯이 Applier가 변경사항 적용을 담당한다.\nComposer는 이 추상화를 Applier에게 위임하여 composition 이후에 기록된 모든 변경사항을 적용한다.\n이것을 “구체화(materializing)“라고 한다.</p>\n<p>이 프로세스는 변경 목록을 실행하고 결과적으로 슬롯 테이블을 업데이트한다.\n슬롯 테이블에 저장된 composition 데이터를 해석하여 효과적으로 결과를 생성한다.</p>\n<p>런타임은 Applier의 구현체와 독립적이다.\n클라이언트 라이브러리가 구현할 것으로 기대되는 계약에 의존한다.\nApplier는 플랫폼과의 통합점과 같으므로 유즈케이스에 따라 인터페이스의 구현체가 전혀 달라질 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Applier<span class=\"token operator\">&lt;</span>N<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> current<span class=\"token operator\">:</span> N\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onBeginChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">down</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">insertTopDown</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">insertBottomUp</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> N<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>가장 먼저 보이는 것은 N 제네릭 타입 매개변수다.\nN 매개변수는 우리가 적용하는 노드의 타입을 결정한다.\n이것이 Compose가 제네릭 호출 그래프 또는 노드 트리와 함께 동작할 수 있는 이유다.\n사용되는 노드 타입에 대해서는 항상 상호운용이 가능하다.</p>\n<p>Applier는 트리를 탐색하고 노드를 삽입, 제거, 이동하는 작업을 제공한다.\n하지만 해당 노드의 타입이나 최종적으로 어떻게 삽입되는지는 관여하지 않는다.\n노드 자체에게 위임된다.</p>\n<p>Applier는 현재 노드에서 지정된 범위의 모든 하위 항목을 제거하거나, 하위 항목을 이동시키고 위치를 변경하는 방법도 정의한다.\nclear 작업은 루트를 가리키고 트리에서 모든 노드를 제거한다.\nApplier와 해당 루트를 향후 새 composition에 사용할 준비를 한다.</p>\n<p>Applier는 모든 노드를 방문하고 적용하면서 전체 트리를 순회한다.\n트리는 하향 또는 상향 순회할 수 있다.\nApplier는 방문하고 변경사항을 적용하는 현재 노드에 대한 참조를 항상 유지한다.</p>\n<p>Composer가 변경사항 적용을 시작하고 끝낼 때 <code class=\"language-text\">onBeginChanges()</code>와 <code class=\"language-text\">onEndChanges()</code>를 호출한다.\n<code class=\"language-text\">insertTopDown()</code>과 <code class=\"language-text\">insertBottomUp()</code>으로 상단에서 하단으로, 또는 하단에서 상단으로 노드를 삽입한다.\n<code class=\"language-text\">down()</code>으로 현재 노드의 자식 노드로 이동하고, <code class=\"language-text\">up()</code>으로 현재 노드의 부모로 이동한다.</p>\n<hr>\n<h1 id=\"노드-트리-구축-시-성능--performance-when-building-the-node-tree\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%B6%95-%EC%8B%9C-%EC%84%B1%EB%8A%A5--performance-when-building-the-node-tree\" aria-label=\"노드 트리 구축 시 성능  performance when building the node tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 트리 구축 시 성능  (Performance when building the node tree)</h1>\n<p>트리를 하향식으로 작성하는 것과 상향식으로 작성하는 것에는 중요한 차이가 있다.</p>\n<p><strong>하향식 삽입  (Inserting top‑down)</strong></p>\n<p>아래와 같은 트리가 있다고 가정해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 138.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAACzklEQVR42tVVzU8TQRTf8qXxDzDReDPKyROx0YvEgwnc1IQ7N/8COdrEgwe9qCQNUChqWyRbS4WuLP2iS+lWSlvaClisoUAhUMpXC2wL1e5zX8vCEgjpwslJJvPb934z++a938wQxH/fVKCqOA2frwGhwKHeVV+FXWqTvxZAcSKZpJ65d3wz2BFLfWU3kiQrcfyw0vtwshCDwGaEn8hM8Yg7BZuUU250RbJ1m2mJwRy8N6tzbXRX7hfMg3Xb3SLlyIqwZ7m/IcLPAJv0895VP49Yv2xslB2htPWt0c+9XDCOHfHFJKMqyURv/dz8idY3S20X0iAzwNy39dvuYXUvtuDBZE3IoNRO9N49f4SieFVExUDKrh7Lhvjv2QkeMdpkC5yEUgWNKappFpbg25StYP/NFBAbN6gmKUeWDh3bnpZZWAQ11ZHrsGpziNEmW4diMVqT2jv+/GQmzE1DJBuFwJ/JNNrkXxRCfnBL5i/mx8bQ11dOjqWdO94hY9D82kSaHhXPcrk5FHPj6nZdpmn6qcViUYo+iqIeWAYHnwinpKasPB7eIlBf1cXoG7U2wy38DECgGjtiHa2r1bi6G4gAUX3mzSPmRJMglc5NT9CXDW3Y06MOdbyzVuS0Ln287cx47D4utDmcZoOahEF5ej6PdFfl5nxsXJCHa8GTT0ASHDsek0gb3mVN6LPHR/Ix4eYZzflZoomoPNie4kR0HYu6G5G/0VXHnLvwou3lnj8dhnA++pMYJC4JP6uJFGJRV4KFt33qPTY5XgjuT6c613qun4zyqGIKNzfunIcVCKR/7OPo3GX1Is2ecRsWIQVj68H9BcGH3FPWOF6QdwvtN21bIxYvF4gPbTE6VfjN1cOdCJjeYHR4lSEHuWcW5tAhnNe69rorGLH0zwd+xTX0CRwgytCjMKkCewmTlcefUfSVtCfllXVSzjpaRd95n1O57R/PrAH+Fhy8uAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"\"\n        src=\"/static/bb176ec8f505adb0b11e3728eaf4ace2/37523/1.png\"\n        srcset=\"/static/bb176ec8f505adb0b11e3728eaf4ace2/e9ff0/1.png 180w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/f21e7/1.png 360w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/37523/1.png 720w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/302a4/1.png 1080w,\n/static/bb176ec8f505adb0b11e3728eaf4ace2/11a8f/1.png 1272w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 트리를 하향식으로 구축하려면 먼저 B를 R에 삽입한 다음 A를 B에 삽입하고 마지막으로 C를 B에 삽입한다.\n즉, 아래 그림과 같은 순서(좌측에서 우측)로 동작한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACwklEQVR42rVTzU8TQRwtYggY0aLU8GGUgzHGGBNj4k0T/wgSIgdj4kG9ES9gxHIwXoz2IJoQaRaMbeOEZdd2XUp229kt3WkLFZDyEQFFEDDQj6VUKGki485iEWhNvDDJZibv98ub995v1mDYj4UxLgCjoMiADQV7awQ3m80H/hffKgJQCF6DY1nynRfZ2+1VEMKDO9r1OsHBM1CSn3CJq5DTodsA8ybOxpUBCA4TnFEZI8GZNKzhXtnKnE7nIb1/DpT40v23XHF4Ya8IfflW+9+Ob05jbe+0WCxGhJCuVloJPB3bnMJ9q/1uO2uvCgaDRwiONsJNw5kJ7IuHhrWYcm17VKUlmBzEnoTSbDFbjG7k1gk9Cd9dlAhjqKJWYAUmPsjrhGJKqfNFQ9izrHTlVahlWMT6uevkzLJslfaVZmuswl1r06zSNF2ZtazHITFXGcgY82bI/OipgUtKSw+WK+k39AkggKMEty04y+VY4CEfE88Thdpw9Gzbo2ypdxk9cMfEK3kVDqQj777iBRzeiNgbGxvLshkG1geff8Hz+ON6xNMBOqr9ExO68lBmuPnz5jccWv0U0TIszFEoqsp9cb4PC6q/gTJTWoZbhL2zsMmz4MdeVXlitVpNQljQlQtz0j3hu5QR5+UPtbW1hTkKyYOGeMuOy+WqJlkBhEocnY6zThzWc+Np/iRFUcXUDCy2UbZzAI8WORyOGuAC1bm2NcIs0P2i+3jvoveyFEcDMI5atwdHgYr3c+4zcjzgkxMBm+5sRamTo2hGSEg3/pAe2PX7kd18+mbx0Np4w8yvRTySmoxDHC4nOHlOodRQ/dTGLB5NTq21rXeeGvk5aY/hFB7LTHf9k5AHvIkepythEj12R+X6bJ0DXAUFKaN3xf9IjPvv6L2qdAkmgy/5hHgx77T3bZGbiPxdFv7WtvEdfdvKfgOrUsb0cwiUEQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"\"\n        src=\"/static/434146ece8a02d8c9abdafc06d48ddbd/37523/2.png\"\n        srcset=\"/static/434146ece8a02d8c9abdafc06d48ddbd/e9ff0/2.png 180w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/f21e7/2.png 360w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/37523/2.png 720w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/302a4/2.png 1080w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/07a9c/2.png 1440w,\n/static/434146ece8a02d8c9abdafc06d48ddbd/78ed4/2.png 2566w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><strong>상향식 삽입 (Inserting bottom‑up)</strong></p>\n<p>트리의 상향식 구축은 A와 C를 B에 삽입한 다음, B 트리를 R에 삽입하는 것으로 시작된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAClUlEQVR42rVTz2vTcBTv7OZ0mw42XQc6GU4U/wAVERxe9OJOssME8eZJYV5FiEdRBgpD6Xao3cDBF7o2TU3aJWn6I+m6Lq61blW7TUXUNmtWarUrOOGZb2ak+5GL4IMv7+Xx4ZP3Pu89i+V/mSzLDdpr2ppLpVLNO+Fpmm4UBKHFlNButzeMj4/vx7EGrMfeITj2kBxnMzA4DwB1OPZ6vU1jrrEOHBu5Tcap4p3gaszhXvR3+ZCvE+emlPBNfkVkptTQSfzNMEw3Qmg3jlk1epcvSM9Qyd+2jZQFuXVWTavz5UWIr70aGO4lWnqBqE+WFxKfQIGZauqW3iZP92A/A5n2ueJ8IVNZAhkyl/8QWi21zFw+PBjMSSMoSx8kSdLWb7FY/W+5QUGN2T1h33mMcddUqFV+O6hII17wNm2tcEMTwXvAI3pOoH5kJWPkMX5VGphMvTiud7AcvBKoRM5oZJ14GDjnCrg6MH5HDfsBWQVV9AmK+HEiO9kTUqafLsNniJYSjokq0y2ps7/i5eQP6s3UJX36IDdwSpRiv0Te85DQSQkgdv0l9IC4b+bbXD798x3wJfGif4kbjBTiwK2IxDCgFiEnLfF5MUMl/acxfhrStnhpTklWMiCvv9Y1RFpRmzRkS9Kp6HqibwgN7aUo6lAAUs0EbKxPAALNj4FudE+4u5Amvv3G/VY6y/Wx+ehV5yPnEdPVMfbL5XId1tsgtDbAUmeAydHnNmY1dDakTo/68uxRfZi56BCjRK5tIzU0wIS4wlqA4YknDzuSlQVKhe/wsrpwj6uKFz7AV0ivZXOjJdRmWqEZ4aTT2c4q4etCIRYPlCPnUBG1hotxOlSUHpieIG4T37DZvZtq9a+GCY1n6Fv7k98hwrPmcxMu5wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3\"\n        title=\"\"\n        src=\"/static/cf97a607676ef4497f404bdd62879df1/37523/3.png\"\n        srcset=\"/static/cf97a607676ef4497f404bdd62879df1/e9ff0/3.png 180w,\n/static/cf97a607676ef4497f404bdd62879df1/f21e7/3.png 360w,\n/static/cf97a607676ef4497f404bdd62879df1/37523/3.png 720w,\n/static/cf97a607676ef4497f404bdd62879df1/302a4/3.png 1080w,\n/static/cf97a607676ef4497f404bdd62879df1/07a9c/3.png 1440w,\n/static/cf97a607676ef4497f404bdd62879df1/81a70/3.png 2616w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>하향식과 상향식의 트리 작성 성능은 상당히 다를 수 있다.\n사용되는 Applier의 구현체에 따라 성능의 결과가 달라지며, 일반적으로 새 하위 항목이 삽입될 때마다 알림을 받아야 하는 노드 수에 따라 달라진다.</p>\n<p>Compose로 표현하려는 그래프에 노드가 삽입될 때마다 노드의 모든 상위 항목에 알려야 한다고 상상해보자.\n하향식 삽입의 경우는 수많은 노드(부모 노드, 부모의 부모 노드 등 먼 조상까지)에게 알려야 할지도 모른다.\n그래프에 새로운 깊이가 추가될 때마다 변경사항을 알려야 할 노드가 기하급수적으로 증가한다.</p>\n<p>대신 상향식 삽입의 경우 부모가 아직 트리에 연결되어 있지 않기 때문에 언제나 직속 부모 노드에게만 알린다.\n자식 노드에게만 변화를 알리는 형태의 전략을 취한다면 노드의 변화를 알리기 위한 비용을 많이 절감시킬 수 있다.</p>\n<p>따라서 전략은 표현하고 있는 트리에 따라서, 혹은 변경사항들이 트리의 위쪽이나 아래쪽에 어떻게 알려져야 하는지에 따라서 달라질 수 있다.\n핵심은 노드 삽입 전략을 둘 다 선택해서는 안 되고, 단 하나만을 선택해야 한다는 것이다.</p>\n<hr>\n<h1 id=\"변경-사항이-적용되는-방식-how-changes-are-applied\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD%EC%9D%B4-%EC%A0%81%EC%9A%A9%EB%90%98%EB%8A%94-%EB%B0%A9%EC%8B%9D-how-changes-are-applied\" aria-label=\"변경 사항이 적용되는 방식 how changes are applied permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변경 사항이 적용되는 방식 (How changes are applied)</h1>\n<p>클라이언트 라이브러리는 Applier 인터페이스에 대한 구현을 제공한다.\n그중 하나가 Android UI에서 사용되는 UiApplier다.\nUiApplier는 “노드 적용”의 의미를 내포하며, 디바이스 스크린에서 볼 수 있는 구성 요소를 어떻게 생성하는지 보여주는 완벽한 예시다.</p>\n<p>구현체를 살펴보면 별로 거창하지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">class</span> <span class=\"token function\">UiApplier</span><span class=\"token punctuation\">(</span>\n    root<span class=\"token operator\">:</span> LayoutNode\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> AbstractApplier<span class=\"token operator\">&lt;</span>LayoutNode<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">insertTopDown</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> LayoutNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Ignored.</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">insertBottomUp</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> instance<span class=\"token operator\">:</span> LayoutNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">insertAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> instance<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">removeAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token operator\">:</span> Int<span class=\"token punctuation\">,</span> count<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">,</span> <span class=\"token keyword\">to</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onClear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        root<span class=\"token punctuation\">.</span><span class=\"token function\">removeAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onEndChanges</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>owner <span class=\"token keyword\">as</span><span class=\"token operator\">?</span> AndroidComposeView<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">clearInvalidObservations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>가장 먼저 볼 수 있는 것은 Applier 인터페이스의 제네릭 타입 N이 LayoutNode로 바뀌었다는 것이다.\n이는 렌더링될 UI 노드를 나타내기 위해 Compose UI가 선택한 노드 타입이다.</p>\n<p>다음으로 주목해야 할 점은 AbstractApplier를 상속받는 형태다.\n이는 방문한 노드를 스택에 저장하는 기본 구현체다.\n트리 하단에서 새 노드를 방문할 때마다 스택에 추가하고, 방문자가 위로 이동할 때마다 마지막으로 방문한 노드를 스택 상단에서 제거한다.\n일반적으로 여러 Applier 간에 공통적으로 사용되는 스펙이기 때문에 추상 클래스로 만든 것이다.</p>\n<p>Android의 경우 노드 삽입이 상향식으로만 수행되기 때문에 UiApplier에서 insertTopDown이 무시되는 것을 확인할 수 있다.\n노드 선택 전략은 둘 중 하나를 선택하는 것이 중요하다.\n이 경우 새 하위 항목이 삽입될 때마다 중복되는 노드 알림을 방지하려면 상향식 전략이 더 적합하다.</p>\n<p>노드를 삽입, 제거, 이동하는 방법은 모두 노드 자체에 위임된다.\nLayoutNode는 Compose UI가 UI 노드를 모델링하는 방법이므로 상위 노드와 하위 노드에 관한 모든 것을 알고 있다.\n노드를 삽입한다는 것은 해당 노드를 주어진 위치의 새 부모 노드에 연결하는 것을 의미한다.\n노드를 이동한다는 것은 본질적으로 부모 노드의 자식 노드들을 재정렬하는 것을 의미한다.\n노드를 제거한다는 것은 단순히 목록에서 해당 노드를 제거하는 것을 의미한다.</p>\n<p>변경사항 적용이 끝나면 <code class=\"language-text\">onEndChanges()</code>를 호출할 수 있다.\n이는 최종적인 요구사항을 루트 노드 소유자에게 위임한다.\n변경사항을 적용하기 전에 항상 <code class=\"language-text\">onBeginChanges()</code>가 먼저 호출된다고 가정되므로 <code class=\"language-text\">onEndChanges()</code>는 마지막에 호출해야 한다.</p>\n<p><code class=\"language-text\">onEndChanges()</code>가 호출된 시점에서 모든 보류 중인 무효화된 관찰들이 해제된다.\n이 스냅샷 관찰들은 읽고 의존하는 값이 변경될 때 자동으로 레이아웃이나 화면에 그리는 작업을 다시 호출하기 위한 것이다.\n트리에서 노드가 추가되거나 삽입되거나 교체되거나 이동되는 것이 레이아웃 크기의 측정이나 구성 등에 어떻게 영향을 미칠 수 있는지 생각해보자.</p>\n<hr>\n<h1 id=\"노드-연결-및-그리기-attaching-and-drawing-the-nodes\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-%EC%97%B0%EA%B2%B0-%EB%B0%8F-%EA%B7%B8%EB%A6%AC%EA%B8%B0-attaching-and-drawing-the-nodes\" aria-label=\"노드 연결 및 그리기 attaching and drawing the nodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 연결 및 그리기 (Attaching and drawing the nodes)</h1>\n<p>트리에 노드를 삽입하면 어떻게 화면에 나타날까?\n노드는 스스로 연결하고 그리는 방법을 알고 있다.</p>\n<p>UiApplier가 LayoutNode에게 삽입을 위임하면 다음 순서로 진행된다.\n조건 확인 (부모 노드 없는지 등), Z 인덱스 정렬된 자식 목록 invalidate, 부모 노드와 Owner에 연결, invalidate 수행.</p>\n<p>Owner는 트리의 루트에 존재한다.\nComposable 트리를 안드로이드 뷰 시스템과 연결하는 통합 계층이다.\nAndroidComposeView(표준 View)로 구현된다.\n모든 레이아웃, 그리기, 입력, 접근성은 Owner를 통해 연결된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACKUlEQVR42mNgoAv4/58RRCnO/ixuvfJPrdO6P3WOa//UWq743WKy6KcOWE39fybiDYQq1l77U997//9/6af//08/9e9P0Kn//y02/4kGydnv/89Cukt3/udmuPzfVOnIfy/Dg1+DGc78N+c5918U2RfE+ZiBAaz4NWeS1H+hgt7/qtVT/+rWzfwvVjT1J3+2EURNPRMJBkIUv1Ro0v+rM+nff6uZ///ZzPzz33j2/88qbWAv/7evZyHBQIh3NkyeI3U2tMvjPkOs5m3WOO1LNrX227pm60F8jMfL/xlCmUH0c9mK8PfKdcc/abdu/6TVsuedWv2WHRbJQsiufqZe2/FJrfkYUM22zxotB1/KVfdjGgh1/lu5qtL/xpP/f7fs//XXbur/b6rN746LRYiD5M4wpLGC6A+yNWv+W0z7/92q/8d/2+n/P8rXHcRMJUDb6+3tWWYyMLCuyGs0nWuTKLosuVJvkW+OYj0DA1M91HWrGBiYJwqZ8a3KbrScyKDCtyKz1nRBaKE0UIqxHjmSHitXxL437fj60ab3xXuzzpvn5HK13hm2Hv1g0/vyg0X37xdaDYXreAOE3+u3vfpo0/f8vVXPq0fKlbnvjNsufbDte/nOvPPXU/WaKLiBz5SqTD7otXYBNbS+0WqsuyKaJfFWq6H4vX572wedlr7n6tUOi8Rdud/rNLd81Gtteafb3HFfvtzhjXZj1Xu9ttZ32i29z5RrjWmSbQGL/PrNKxYmiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4\"\n        title=\"\"\n        src=\"/static/c65103cb98020ebdff04da2997ed8ae7/37523/4.png\"\n        srcset=\"/static/c65103cb98020ebdff04da2997ed8ae7/e9ff0/4.png 180w,\n/static/c65103cb98020ebdff04da2997ed8ae7/f21e7/4.png 360w,\n/static/c65103cb98020ebdff04da2997ed8ae7/37523/4.png 720w,\n/static/c65103cb98020ebdff04da2997ed8ae7/302a4/4.png 1080w,\n/static/c65103cb98020ebdff04da2997ed8ae7/07a9c/4.png 1440w,\n/static/c65103cb98020ebdff04da2997ed8ae7/84bc0/4.png 3176w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>LayoutNode는 Owner와 연결되어야 화면에 나타난다.\nOwner는 setContent 호출 시 설정된다.\nActivity, Fragment, ComposeView에서 setContent를 호출하면 AndroidComposeView가 생성되어 View 계층에 연결되고 Owner로 설정된다.</p>\n<hr>\n<h1 id=\"composition\" style=\"position:relative;\"><a href=\"#composition\" aria-label=\"composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition</h1>\n<p>Composer가 Composition에 대한 참조를 가지고 있어서 Composer가 Composition을 생성하고 소유한다고 생각할 수 있다.\n하지만 실제로는 그 반대다.\nComposition이 생성되면 Composer는 스스로 구축한다.\nComposer는 currentComposer 메커니즘을 통해 접근할 수 있으며, Composition이 관리하는 트리를 생성하고 업데이트하는 데 사용된다.</p>\n<p>클라이언트 라이브러리는 두 가지 진입점을 통해 Jetpack Compose Runtime에 접근한다.</p>\n<p>Composable 함수 작성: 관련된 모든 정보를 방출하고 런타임과 연결한다.\nsetContent: 대상 플랫폼과의 통합 계층. Composition이 생성되고 시작된다. Composable 함수는 Composition 프로세스 없이는 실행되지 않기 때문에 필요하다.</p>\n<hr>\n<h1 id=\"composition-생성하기-creating-a-composition\" style=\"position:relative;\"><a href=\"#composition-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0-creating-a-composition\" aria-label=\"composition 생성하기 creating a composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition 생성하기 (Creating a Composition)</h1>\n<p>Android에서는 <code class=\"language-text\">ViewGroup.setContent</code> 호출로 새 composition을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doSetContent</span><span class=\"token punctuation\">(</span>\n    owner<span class=\"token operator\">:</span> AndroidComposeView<span class=\"token punctuation\">,</span>\n    parent<span class=\"token operator\">:</span> CompositionContext<span class=\"token punctuation\">,</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Composition <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> original <span class=\"token operator\">=</span> <span class=\"token function\">Composition</span><span class=\"token punctuation\">(</span><span class=\"token function\">UiApplier</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> wrapped <span class=\"token operator\">=</span> <span class=\"token function\">WrappedComposition</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">,</span> original<span class=\"token punctuation\">)</span>\n    wrapped<span class=\"token punctuation\">.</span><span class=\"token function\">setContent</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> wrapped\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>WrappedComposition은 Composition을 AndroidComposeView에 연결하는 데코레이터다.\n안드로이드 Context 정보를 CompositionLocal로 제공한다.\nUiApplier는 트리의 루트 LayoutNode를 가리킨다.\n클라이언트 라이브러리가 Applier 구현을 선택한다.</p>\n<p>VectorPainter는 자신만의 Composition을 생성한다.\nVectorApplier를 사용하며 벡터 트리의 루트 노드(VNode)를 가리킨다.\nSubcomposeLayout도 자체 Composition을 유지한다. 측정 단계에서 내용을 하위 구성할 수 있다.</p>\n<p>상위 CompositionContext를 전달하면 새 composition을 기존 composition에 논리적으로 연결한다.\ninvalidation과 CompositionLocal이 전체에서 동일하게 작동한다.\nrecomposition 컨텍스트로 변경사항을 적용할 CoroutineContext를 지정할 수 있다.\n제공하지 않으면 EmptyCoroutineContext가 사용된다.</p>\n<p>Composition은 더 이상 필요하지 않으면 <code class=\"language-text\">composition.dispose()</code>로 폐기해야 한다.</p>\n<hr>\n<h1 id=\"초기-composition-과정-the-initial-composition-process\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0-composition-%EA%B3%BC%EC%A0%95-the-initial-composition-process\" aria-label=\"초기 composition 과정 the initial composition process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기 Composition 과정 (The initial Composition process)</h1>\n<p><code class=\"language-text\">composition.setContent(content)</code>가 호출되면 슬롯 테이블이 데이터로 채워진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">setContent</span><span class=\"token punctuation\">(</span>content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>composable <span class=\"token operator\">=</span> content\n    parent<span class=\"token punctuation\">.</span><span class=\"token function\">composeInitial</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> composable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>상위로 계속 위임하다가 결국 Recomposer가 초기 composition을 수행한다.</p>\n<p>모든 State 객체의 현재 값을 스냅샷으로 취합한다.\n이 스냅샷은 가변적이지만 동시성에 안전하다.\nState 변경사항은 해당 객체에만 발생하고 나중에 전역 상태와 원자적으로 동기화된다.\n<code class=\"language-text\">snapshot.enter(block)</code> 안에서만 State 값 수정 가능하다.\nRecomposer는 State 읽기/쓰기 관찰자를 전달해서 composition에 알린다.</p>\n<p><code class=\"language-text\">composition.composeContent(content)</code>가 실행되고 Composer가 실제 composition을 수행한다.\n완료되면 <code class=\"language-text\">snapshot.apply()</code>로 변경사항을 전역 상태에 전파한다.</p>\n<p>진행 중이면 재진입 불가. 보류 중인 invalidation을 복사하고, isComposing을 true로 설정한다.\n<code class=\"language-text\">startRoot()</code> → <code class=\"language-text\">startGroup</code> → content 람다 호출 → <code class=\"language-text\">endGroup</code> → <code class=\"language-text\">endRoot()</code> 순으로 진행한다.\n완료 후 <code class=\"language-text\">isComposing</code>을 <code class=\"language-text\">false</code>로 변경하고 임시 데이터를 삭제한다.</p>\n<hr>\n<h1 id=\"초기-composition-후-변경-사항-적용-applying-changes-after-initial-composition\" style=\"position:relative;\"><a href=\"#%EC%B4%88%EA%B8%B0-composition-%ED%9B%84-%EB%B3%80%EA%B2%BD-%EC%82%AC%ED%95%AD-%EC%A0%81%EC%9A%A9-applying-changes-after-initial-composition\" aria-label=\"초기 composition 후 변경 사항 적용 applying changes after initial composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기 Composition 후 변경 사항 적용 (Applying changes after initial Composition)</h1>\n<p>초기 composition 이후 Applier는 <code class=\"language-text\">composition.applyChanges()</code> 프로세스 중에 기록된 모든 변경사항을 적용하라는 알림을 받는다.</p>\n<p><code class=\"language-text\">applier.onBeginChanges()</code>를 호출하고 모든 변경사항을 실행한다.\n필요한 Applier와 SlotWriter 인스턴스를 각 변경사항에 전달한다.\n마지막으로 모든 변경사항이 적용된 후 <code class=\"language-text\">applier.onEndChanges()</code>를 호출한다.</p>\n<p>등록된 모든 RememberedObserver를 전달하므로 RememberObserver 계약을 구현하는 모든 클래스는 composition에 들어가거나 나갈 때 알림을 받을 수 있다.\n<code class=\"language-text\">LaunchedEffect</code>나 <code class=\"language-text\">DisposableEffect</code> 같은 항목이 RememberedObserver를 구현하므로 composition 내의 Composable 수명 주기에 대한 이펙트를 제한할 수 있다.</p>\n<p>그 직후 모든 사이드 이펙트들은 기록된 순서대로 실행된다.</p>\n<hr>\n<h1 id=\"composition에-대한-추가-정보-additional-information-about-the-composition\" style=\"position:relative;\"><a href=\"#composition%EC%97%90-%EB%8C%80%ED%95%9C-%EC%B6%94%EA%B0%80-%EC%A0%95%EB%B3%B4-additional-information-about-the-composition\" aria-label=\"composition에 대한 추가 정보 additional information about the composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composition에 대한 추가 정보 (Additional information about the Composition)</h1>\n<p>Composition은 보류 중인 invalidation을 인지하고 있다.\n<code class=\"language-text\">isComposing</code> 플래그로 현재 composition 수행 중인지 알고 있어서 invalidation을 즉시 적용하거나 연기할 수 있다.</p>\n<p>런타임은 ControlledComposition에 의존한다.\nRecomposer가 invalidation과 recomposition을 조율할 수 있게 해준다.</p>\n<p>Composition은 관찰 중인 객체들이 변경되면 recomposition을 강제할 수 있다.\n상위 composition에서 CompositionLocal이 변경되면 하위 composition도 recomposition된다.</p>\n<p>오류 발견 시 composition을 중단하고 Composer를 재설정한다.\ncurrentRecomposeScope가 recomposition을 요구하지 않으면 건너뛴다.</p>\n<hr>\n<h1 id=\"recomposer-the-recomposer\" style=\"position:relative;\"><a href=\"#recomposer-the-recomposer\" aria-label=\"recomposer the recomposer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer (The Recomposer)</h1>\n<p>Recomposer는 ControlledComposition을 제어한다.\n필요할 때 recomposition을 트리거하고 변경사항들을 적용한다.\ncomposition이나 recomposition할 스레드와 변경사항을 적용할 스레드를 결정한다.</p>\n<hr>\n<h1 id=\"recomposer-생성-spawning-the-recomposer\" style=\"position:relative;\"><a href=\"#recomposer-%EC%83%9D%EC%84%B1-spawning-the-recomposer\" aria-label=\"recomposer 생성 spawning the recomposer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer 생성 (Spawning the Recomposer)</h1>\n<p>루트 composition의 부모가 Recomposer가 된다.</p>\n<p>Android의 <code class=\"language-text\">ViewGroup.setContent</code>를 호출하면 WindowRecomposerFactory가 Recomposer를 생성한다.\n생성된 Recomposer는 수명 주기를 인식해서 뷰 트리가 연결되지 않으면 취소된다.</p>\n<p>AndroidUiDispatcher는 Choreographer와 메인 Looper의 핸들러와 연결된다.\nMonotonicFrameClock과도 연결되어 프레임 렌더링을 조정한다.</p>\n<p>PausableMonotonicFrameClock을 생성한다.\nWindow가 보이지 않을 때 이벤트 전달을 일시 중지할 수 있다.</p>\n<p>Recomposer 인스턴스화 시 CoroutineContext를 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> contextWithClock <span class=\"token operator\">=</span> currentThreadContext <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>pausableClock <span class=\"token operator\">?:</span> EmptyCoroutineContext<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> recomposer <span class=\"token operator\">=</span> <span class=\"token function\">Recomposer</span><span class=\"token punctuation\">(</span>effectCoroutineContext <span class=\"token operator\">=</span> contextWithClock<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 컨텍스트는 변경사항을 적용하고 <code class=\"language-text\">LaunchedEffect</code>에서 이펙트를 실행하는 데 사용된다.</p>\n<p>뷰 트리 수명 주기에 관찰자를 연결한다.\n<code class=\"language-text\">onCreate</code> 시 <code class=\"language-text\">recomposer.runRecomposeAndApplyChanges()</code>로 recomposition 작업을 시작한다.\n<code class=\"language-text\">onStart</code>/<code class=\"language-text\">onStop</code> 시 이벤트 재개/일시 중지, <code class=\"language-text\">onDestroy</code> 시 Recomposer 종료.</p>\n<p>이 함수는 invalidation을 기다리고 recomposition한 후 변경사항을 적용한다.</p>\n<hr>\n<h1 id=\"recomposition-프로세스-recomposition-process\" style=\"position:relative;\"><a href=\"#recomposition-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-recomposition-process\" aria-label=\"recomposition 프로세스 recomposition process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposition 프로세스 (Recomposition process)</h1>\n<p><code class=\"language-text\">recomposer.runRecomposeAndApplyChanges()</code> 호출 시 invalidation을 기다리다가 발생하면 자동으로 recomposition한다.</p>\n<p>먼저 변경사항 전파 프로세스에 관찰자를 등록한다.\n상태 변경 시 자동으로 recomposition을 트리거한다.</p>\n<p>Recomposer는 모든 Composition을 invalidate하고 모든 것이 변경되었다고 가정한다.\n이전 변경사항은 추적되지 않았으니 처음부터 기록한다.\n보류 중인 invalidation이 유입될 때까지 작업을 지연한다.</p>\n<p><code class=\"language-text\">parentFrameClock.withFrameNanos {}</code>를 호출하고 다음 프레임을 기다린다.\n블록 내에서 모노리틱 클럭 프레임을 애니메이션 같은 대기자에게 전달한다.\n이로 인해 새로운 invalidation이 발생할 수 있다.</p>\n<p>보류 중인 모든 스냅샷에 대해 invalidation을 수행한다.\n마지막 recomposition 이후 수정된 모든 상태 값을 가져와 보류 중인 recomposition으로 기록한다.</p>\n<p>각 composition에 대해 recomposition을 수행하고 변경사항 적용을 보류 목록에 추가한다.\nRecomposition은 Composition 상태(슬롯 테이블)와 구체화된 트리(Applier)에 필요한 모든 변경을 다시 계산하는 것이다.\n값 변경으로 다시 composition을 수행해야 하는 잠재적인 recomposition을 찾아내고 작업으로 예약한다.\n적용할 변경사항이 있는 모든 Composition을 검토하고 <code class=\"language-text\">composition.applyChanges()</code>를 호출한다.</p>\n<hr>\n<h1 id=\"recomposition의-동시성-concurrent-recomposition\" style=\"position:relative;\"><a href=\"#recomposition%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-concurrent-recomposition\" aria-label=\"recomposition의 동시성 concurrent recomposition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposition의 동시성 (Concurrent recomposition)</h1>\n<p>Recomposer는 recomposition을 동시에 수행할 수 있는 기능이 있다.\nCompose UI는 이 기능을 사용하지 않지만 다른 클라이언트 라이브러리는 필요에 따라 사용할 수 있다.\n<code class=\"language-text\">runRecomposeConcurrentlyAndApplyChanges</code> 함수로 recomposition을 동시에 대응할 수 있다.\n상태 스냅샷 invalidation을 기다리고 자동으로 recomposition을 트리거하는 suspend 함수다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">runRecomposeConcurrentlyAndApplyChanges</span><span class=\"token punctuation\">(</span>\n    recomposeCoroutineContext<span class=\"token operator\">:</span> CoroutineContext\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">runRecomposeAndApplyChanges</code>와의 차이점은 외부에서 제공되는 CoroutineContext를 사용하여 invalidation된 Composition의 recomposition을 수행한다는 점이다.</p>\n<p>전달된 컨텍스트로 자체 CoroutineScope를 생성하고 이를 사용하여 필요한 모든 recomposition을 동시에 수행하기 위한 하위 작업을 생성하고 조정한다.</p>\n<hr>\n<h1 id=\"recomposer의-상태-recomposer-states\" style=\"position:relative;\"><a href=\"#recomposer%EC%9D%98-%EC%83%81%ED%83%9C-recomposer-states\" aria-label=\"recomposer의 상태 recomposer states permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recomposer의 상태 (Recomposer states)</h1>\n<p>Recomposer는 수명 주기를 나타내는 일련의 상태를 갖는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> State <span class=\"token punctuation\">{</span>\n    ShutDown<span class=\"token punctuation\">,</span>\n    ShuttingDown<span class=\"token punctuation\">,</span>\n    Inactive<span class=\"token punctuation\">,</span>\n    InactivePendingWork<span class=\"token punctuation\">,</span>\n    Idle<span class=\"token punctuation\">,</span>\n    PendingWork\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 상태의 의미는 다음과 같다.</p>\n<p><strong>ShutDown</strong>: Recomposer가 취소되고 정리 작업이 완료되었다. 더 이상 사용할 수 없다.</p>\n<p><strong>ShuttingDown</strong>: Recomposer가 취소되었지만 여전히 정리 작업 중이다. 더 이상 사용할 수 없다.</p>\n<p><strong>Inactive</strong>: Recomposer는 Composer의 invalidation을 무시하고 recomposition을 트리거하지 않는다. Recomposition 관찰을 시작하려면 <code class=\"language-text\">runRecomposeAndApplyChanges</code>를 호출해야 한다. 생성 후 Recomposer의 초기 상태다.</p>\n<p><strong>InactivePendingWork</strong>: Recomposer가 비활성 상태이지만 이미 프레임을 기다리는 보류 중인 이펙트가 있을 가능성이 있다. 프레임은 Recomposer가 실행을 시작하자마자 생성된다.</p>\n<p><strong>Idle</strong>: Recomposer가 composition 및 스냅샷 invalidation을 추적하고 있지만 현재 수행할 작업이 없다.</p>\n<p><strong>PendingWork</strong>: Recomposer가 보류 중인 작업에 대해 알림을 받았으며 이미 작업을 수행 중이거나 수행할 기회를 기다리고 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","frontmatter":{"date":"2025.12.07","title":"3장 - Compose 런타임 (The Compose runtime)","categories":"ComposeInternals","author":"Winter","emoji":null},"fields":{"slug":"/composeinternals/3-the-compose-runtime/"}},"site":{"siteMetadata":{"siteUrl":"https://www.winter-love.dev","comments":{"utterances":{"repo":"winter-love-dev/winter-love-dev.github.io"}}}}},"pageContext":{"slug":"/composeinternals/2-the-compose-compiler/","nextSlug":"/composeinternals/1-composable-functions/","prevSlug":"/composeinternals/3-the-compose-runtime/"}},"staticQueryHashes":["1073350324","1321836341","3350743975","339315159","3586530715","988760642"],"slicesMap":{}}
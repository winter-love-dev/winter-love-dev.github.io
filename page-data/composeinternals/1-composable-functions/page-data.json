{"componentChunkName":"component---src-templates-content-template-js","path":"/composeinternals/1-composable-functions/","result":{"data":{"cur":{"id":"dfa35101-0b88-5fbb-b5d4-4848e77e4795","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<h1 id=\"composable-함수의-의미-the-meaning-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%98%EB%AF%B8-the-meaning-of-composable-functions\" aria-label=\"composable 함수의 의미 the meaning of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 의미 (The meaning of Composable functions)</h1>\n<p>Composable 함수는 Jetpack Compose 의 가장 기본적인 요소이며 처음부터 올바른 관념으로 받아들이는 게 좋다.\nComposable 함수를 처음부터 제대로 이해하려면 일반 함수와 다른 관점으로 봐야 한다.</p>\n<p>일반 함수: 반환 값이 결과임. 보통 한 번 실행되면 끝.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">calculate</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> input <span class=\"token operator\">*</span> <span class=\"token number\">2</span></code></pre></div>\n<p>Composable 함수: Node 데이터를 방출해서 컴포지션 하는것이 결과임. 입력 값의 변화에 따라 반복적으로 재실행됨.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>input<span class=\"token operator\">:</span> Input<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Unit</code></pre></div>\n<p>컴포저블 함수의 실행 결과로 생성되는 데이터는 하나의 노드(Node)로 간주되어 방출(Emitting)하는 Action이 실행되고,\n노드는 UI 를 나타내는 Composable 트리(Tree) 구조의 구성 요소로 업데이트 된다.\n이 업데이트 동작은 우리가 컴포즈에서 흔히 접하는 용어인 “컴포지션(Composition)” 이라고 부르는 것이다.</p>\n<p>정리하면 컴포저블 함수를 실행하는 목적은 컴포지션을 통해 트리를 생성 및 업데이트하는 것이다. (컴포지션 유형: Node 를 트리의 구성 요소로 삽입, 제거, 교체, 이동)</p>\n<p>다음은 Side Effect 에 관한 이야기다.\n컴포저블 함수는 Input 값이 바뀔 때마다 몇 번이고 재실행 된다.\n재실행의 부수 효과(Side Effect)로 노드 방출이 일어나며 UI 트리는 항상 최신화 된다.</p>\n<p>우리가 자주 접하는 단어인 Recomposition 도 이 대목에서 다시 이해해볼 수 있다.\n함수에 Input 되는 값이 바뀌었다. 즉 리컴포지션 되었다.</p>\n<p><strong>요약: Composable을 실행한다의 의미: Composition</strong></p>\n<hr>\n<blockquote>\n<p><strong>Compose Runtime:</strong> 실행 중에 UI 트리를 관리하고 최적화하는 시스템.</p>\n</blockquote>\n<h1 id=\"composable-함수의-속성-properties-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%86%8D%EC%84%B1-properties-of-composable-functions\" aria-label=\"composable 함수의 속성 properties of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 속성 (Properties of Composable functions)</h1>\n<p><code class=\"language-text\">@Composable</code> 어노테이션은 단순 마커가 아니라 함수에 특정 제약과 규칙을 부여한다.\n이 제약으로 Compose Runtime 은 코드 실행에 대한 “확실성”을 갖게 되고, 다음과 같은 최적화 기법이 적용된다.</p>\n<ul>\n<li>병렬 Composition: 독립적인 Composable 들을 동시에 실행</li>\n<li>임의 순서 실행: 순서를 바꿔도 결과가 같으면 자유롭게 재배치</li>\n<li>스마트 Recomposition: 변경된 부분만 재실행</li>\n<li>위치 기억법 (Positional Memoization): 이전 결과를 재사용</li>\n</ul>\n<p>핵심: <code class=\"language-text\">@Composable</code> 어노테이션의 의미는 “제약을 주는 대신 최적화를 얻는다”는 것.</p>\n<p>Composable 함수 최적화는 “이 함수는 부수 효과가 없다”, “이 함수들은 서로 독립적이다”\n같은것을 미리 확신할 수 있어야 특정 조건 및 동작을 추론할 수 있다.\n이 확실성으로 다양한 실행 전략(execution strategy) 또는 평가 기법(evaluation techniques)에 따라\n사전에 특정 조건 및 동작을 추론하여 최적화 기법이 적용되는 것이다.</p>\n<hr>\n<blockquote>\n<p><strong>Compose Compiler:</strong> Kotlin 컴파일러 플러그인. Composable 함수를 변환하는 역할.</p>\n</blockquote>\n<blockquote>\n<p><strong>IR:</strong> Intermediate Representation, Kotlin 컴파일러가 소스파일을 해석하는 하나의 과정.</p>\n</blockquote>\n<blockquote>\n<p><strong>Composer:</strong> 런타임중 트리의 형태를 빌드하거나 업데이트하는 객체.</p>\n</blockquote>\n<h1 id=\"호출-컨텍스트-calling-context\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%B6%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-calling-context\" aria-label=\"호출 컨텍스트 calling context permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호출 컨텍스트 (Calling context)</h1>\n<p>Compose Compiler 는 Composable 함수에 엄격한 제약을 하나 부과하는데,\nComposable 함수는 오로지 다른 Composable 함수에서만 호출할 수 있다는 것이다.\n때문에 코루틴처럼 호출 컨텍스트(Calling context)가 필수이다.</p>\n<p>이 제약은 트리가 오직 Composable 함수로 구성되게 보장하게 된다.\n또한 <strong>Composer</strong> 가 트리를 따라 하향 전달될 수 있다는 점 또한 보장된다.</p>\n<p><strong>Compose Compiler</strong> 는 컴파일 타임에 IR 을 가로채어\n우리가 작성한 원본 Composable 함수를 다른 코드로 변환한다.</p>\n<p>원본 소스코드</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n    modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> lastname<span class=\"token punctuation\">,</span> \n      style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>변환된 소스코드</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>\n    name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> \n    $composer<span class=\"token operator\">:</span> Composer<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n  <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>\n    modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">,</span>\n      $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n    <span class=\"token punctuation\">)</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n      text <span class=\"token operator\">=</span> lastname<span class=\"token punctuation\">,</span>\n      style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1<span class=\"token punctuation\">,</span>\n      $composer<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>원본 소스코드에서 변환된 코드를 보면 <strong>Composer</strong> 라는 객체를 주입하는 파라미터가 추가된걸 알 수 있다.\n그리고 내부에 선언된 <code class=\"language-text\">Column</code>, <code class=\"language-text\">Text</code> 에도 <code class=\"language-text\">$composer</code> 라는 객체가 전달되게 코드가 변환 되었는데,\nComposer 라는 객체는 이와 같이 트리 내에서 모든 Composable 로 전달 되도록 변환되고\n이것이 Compose Compiler 가 하는 일 중 하나이다.</p>\n<p>Composer 의 실행 과정을 좀 더 자세히 풀어보면,\nComposable 함수가 실행되면 Node 를 트리로 방출(emitting)한다.\nInput 값이 변경되면 Composable 함수가 재실행된다 (Recomposition)\nCompose Runtime 은 트리를 하향 순회하면서 변경 사항을 확인한다.\n이 때 트리의 형태를 빌드하거나 업데이트 하는 역할이 <strong>Composer</strong> 인 것.</p>\n<hr>\n<blockquote>\n<p><strong>멱등성:</strong> 같은 입력에 대해 항상 같은 결과를 내는 성질.</p>\n</blockquote>\n<h1 id=\"멱등성-idempotent\" style=\"position:relative;\"><a href=\"#%EB%A9%B1%EB%93%B1%EC%84%B1-idempotent\" aria-label=\"멱등성 idempotent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멱등성 (Idempotent)</h1>\n<p>Composable 함수는 반드시 멱등성을 가져야 한다.\n같은 입력값으로 여러번 실행해도 동일한 노드 트리를 생성해야 한다는 뜻이다.</p>\n<p>멱등성이 중요한 이유는 Composable 의 핵심 최적화 기법인 <strong>리컴포지션 스킵(Skip)</strong> 때문이다.</p>\n<p>Composable 함수는 입력값이 바뀌면 재실행(Recomposition) 된다.\n그런데 앱 전체를 매번 다시 그리면 UI 를 그리는 성능상 비효율적이다.</p>\n<p>Compose Runtime 은 트리를 아래로 순회하면서 <strong>입력값이 바뀐 노드만</strong> 다시 실행하고\n<strong>입력값이 안 바뀐 노드는 건너뛴다(Skip)</strong></p>\n<p>멱등성이 보장되면 Compose Runtime 은 다음과 같이 가정할 수 있게된다.\n“같은 입력값이면 같은 결과를 낼 것임”,\n“이미 메모리에 결과가 있으니 다시 실행 안해도 됨”.\n결과: Skip</p>\n<p>이렇게 불필요한 재실행을 생략해서 성능을 최적화 한다.</p>\n<hr>\n<h1 id=\"통제되지-않은-사이드-이펙트-방지-free-of-uncontrolled-side-effects\" style=\"position:relative;\"><a href=\"#%ED%86%B5%EC%A0%9C%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B4%ED%8E%99%ED%8A%B8-%EB%B0%A9%EC%A7%80-free-of-uncontrolled-side-effects\" aria-label=\"통제되지 않은 사이드 이펙트 방지 free of uncontrolled side effects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>통제되지 않은 사이드 이펙트 방지 (Free of uncontrolled side effects)</h1>\n<p>사이드 이펙트 (Side Effect):\n호출되는 함수의 제어를 벗어나서 발생할 수 있는 예상치 못한 모든 동작.\n로컬 캐시에서 데이터 읽기, 네트워크 요청 작업, 전역변수 설정 변경 등 예상치 못한 모든 동작.\n즉 Composable 함수 내부적인 요인에 의해서만 발생하는게 아니라 외부 요인으로 인한 Side Effect 가 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">EventsFeed</span><span class=\"token punctuation\">(</span>networkService<span class=\"token operator\">:</span> EventsNetworkService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> events <span class=\"token operator\">=</span> networkService<span class=\"token punctuation\">.</span><span class=\"token function\">loadAllEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  LazyColumn <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">items</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> event <span class=\"token operator\">-></span>\n      <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드의 문제점: 함수가 호출될 때마다 네트워크 요청이 실행된다는 것이다.</p>\n<p>앞서 언급했듯이 Composable 함수는 Input 값이 바뀌면 재실행된다.\n그런데 재실행이 언제, 몇 번 일어날지는 Compose Runtime 이 결정한다. 우리가 통제할 수 없다.</p>\n<p>예를 들어</p>\n<ul>\n<li>화면 회전하면 재실행</li>\n<li>다른 State 가 바뀌어도 재실행</li>\n<li>심지어 최적화를 위해 멀티 스레드로 병렬 실행 가능</li>\n</ul>\n<p>결과적으로 loadAllEvents() 가 우리 의도와 상관없이 수십 번 호출될 수 있다.\n이게 바로 “통제되지 않은 사이드 이펙트” 문제다.</p>\n<p>Compose Runtime 은 Composable 함수가 <strong>예측 가능하기를(결정론적인)</strong> 기대하는데\n사이드 이펙트가 포함되면 예측이 불가능해진다.</p>\n<p>또 다른 문제: 실행 순서 의존</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">MainScreen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Header</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       \n  <span class=\"token function\">ProfileDetail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">EventList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Header()</code> 가 먼저 실행되고, 그 다음 <code class=\"language-text\">ProfileDetail()</code> 이 실행되겠지? <strong>“NO”</strong></p>\n<p>Compose Compiler 는 이 함수들을 순서를 바꿔서 실행할 수도 있고 동시에 병렬로 실행할 수도 있다.\n따라서 Header 에서 변수 세팅하고, Profile 에서 읽기 같은 로직은 의도대로 작동하지 않는다.</p>\n<p>그럼 어떻게 해야 하나? 우리는 모든 Composable 함수를 stateless 하게 만들수 있게 노력해야 한다.\nComposable 함수는 최대한 “멍청하게” 만들어야 한다.\n모든 필요한 데이터는 파라미터로 받고, 함수 안에서는 받은 데이터로 UI 그리기만 하게 만들자.</p>\n<p>그럼 네트워크 요청은 어디서 하나? Effect Handler 를 사용한다. 추후 챕터에서 다룰거라고 함.</p>\n<p>정리. Composable 함수 안에서 네트워크 요청, DB 접근 같은 걸 직접 하면 안 됨.\n왜? 함수가 언제든 여러 번 실행될 수 있어서.</p>\n<p>해결책: Effect Handler 사용.</p>\n<hr>\n<h1 id=\"재시작-가능-restartable\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EA%B0%80%EB%8A%A5-restartable\" aria-label=\"재시작 가능 restartable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재시작 가능 (Restartable)</h1>\n<p>일반적인 코틀린 함수는 콜스택 (call stack) 상으로 단 한 번만 호출된다.\nComposable 함수는 recomposition 으로 여러번 다시 시작될 수 있다.</p>\n<p>Compose Runtime 은 Tree 를 항상 최신 상태로 유지하기 위해 어떤 노드를 재시작할지 선택적으로 판단한다.\nComposable 함수는 관찰하는 상태(state)에 기반하여 반작용적으로 재실행되게 설계되었다.</p>\n<p>Compose Compiler 는 State 를 읽는 (stateful) Composable 함수를 찾아\nCompose Runtime 에게 재시작 하는 방법을 알려주는 코드를 생성한다.\nstateless 한 함수는 재시작할 필요가 없기 때문에 이런 Composable 함수엔 재시작 하는 방법을 가르쳐주지 않는다고 한다.</p>\n<hr>\n<h1 id=\"빠른-실행-fast-execution\" style=\"position:relative;\"><a href=\"#%EB%B9%A0%EB%A5%B8-%EC%8B%A4%ED%96%89-fast-execution\" aria-label=\"빠른 실행 fast execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빠른 실행 (Fast execution)</h1>\n<p>Composable 함수들은 직접적으로 UI 를 구축하거나 반환하지 않는다.\nComposable 은 단순히 Tree 구조를 구축 및 업데이트 하기위한 데이터(Node) 를 방출할 뿐이다.\n이 매커니즘으로 Composable 은 빠르게 실행될 수 있고 Compose Runtime 이 몇 번이고 실행할 수 있게 해준다.\n이 재실행 과정은 애니메이션의 각 프레임 만큼이나 자주 발생할수도 있다고 한다.</p>\n<p>개발자가 지켜야 할 규칙: Compose Runtime 은 Composable 이 빠르게 실행된다고 가정한다.\n따라서 Network, DB, 메모리 캐싱 등 비용이 큰 작업은 코루틴으로 처리 되어야 한다는 말임.\n해당 작업들은 라이프 사이클에 대응할 수 있는 (lifecycle aware) 이펙트 핸들러에서 처리 되어야 하는데 이 내용은 나중에 다룬다고.</p>\n<hr>\n<blockquote>\n<p><strong>메모이제이션 (Memoization):</strong> 캐싱의 한 유형. 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 줄임.</p>\n</blockquote>\n<blockquote>\n<p><strong>위치 기억법:</strong> 함수 메모이제이션의 한 형태이다.</p>\n</blockquote>\n<h1 id=\"위치-기억법-positional-memoization\" style=\"position:relative;\"><a href=\"#%EC%9C%84%EC%B9%98-%EA%B8%B0%EC%96%B5%EB%B2%95-positional-memoization\" aria-label=\"위치 기억법 positional memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위치 기억법 (Positional memoization)</h1>\n<p>함수 실행 결과를 캐싱해서 같은 입력에 대해 다시 계산하지 않는 기법.</p>\n<p>일반적인 함수의 메모이제이션 방법: 함수의 이름, 타입, 파라미터의 조합으로 고유한 키를 생성하고 다시 실행될 때 이 키를 이용해서 메모이제이션 여부를 판단한다.</p>\n<p>Composable 함수: 위의 일반적인 방법  + 소스 코드 위치(고유 키) 생성.\n하지만 같은 함수여도 호출 위치가 다르면 UI Tree 상 다른 고유 키로 취급된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">MyComposable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 부모 트리\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 1</span>\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 2</span>\n   <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>”Hello”<span class=\"token punctuation\">)</span> <span class=\"token comment\">// id 3</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>같은 <code class=\"language-text\">Text(\"Hello\")</code>지만, 소스 코드 위치가 다르므로 각각 다른 ID를 받는다.\n입력값이 바뀌지 않으면 이 id는 recomposition 시 Skip 될 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">TalksScreen</span><span class=\"token punctuation\">(</span>talks<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Talk<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Column <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>talk <span class=\"token keyword\">in</span> talks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">Talk</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드가 문제인 이유: Compose Runtime 입장에서 함수에 고유 ID 를 할당하기 어려운 케이스임.</p>\n<p>처음엔 <code class=\"language-text\">Talk</code> 가 생성된만큼 ID 가 생성되어 각각의 <code class=\"language-text\">Talk</code> item 을 구분할 수 있긴 하다.\nList 순서상 맨 끝에 새로운 item 이 추가 되어도 모든 item 은 각자의 고유한 ID 를 잘 유지할 수 있다.</p>\n<p>문제는 List 순서상 중간의 아이템이 추가되거나 삭제 된다면?\n해당 위치 이후의 item 들은 Composable 의 위치가 바뀌며 각자의 고유 ID 를 잃게되고 결과적으로 전부 recomposition 된다.</p>\n<p>업데이트가 생략 되었어야 할 Composable 함수들이 전부 recomposition 을 하게 되었으니 리스트가 길면 길수록 비효율적이게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">TalksScreen</span><span class=\"token punctuation\">(</span>talks<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Talk<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Column <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>talk <span class=\"token keyword\">in</span> talks<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">key</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> Unique key 추가\n        <span class=\"token function\">Talk</span><span class=\"token punctuation\">(</span>talk<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 방법처럼 Key 로 Composable 각자에 고유한 ID 를 직접 부여해서 트리 내 각자의 위치를 유지하게 할 수 있다.\n위에 말한 비효율 문제를 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">FilteredImage</span><span class=\"token punctuation\">(</span>path<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">val</span> filters <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span> <span class=\"token function\">computeFilters</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">ImageWithFiltersApplied</span><span class=\"token punctuation\">(</span>filters<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">ImageWithFiltersApplied</span><span class=\"token punctuation\">(</span>filters<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Filter<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">remember</code> 는 <code class=\"language-text\">computeFilters(path)</code> 를 실행하고 결과 저장, path 가 바뀌지 않으면 <code class=\"language-text\">remember</code> 에 저장된 값을 재사용.\n해당 방법으로 recomposition Skip.</p>\n<p>핵심: Composable 은 호출 위치로 고유 ID 를 가짐.\n입력값의 변화가 없다면 해당 위치의 Composable 은 recomposition 을 Skip 한다.\n반복문에서는 <code class=\"language-text\">Key()</code> 로 명시적인 ID 지정 필요.\n함수 내부의 계산 결과를 캐싱하려면 <code class=\"language-text\">remember</code> 함수를 사용하자.</p>\n<hr>\n<h1 id=\"suspend-함수와의-유사성-similarities-with-suspend-functions\" style=\"position:relative;\"><a href=\"#suspend-%ED%95%A8%EC%88%98%EC%99%80%EC%9D%98-%EC%9C%A0%EC%82%AC%EC%84%B1-similarities-with-suspend-functions\" aria-label=\"suspend 함수와의 유사성 similarities with suspend functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Suspend 함수와의 유사성 (Similarities with suspend functions)</h1>\n<p>suspend 와 Compose 함수는 비슷한 제약을 가진다.</p>\n<p><strong>Coroutine:</strong> suspend 함수는 다른 suspend 함수에서 호출될 수 있다. <br/>\n<strong>Compose:</strong> Composable 함수는 다른 Composable 함수에서 호출될 수 있다.</p>\n<p>때문에 이 둘은 호출 컨텍스트가 필요하다.\n이 제약으로 suspend 는 suspend 끼리, Composable 역시 Composable 끼리 묶일 수 있게 보장해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// Coroutine 함수 변환 전</span>\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">publishTweet</span><span class=\"token punctuation\">(</span>tweet<span class=\"token operator\">:</span> Tweet<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Post <span class=\"token operator\">=</span> <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n\n<span class=\"token comment\">// Coroutine 함수 변환 후</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">publishTweet</span><span class=\"token punctuation\">(</span>\n    tweet<span class=\"token operator\">:</span> Tweet<span class=\"token punctuation\">,</span> \n    callback<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>Post<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">-</span> 추가\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Unit</code></pre></div>\n<p>둘 다 암시적인 파라미터를 추가한다는 점에서 유사하다.</p>\n<p>핵심 차이점: <br/>\n<strong>Continuation:</strong> Kotlin Runtime 으로부터 다양한 중단점에서 실행을 중단, 재개에 대한 정보를 담고 있는 객체. 본질적으론 일반 함수와 똑같이 한 번 실행되면 끝이다. <br/>\n<strong>Composer:</strong> Compose Runtime 으로부터 여러번 실행되는 이벤트에 반응하며 항상 UI Tree 를 최신 상태로 유지하게 만들기 위한 객체.</p>\n<p>“한 번 실행하고 중단, 재개 / 상태 변화에 반응해서 계속 재실행”</p>\n<p>유사하긴 하지만 완전히 다른 문제를 해결하니 각자의 매커니즘이 필요하다.</p>\n<hr>\n<h1 id=\"composable-함수의-색깔-the-color-of-composable-functions\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%83%89%EA%B9%94-the-color-of-composable-functions\" aria-label=\"composable 함수의 색깔 the color of composable functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수의 색깔 (The color of Composable functions)</h1>\n<p>서로 다른 종류의 함수는 잘 섞이지 않는다는 이야기다.</p>\n<p>동기 함수에서 비동기 함수를 직접 호출할 수 없고, 일반 함수에서 suspend 함수를 직접 호출할 수 없듯이.\n그리고 일반 함수에서 Composable 함수를 직접 호출할 수 없듯이.</p>\n<p>이렇게 함수들이 서로 다른 “색깔”을 가진 것처럼 분리되어 있다고 해서 함수 컬러링이라고 부른다.</p>\n<p>Composable 함수는 다른 Composable 함수에서만 호출 가능하다. 일반 함수와 섞으려면 통합점이 필요하다 (예: <code class=\"language-text\">setContent</code>)</p>\n<p>왜 이런 제약이 있을까? Composable 함수는 일반 함수와 완전히 다른 목적을 가지기 때문.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">SpeakerList</span><span class=\"token punctuation\">(</span>speakers<span class=\"token operator\">:</span> List<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Column <span class=\"token punctuation\">{</span>\n        speakers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 일반 함수인데?</span>\n            <span class=\"token function\">Speaker</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Composable 호출 가능</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">forEach</code>는 일반 함수인데 어떻게 안에서 Composable을 호출할 수 있을까? <strong>inline</strong> 때문이라고 한다. <code class=\"language-text\">forEach</code> 같은 컬렉션 연산자는 inline 으로 선언되어 있다.\ninline 함수는 호출 시점에 코드가 그대로 복사되어 들어간다. 결국 <code class=\"language-text\">Speaker(it)</code>는 <code class=\"language-text\">SpeakerList</code> 본문 안에서 호출되는 것과 같다. 둘 다 Composable이니까 문제없다.\ninline 덕분에 함수 컬러링 문제를 우회하고 자연스러운 코드를 작성할 수 있다.</p>\n<p>함수 컬러링은 문제일까? 오히려 장점이라고 한다. 컴파일러와 런타임이 “colored 함수”를 특별하게 처리할 수 있기 때문이다.</p>\n<p>suspend 함수는 비동기 non-blocking 프로그래밍을 가능하게 한다.\nComposable 함수는 재시작 가능(Restartable), 생략 가능(Skippable), 반응형(Reactive)이다.\n일반 함수에는 없는 이런 특별한 기능을 얻는 대가로 “색깔”이라는 제약이 생긴 것이다.</p>\n<hr>\n<h1 id=\"composable-함수-타입-composable-function-types\" style=\"position:relative;\"><a href=\"#composable-%ED%95%A8%EC%88%98-%ED%83%80%EC%9E%85-composable-function-types\" aria-label=\"composable 함수 타입 composable function types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable 함수 타입 (Composable function types)</h1>\n<p><code class=\"language-text\">@Composable</code> 어노테이션은 함수의 타입 자체를 변경한다.</p>\n<p>일반 함수 타입: <code class=\"language-text\">(T) -> A</code> <br/>\nComposable 함수 타입: <code class=\"language-text\">@Composable (T) -> A</code></p>\n<p><code class=\"language-text\">@Composable</code>이 타입의 일부가 된다는 뜻이다.</p>\n<p>Composable 람다: 일반 람다를 선언하듯이 Composable 람다도 선언할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\">// Composable 람다를 프로퍼티로 저장</span>\n<span class=\"token keyword\">val</span> textComposable<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>\n        text <span class=\"token operator\">=</span> it<span class=\"token punctuation\">,</span>\n        style <span class=\"token operator\">=</span> MaterialTheme<span class=\"token punctuation\">.</span>typography<span class=\"token punctuation\">.</span>subtitle1\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">NamePlate</span><span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> lastname<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Column</span><span class=\"token punctuation\">(</span>modifier <span class=\"token operator\">=</span> Modifier<span class=\"token punctuation\">.</span><span class=\"token function\">padding</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">.</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span>text <span class=\"token operator\">=</span> name<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">textComposable</span><span class=\"token punctuation\">(</span>lastname<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 저장한 람다 사용</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 Composable 람다를 재사용할 수 있다.</p>\n<p>Scope가 있는 Composable 타입: 특정 Composable 안에서만 사용 가능하도록 범위를 제한할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">Box</span><span class=\"token punctuation\">(</span>\n    content<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@Composable</span> BoxScope<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit  <span class=\"token comment\">// BoxScope 안에서만</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Layout</span><span class=\"token punctuation\">(</span>\n        content <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> BoxScopeInstance<span class=\"token punctuation\">.</span><span class=\"token function\">content</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">BoxScope.() -> Unit</code>은 Box 안에서만 호출 가능한 람다를 의미한다.\n이 덕분에 특정 Composable 내부에서만 쓸 수 있는 함수를 만들 수 있다.</p>\n<p>왜 타입이 중요한가? 타입이 다르면 컴파일러가 다르게 처리할 수 있다.</p>\n<p><code class=\"language-text\">@Composable</code> 타입 덕분에 컴파일 시점에 잘못된 호출 검증 가능 (일반 함수에서 Composable 호출 시 에러),\n런타임이 Composable 함수를 특별하게 처리 가능 (재시작, Skip 등),\n타입 시스템으로 제약을 강제할 수 있음.</p>\n<p>Composable 함수가 일반 함수와 완전히 다른 타입인 이유다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","excerpt":"Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 (관련글) 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도. Composable 함수의 의미 (The meaning of Composable functions) Composable 함수는 Jetpack Compose 의 가장 기본적인 요소이며 처음부터 올바른 관념으로 받아들이는 게 좋다.\nComposable 함수를 처음부터 제대로 이해하려면 일반 함수와 다른 관점으로 봐야 한다. 일반 함수: 반환 값이 결과임. 보통 한 번 실행되면 끝. Composable 함수: Node 데이터를 방출해서 컴포지션 하는것이 결과임. 입력 값의 변화에 따라 반복적으로 재실행됨. 컴포저블 함수의 실행 결과로 생성되는 데이터는 하나의 노드(Node)로 …","frontmatter":{"date":"2025.11.14","title":"1장 - Composable 함수들 (Composable functions) 내맘대로 정리","categories":"ComposeInternals","author":"Winter","emoji":null,"thumbnail":{"publicURL":"/static/5314d2a18f59617ee9c2723cac41e942/cover.png"},"articleDescription":null,"articleKeywords":null,"articleModifiedDate":null},"fields":{"slug":"/composeinternals/1-composable-functions/"}},"next":{"id":"b5d12a89-cf43-5050-b2fe-6a15c193a8c8","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC30lEQVR42l2SbWhbZRzFL66OIRtaWytsQh3bWIfUzo254Yc5ymo77Qb7sBfmPghaLQNH3VwZ2wdXRQXBMrFaZbPFdTDa4kiTVhmBzKW1TdKb2+am6ftrmtybt6YmvZukTfLbTSiFeuBwHh54zv8cnr+wOfcFcvPzeGnLi+SXFpH/11kKTGfIM57i5c6zWc1wa+c5nrlfQe3DRp4MxfEPqqg6g3IQr+jD51Tw9asIz+VsouX3FjweN9KICyk0jhQcX9Ux3NFphuNzTGsqtUO3+cluIC4vorhU/AMqbssIgYEwihjAa1cQNl7Zz98TTkguE9aiRJfiJP5LkEyssKIzlUqRQTqdzqqmavhFP0H3An/eaqe+5nOavvkZr03B26cbbnhwAkvYRerxMqGFCDNzsygBhXAkzKx+DoXDZKySq8ZxdYl5UWHOGURu62S2/S7fVn2IaJLxO0IIz7a/y6OQC+c/DiwPLRgMBrq6urDZbHR0dCBJ0rqEMUVjVq82LwaJWgexf/cl3Q0/6ulUpqxevfIflVgjbtziIIYOA2azGbvdjsViyRpHIpFVQ7JJF/1xlP4gi8NP8Bh7MNZ+xL26G8z0hvD3hRGEtqM8isi4HBK/NTdhMplwOBz6J3mQZXktWWpVl/waI+Zx6i7UUfXe+zRfqeX4/rc4X/kBPa0iwjvWqwwsThENLTA6MYZ33kssFluruZJKkkynsukCiSihQIxfbjRStu8IJ98+Qdmb5dRUfUbZwaMcfv0IwkWpgYkl37oU/0fGMIPy7mt8MXSHdDzBv/pQTdOy920trRRve40924oQqqUfMI13I4666BuT6B1xMqxMMvlYxaPv36g+TI7NcMn1q77Yx/jUehNlbI6pyWlUn0osGuPr619RuOUVSgqLET6211Nl+34dP7HV86rxPDltx8hpraDAcJpS82UEYwXbq0spfn4Xe/XHpcWHObTzALsLdrAjr5A3tpfwFNUhsQbUHv0pAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5d66eb67a58c667e3cf8cca5dc7248de/37523/cover.png\"\n        srcset=\"/static/5d66eb67a58c667e3cf8cca5dc7248de/e9ff0/cover.png 180w,\n/static/5d66eb67a58c667e3cf8cca5dc7248de/f21e7/cover.png 360w,\n/static/5d66eb67a58c667e3cf8cca5dc7248de/37523/cover.png 720w,\n/static/5d66eb67a58c667e3cf8cca5dc7248de/302a4/cover.png 1080w,\n/static/5d66eb67a58c667e3cf8cca5dc7248de/29c1d/cover.png 1375w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>발표자료: <a href=\"https://speakerdeck.com/winterlovedev/android-modularization-experience\">speakerdeck.com/android-modularization-experience</a></em></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 655px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAADL0lEQVR42g3R/1PTBQDG8d31g3f91F131Q/VZZeVfYPMw8BCBYEgFZgDrCaQMA/P23KwyWDSgAEbskjGGhhISgi0wUUHwRTcmNCEcTcXiMiXG4wUJgIX3Zn207vPP/B6nuceUa0snKiwRMQHJWSm5qLMVqHOVuMw6flrtJvgSA8PLZ8Raj3NoqeXJ/euEhyw0qrV03quHH2Oii5dHk/6xcTuegdRXPhuEiIPCWAGhdlKLmkrsBaU8s9kJ8w1UW+QUZH+ArW5r3A4fiezQ7Vw34HHbGSj28B8ZzV23RnGa8RIY8IQJX4YQdInyXyZJCU/8wxGRRm1+dWMt1h4/PMpzKf2cD72VerE29n7mghV/NtseVvw1JlY66mB2WY23VXkpUg5nRKJaLjyUyQHxOQezUUuzaej1Eh7uZle0/esdRSx2PgVfk08g/K9XFfuoSAunNEmAyPmRgJtVeAzEeorQZGeRnT4+4jW7dFkJaYjSZBRnqdmq7eeZXsz03oZf1/+giVdJqOyd/HKd9N+5E0kO55B83EYt6+Y+dd7FcZMTP2QTajnOGVZEYiKJJEkRx+hryaHXkM+wQ4h0XaZAel+NhrTeXpSy6O0PFYOZeKKSeHwjucwxUSx3CXMXbnGxu/f4aqSCHAuV9TRiH6UZ1CvVvKfv441VwNLDjvLTRp+ORHLepOYp4VlPD6q4L4AtiV8TurOl7iYEUV/6Qk2x2yEOrX8VnKMS2opsgSh4UyHBY/dxp2hQeZuulnyT+Fr1jBoLeeh9QCrRfvYeise58sfkbV9G8qDHzBwXoHdoBEed7I6+iu+zga6q8tpUMsR3bTZ8F67zm2nixnPGAGfj0eBBdYCD1hxNDCpfZ0bsjeo3P8iiqjncf5kYT0QZHVyisXxMeZG3Hi7OhlqvEBraTEiT38//uFh7t66xbyABafu8GBmmtWFeTbv+ZnQxVGZFsGNb1Mwpr7Hn8KKhT/cjNja6LtYR4tOjTHvOKpjyXydFCeAjgF87mFmJiaY9wvgtADO3iW0FGTZ2c6FmGc5uS8MV0kyZ3dtoyJHTMO5s1j0aqxlWkzFKoyaAqqLC9Epv+F/R2tMfcmcqEMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/22452ca59949d9d68f78fb1d842de811/ae6b7/0.png\"\n        srcset=\"/static/22452ca59949d9d68f78fb1d842de811/e9ff0/0.png 180w,\n/static/22452ca59949d9d68f78fb1d842de811/f21e7/0.png 360w,\n/static/22452ca59949d9d68f78fb1d842de811/ae6b7/0.png 655w\"\n        sizes=\"(max-width: 655px) 100vw, 655px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>행사 정보: <a href=\"https://event-us.kr/gdgandroid/event/99825\">https://event-us.kr/gdgandroid/event/99825</a></em></p>\n<blockquote>\n<p>자식 클래스가 생성되기 위해서는 부모 클래스의 생성자를 먼저 호출합니다.</p>\n<p>이 행사는 시니어가 되기 위해 주니어들이 super.init 하는 행사입니다.</p>\n<p>어떠한 기준으로 주니어/시니어를 나눌 수 없지만 오늘의 나보다 더 발전하기를 원하고 내일의 내가 더 나은 개발자가 될 수 있도록 그러한 배움을 더 바라는 분들을 위해 행사를 준비했습니다.</p>\n</blockquote>\n<h1 id=\"개요---발표자-지원하기\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94---%EB%B0%9C%ED%91%9C%EC%9E%90-%EC%A7%80%EC%9B%90%ED%95%98%EA%B8%B0\" aria-label=\"개요   발표자 지원하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요 - 발표자 지원하기</h1>\n<p>2025년 3월 15일. GDG Korea Android 팀이 주관하는 행사 super.init(version=6)의 발표 연사자가 되었습니다.</p>\n<p>안드로이드 주니어 개발자들에게 발표 기회를 주고, 주니어 청중들을 대상으로 기술이나 경험을 주제로 발표를 하는 행사입니다.</p>\n<p>저는 4년차 안드로이드 개발자고, 이런 공개적인 행사의 청중으로만 참여했을 뿐 발표한 경험은 없었습니다. 이번 행사에선 저도 발표자로 첫 발을 내딛고, 주니어와 중니어의 경계에 있는 연차로서 마지막 super.init 발표 참여 기회라고 생각했습니다.</p>\n<p>발표자 모집 기간에 떨리는 마음으로 지원했고, 큰 기대는 안 했었는데 운이 좋게도 발표자로 선정되어 이렇게 후기를 작성하고 있네요. 좋은 기회를 주신 GDG Korea Android 팀에 감사의 인사를 전합니다. 🥰</p>\n<h1 id=\"발표-주제-선정하기\" style=\"position:relative;\"><a href=\"#%EB%B0%9C%ED%91%9C-%EC%A3%BC%EC%A0%9C-%EC%84%A0%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"발표 주제 선정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>발표 주제 선정하기</h1>\n<ul>\n<li>팀원들을 설득하는 방법</li>\n<li>모듈화 경험</li>\n</ul>\n<p>저의 관심사를 몇 가지 리스트업 했고, 현실적으로 많은 이야기를 할 수 있는 발표 주제로서는 모듈화 경험만한게 없었습니다.</p>\n<p>발표 제목은 청중들의 흥미를 자극할 수 있는게 뭐가 있을까 고민했고, 정말 마음에 드는 제목이 딱 떠올랐습니다. 🤭</p>\n<p><strong>“10년 개발한 프로젝트. 애자일 업무 조직에서 모듈화 했던 경험을 공유합니다”</strong></p>\n<h1 id=\"발표-준비하기\" style=\"position:relative;\"><a href=\"#%EB%B0%9C%ED%91%9C-%EC%A4%80%EB%B9%84%ED%95%98%EA%B8%B0\" aria-label=\"발표 준비하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>발표 준비하기</h1>\n<ol>\n<li>발표 대본 글쓰기</li>\n<li>PPT 만들기</li>\n</ol>\n<p>발표 자료를 만드는 프로세스는 이렇게 두 단계였는데, 글을 쓰는데 정말 많은 시간을 투자했습니다 (2주 정도). 아무래도 회사 일정과 병행 하다보니 준비가 쉽지는 않았습니다.</p>\n<p>여차 저차 아쉬움이 남지 않게 발표 자료를 열심히 만들었습니다.</p>\n<p>발표자료: <a href=\"https://speakerdeck.com/winterlovedev/android-modularization-experience\">speakerdeck.com/android-modularization-experience</a></p>\n<p>2주 동안 열심히 작성한 대본과 PPT 자료를 조합해서 며칠 동안은 방이 쩌렁 쩌렁 울리게 대본을 읽고, 발표 제한시간 20분이 넘지 않게 첨삭하는 시간을 보냈습니다. 방에서 대본을 읽는것도 처음엔 많이 떨려서 익숙해지는데도 시간이 며칠 필요했습니다. 🤢</p>\n<h1 id=\"행사장-모습\" style=\"position:relative;\"><a href=\"#%ED%96%89%EC%82%AC%EC%9E%A5-%EB%AA%A8%EC%8A%B5\" aria-label=\"행사장 모습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>행사장 모습</h1>\n<p>행사 장소는 선릉역에 있는 “배민테크살롱” 입니다. 평소엔 학생들이 개발 공부를 하는 캠퍼스로 사용되는 공간이라고 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAAES0lEQVR42h2TW1OTVxSGv9tOb9ppe+Fx9MJWrdpWschIPEQqgqAcNFBFEAEFFFETRQ4thGOiEhIEIgRJnBDOCQmBmEBiTEggQIGqpZ0e/svTLRdr9p75vvXMftf7LunS6X08ykvk1+LTm1VfLKf2xinuXzlG4YXDlGQcJT/1O+RHdpIUtxPF6T0Uph3kXm4cdYWJNJedpa0ildY7KbQ9yEIyNRZjrL/BQOtNrE9vYWzI54kyk/o7F9DW3cLU8ZgXusc8bbrPsxYlffparEY1tp5fGOys4qnqMvUlclorUtAqs5H6G/LQVqbTVJbMk7uptNxOpjTzB5pV11hfcLMSnWI54mI56iIWniQ27xT3KaJvJlgMuenRKLmbk8DDgpO0VGYg9dbl0qHKpFWA2srPUlMoI1O2i6LsRDyjnbhHDbiGdDgGnzFp1WG3tmO3GbAPGpgc7sbnekXAM4xnwkSvphLJWKOgQ3mRxptnUJecQnU1ngsJ28lJ/p7pkQ5mxp/jHuvCPd6Na8TA1PBzPI4+3PZefFOvGHulo0mo6WuvJjw7gdRVlY1eANUlwpCiEwL4I1myHaTL9uAc1DItgJOmWtyWRpxWDa8dL/C4TMzYTXhdFioLkrkkFJVnx2HRVyN1PsxCr8oQQPkmsCr/GLny3ZyL34HDqsXRXUm5/CsqZJ+QdzYOl02P1/1SlJmZyZeUXJaRe+YblNdOYGwuQ/oI04kZNpUmCehJqq8ncC15D2cOb2HUpMbekEpjymc8SvyU81sl1LevEg3b8XttQrKF6xfjyRHA6iI5/doKJJ0yg3ZVljDl3CawtvA4xen7Re62MNBSiq34EOaMbXSnbaUu/ksKEvYyNdRJVLj9enKAgvQ48s4dQF2ewmCXkKx/dIkOIVtz97wwRoS7SEZ51iER4q0YHv+M7fYx7Il7Gf52F8q921Ec2slg6wPWVmeFSd0okvaRm/Q1GpHBWUcvUk9NDl3VCtrFS5tLhdMCWplzhFMHPsfQdp+ARYU9eRvGXV+Qv387LWUKXANPRBbdwtVxeg31aGpvMTNmZG3BI4LdWEifyGK3gGrE+jQLYIXiKGmyfXQ/qyLmM2O8cpAa4Xx15nEiQfum3I+n12nB47QSCjiJhWaIBWeQvGIeI0J7f+N1EeyfUJeloW+8h6FVxYhZS2S6nwH1HawNRfRW5RMJuYgExom8sTNs1mHQ1jA0oMc12k94zoUUFk5FvUOEpsw4XmrwTpiJioBOj/bgEzN567GwFHawGBSQwOgm7K1vmNDsmKgJgq/HiQZc4h+PkOxHer/gYz08zcZSgL9Ww7yP+Vmb9xALOFh662BF7O+8z0bUP0LEP8r83BgLQSersTnWYwGx73N8WA7yx4roXQoh/ftugf8+LLKxEmQt4t2s9aiPP1dD/PNhgb/fzYsGP6sRj2ieZeO3EBtrYdYF5PelN7z7CF30i28B3i+H+R/4PDmZIt2isQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"\"\n        src=\"/static/88865d2a24771accd6f5931c4a9f4171/6af66/1.png\"\n        srcset=\"/static/88865d2a24771accd6f5931c4a9f4171/e9ff0/1.png 180w,\n/static/88865d2a24771accd6f5931c4a9f4171/f21e7/1.png 360w,\n/static/88865d2a24771accd6f5931c4a9f4171/6af66/1.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>행사장 입구에서 귀여운 머그컵을 나눠주고 있었습니다</em></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAC/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAARzhUKer/8QAGxAAAQQDAAAAAAAAAAAAAAAAAAEREyECEiL/2gAIAQEAAQUCj1WK2OhsSj//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAAAARARMQL/2gAIAQEABj8CVM1RT6jD/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFBYf/aAAgBAQABPyHSDuJ5Meta7E3VmZB6FRRuofKf/9oADAMBAAIAAwAAABBMz//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/EKr/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8Qmo//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhYUFxoTH/2gAIAQEAAT8QUNrsilbiWGlJ4t5ety4oCRx8fe4+6i5D0g95BWmUlFRqf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2\"\n        title=\"\"\n        src=\"/static/a0d989084e83c7386395cb9a686111d7/80e3c/2.jpg\"\n        srcset=\"/static/a0d989084e83c7386395cb9a686111d7/4ec73/2.jpg 180w,\n/static/a0d989084e83c7386395cb9a686111d7/158ba/2.jpg 360w,\n/static/a0d989084e83c7386395cb9a686111d7/80e3c/2.jpg 720w,\n/static/a0d989084e83c7386395cb9a686111d7/47311/2.jpg 1080w,\n/static/a0d989084e83c7386395cb9a686111d7/d165a/2.jpg 1400w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>행사장 모습</em></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQD/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAYa4U6MQf//EABkQAAIDAQAAAAAAAAAAAAAAAAECAAMSEf/aAAgBAQABBQJAjQ5rU2J3WXNnQWE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAwADAQAAAAAAAAAAAAAAAAERITJBEv/aAAgBAQAGPwKNP0zU0FiPpJ0Uwf/EABsQAQADAQADAAAAAAAAAAAAAAEAESExQYGh/9oACAEBAAE/IahHokF0vtX1ifL7liFH6iIxtmKwMbk//9oADAMBAAIAAwAAABAT/wD/xAAYEQEAAwEAAAAAAAAAAAAAAAABEBEhMf/aAAgBAwEBPxASt7H/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAgMAAwEAAAAAAAAAAAABABEhMVFBYXGx/9oACAEBAAE/EGGIyAL9ErkAGks7kqNF+zT8l3FUpVW5zE3sgXl3UNXho2ez/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"3\"\n        title=\"\"\n        src=\"/static/6058109b41027388172cd9add784a4c8/80e3c/3.jpg\"\n        srcset=\"/static/6058109b41027388172cd9add784a4c8/4ec73/3.jpg 180w,\n/static/6058109b41027388172cd9add784a4c8/158ba/3.jpg 360w,\n/static/6058109b41027388172cd9add784a4c8/80e3c/3.jpg 720w,\n/static/6058109b41027388172cd9add784a4c8/47311/3.jpg 1080w,\n/static/6058109b41027388172cd9add784a4c8/d165a/3.jpg 1400w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>행사장 모습2</em></p>\n<p>100명이 넘는 안드로이드 개발자 청중들이 모였습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 133.33333333333331%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAECBAUDBv/EABYBAQEBAAAAAAAAAAAAAAAAAAADAf/aAAwDAQACEAMQAAABzXNkTmHo62daxMRC3//EABwQAAICAgMAAAAAAAAAAAAAAAECAAMQEhETQf/aAAgBAQABBQLOrwLzN4rpcOkVNosqJBZi08//xAAVEQEBAAAAAAAAAAAAAAAAAAAQAv/aAAgBAwEBPwEk/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAIQIWH/2gAIAQIBAT8BhsLP/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAEQESExMv/aAAgBAQAGPwKXapKaaM4eUWa4/8QAHRAAAwEAAgMBAAAAAAAAAAAAAAERITFBUWGhsf/aAAgBAQABPyEhB2flVfY5Fmvgz18GVf2mRW/krybv8SZOMTS2CxEf/9oADAMBAAIAAwAAABDDK7//xAAZEQEAAgMAAAAAAAAAAAAAAAABABEQMVH/2gAIAQMBAT8QrCvcA5P/xAAYEQEBAQEBAAAAAAAAAAAAAAABABEhMf/aAAgBAgEBPxAduwSLr2//xAAfEAEAAgICAgMAAAAAAAAAAAABABEhMUFRYbFxofD/2gAIAQEAAT8QouAgKm5iUsdA8yrrK7cG7+oHBPxwj2OL9oYhg2Ro+n6pajcquO5clZslzgudceJiF0AE/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4\"\n        title=\"\"\n        src=\"/static/45f162ea3418616b080f84262e32c116/80e3c/4.jpg\"\n        srcset=\"/static/45f162ea3418616b080f84262e32c116/4ec73/4.jpg 180w,\n/static/45f162ea3418616b080f84262e32c116/158ba/4.jpg 360w,\n/static/45f162ea3418616b080f84262e32c116/80e3c/4.jpg 720w,\n/static/45f162ea3418616b080f84262e32c116/9ecec/4.jpg 1050w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<em>제가 발표하는 모습입니다 ✌️</em></p>\n<h1 id=\"간단한-발표-내용-공유\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%B0%9C%ED%91%9C-%EB%82%B4%EC%9A%A9-%EA%B3%B5%EC%9C%A0\" aria-label=\"간단한 발표 내용 공유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 발표 내용 공유</h1>\n<p>저는 모빌리티 서비스 TADA 팀에서 일하고 있습니다. 우리가 익숙하게 알고있는 한국의 TADA 가 아니라, 해외에도 똑같은 이름의 TADA 서비스를 운영하는 회사가 있는데요. 저는 이 해외 서비스 개발팀 입니다. 전혀 다른 회사고 우리가 먼저 출시 했다고 합니다. (매우 중요 😤)</p>\n<p>이 프로젝트는 10년 간 개발 되었습니다. 10년 전의 개발 방식부터 현대 방식과 아키텍처 적용에 이르기까지 <strong>“다양한 개발 방법론”</strong> 과 <strong>“아키텍처”</strong> 와 <strong>“각 출시 국가별 구현이 쌓여온”</strong> 프로젝트였습니다.</p>\n<p>열정있는 우리 팀원 분들이 아키텍처를 현대화 하고 코드 퀄리티를 개선하기 위해 꾸준히 노력해왔지만 이미 과거부터 너무나 강력하게 결합되고, 거대해진 코드베이스의 확장성, 가독성, 코드 품질을 개선하는 것은 쉽지 않은 일이었습니다.</p>\n<p>우리팀은 효율적인 개발 환경으로 개선하기 위해 오랜 시간 고민해왔는데요. 그 해결책으로 모듈화 도입을 오랫동안 검토하고 있었습니다.</p>\n<p>마침 우리는 모듈화를 진행하게 되는 <a href=\"https://speakerdeck.com/winterlovedev/android-modularization-experience?slide=6\">어떠한 계기를 맞이하게 되었고</a> 이후로 우당탕탕 모듈화를 했던 과정와 경험담을 공유하는 발표입니다. 🤗</p>\n<p>모듈화에 관한 경험담과 방법을 언젠가 블로그 아티클로 다루려 합니다.</p>\n<h1 id=\"후기\" style=\"position:relative;\"><a href=\"#%ED%9B%84%EA%B8%B0\" aria-label=\"후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>후기</h1>\n<p>자료 준비부터 현장 발표까지 한 순간도 아쉬움이 남지 않게 열심히 준비해서 다 쏟아내고(?) 왔습니다.</p>\n<p>발표 당시엔 너무 떨렸습니다. 🤢 끝나고 나서는 후련하고 뿌듯했습니다. 🤟 좋은 기회를 주신 GDG Korea Android 팀에 다시 한 번 감사의 인사를 전합니다. 🥰</p>\n<p>제 발표를 보러 먼 길 와주신 친구들, 회사 동료에게도 감사의 인사를 전합니다. 🥰</p>\n<p>링크드인으로만 뵈었던 분들이 저에게 먼저 다가와서 인사도 해주셨는데, 정말 반가웠습니다. 🤝</p>\n<p>저의 <a href=\"https://winter-love.dev/android/research-lint-library/\">Lint 적용 블로그 아티클</a> 을 보고 Lint 작업을 하셨다는 분도 있었습니다. 😱 충격과 뿌듯함, 감사함이 몰려왔습니다…! Lint 후속 글 쓰기로 했는데… 빨리 써야겠습니다.</p>\n<p>행사장의 사람들과 이야기 하면서 여러가지 인사이트를 얻었고, 그 과정에서 저에게 당장 필요한, 부족한 부분들을 찾을수 있었습니다. 좋은 고민 주제를 몇 가지 얻을수 있었습니다.</p>\n<p>감사합니다.</p>","frontmatter":{"date":"2025.03.16","title":"GDG Korea Android 개발자 행사의 스피커가 되었습니다. super.init(version=6) 후기","categories":"Life","author":"Winter","emoji":"📣"},"fields":{"slug":"/life/super-init-v6-review/"}},"prev":{"id":"d9b8b773-3000-5ecd-83f2-9993680a657e","html":"<p>Jetpack Compose Internals 를 읽고 정리하는 글이다.\n어쩌다보니 올해 안에 완독 하겠다는 목표를 세워서 <a href=\"https://winter-love.dev/insights/compose-internals\">(관련글)</a> 열심히 읽는중이다.\n이 글의 수준을 다음과 같이 설정했다.\n대학생이나 현업 개발자 등 컴포즈를 평소보다 좀 더 깊이 있게 파고들고 싶은 자가 받아들일 수 있을 정도로 쉬운 난이도.</p>\n<hr>\n<p>참고. compose architecture</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.555555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAArklEQVR42mNgAIL///8zAjETCDNAAYyPJMaIIQbUx1APZIMwiA0DB14dm7bn8eEHe54efrz37dHITWmbuE6fOX3l6NGjN0+dOnXvzJkzFidPnrQEsu8DxW6dOX/hwv8rWTx6i7/nOqz9+9Rl/d+7Zst/r4QbuO/F0Wk77u57sPP+PoiB9UADT5++cvDgwZvHjx+HG3jixIn7hw4dunXqzNkL/18iDHTdgGYgNb0MAMdIqi4GQCyQAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"0\"\n        title=\"\"\n        src=\"/static/7970e338a20dbbf6b503a293a6823b5f/37523/0.png\"\n        srcset=\"/static/7970e338a20dbbf6b503a293a6823b5f/e9ff0/0.png 180w,\n/static/7970e338a20dbbf6b503a293a6823b5f/f21e7/0.png 360w,\n/static/7970e338a20dbbf6b503a293a6823b5f/37523/0.png 720w,\n/static/7970e338a20dbbf6b503a293a6823b5f/302a4/0.png 1080w,\n/static/7970e338a20dbbf6b503a293a6823b5f/07a9c/0.png 1440w,\n/static/7970e338a20dbbf6b503a293a6823b5f/58e49/0.png 4296w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>이 챕터를 읽기전에…\nCompose Compiler가 어떻게 동작하는지 내 기준 꽤 깊이 있게 살펴본다. 크게 세 부분으로 나뉜다.</p>\n<p><strong>Compose 어노테이션들</strong>  @Composable부터 @Stable, @Immutable까지 각 어노테이션이 무엇을 의미하고 왜 필요한지.</p>\n<p><strong>정적 분석과 검사</strong> 컴파일 단계에서 코드를 검증하고 오류를 잡아내는 과정.</p>\n<p><strong>코드 생성과 변환</strong> IR 낮추기(Lowering)를 통해 우리가 작성한 코드가 어떻게 변환되는지. Composer 주입, 비교 전파, 그룹 생성 등 실제 최적화 기법들.</p>\n<p>마음의 준비를 하자.\n내용이 많고 기술적인 용어들이 마구 언급되며, 챕터 자체의 분량이 꽤 길다.</p>\n<hr>\n<blockquote>\n<p><strong>IR:</strong> Intermediate Representation, Kotlin 컴파일러가 소스파일을 해석하는 하나의 과정.</p>\n</blockquote>\n<blockquote>\n<p><strong>Compose Compiler:</strong> Kotlin 컴파일러 플러그인. Composable 함수를 변환하는 역할.</p>\n</blockquote>\n<blockquote>\n<p><strong>Composer:</strong> 런타임중 트리의 형태를 빌드하거나 업데이트하는 객체.</p>\n</blockquote>\n<h1 id=\"compose-컴파일러-the-compose-compiler\" style=\"position:relative;\"><a href=\"#compose-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-the-compose-compiler\" aria-label=\"compose 컴파일러 the compose compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 컴파일러 (The Compose compiler)</h1>\n<p>Kotlin 에서 코드 생성이라고 하면 보통 kapt, KSP 를 떠올린다.\n하지만 Compose Compiler 는 KSP 같은 어노테이션 프로세서가 아니라 “Kotlin 컴파일러” 의 플러그인이다.</p>\n<p><strong>둘의 차이:</strong> <br/>\nKSP: 컴파일 전에 실행. 새 코드만 추가 가능. <br/>\n컴파일러 플러그인: 컴파일 중에 실행. 기존 코드 수정 가능. <br/></p>\n<p><a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#%ED%98%B8%EC%B6%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-calling-context\">이전 1장 글에서 봤던 Composer 파라미터 주입</a>\n이 바로 “기존 코드 수정”의 예시다. KSP 로는 불가능.</p>\n<p>Compose Compiler 는 IR (Intermediate Representation) 단계에서 코드를 변환한다.\nIR 은 소스 코드가 최종 결과물로 변환되기 전 중간 단계다.\n이 단계에서 Compose Compiler 는 우리가 작성한 Composable 함수를 Runtime 이 원하는 형태로 마음대로 바꿔버린다.</p>\n<p>예를 들어 우리가 작성한 <code class=\"language-text\">fun Header()</code> 는 컴파일 후에는 <code class=\"language-text\">fun Header($composer: Composer)</code> 로 변환된다.\n이게 IR 변환이다.</p>\n<p>핵심: IR 단계에서 코드를 변환하니까 우리 눈에 안 보이는 일들이 일어날 수 있다.</p>\n<p>@Composable 어노테이션은 단순 마커가 아니다. 함수의 타입 자체를 바꾼다.</p>\n<p>일반 함수 타입: <code class=\"language-text\">(String) -> Unit</code> <br/>\nComposable 함수 타입: <code class=\"language-text\">@Composable (String) -> Unit</code> <br/></p>\n<p>타입이 다르니까 컴파일러가 규칙을 강제할 수 있다.\n일반 함수에서 Composable 함수를 호출하면 컴파일 에러가 나는 이유다.\n그럼 타입을 바꾸면 뭐가 좋은가? Composable 함수에게 “메모리”가 생긴다.</p>\n<p>“메모리”가 생긴다는 의미: @Composable 이 붙으면 그 함수는 다음과 같이 동작하게 된다.</p>\n<p>remember 사용 가능 (값을 기억할 수 있음), Composer 와 슬롯 테이블 사용 가능,\n고유한 ID 를 할당받음 (1장의 위치 기억법), 트리 내 위치를 가짐,\n라이프사이클을 가짐 (recomposition 되어도 상태 유지 가능).</p>\n<p>이 모든 게 “메모리”다.\nComposable 함수가 실행될 때마다 매번 새로 시작하는 게 아니라, 이전 실행을 “기억”하고 있다는 뜻이다.\n결과적으로 Composable 함수는 노드를 방출해서 트리를 구성할 수 있게 된다.</p>\n<p>요약: @Composable 은 타입을 바꾸고, 타입이 바뀌면 메모리를 갖게 되고, 메모리가 있으니까 트리의 일부가 될 수 있다.</p>\n<hr>\n<h1 id=\"compose-어노테이션들-compose-annotations\" style=\"position:relative;\"><a href=\"#compose-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EB%93%A4-compose-annotations\" aria-label=\"compose 어노테이션들 compose annotations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 어노테이션들 (Compose annotations)</h1>\n<p>Compose Compiler가 코드를 변환하려면 먼저 어떤 함수가 Composable인지, 어떤 최적화를 적용해야 하는지 알아야 한다.\n이를 위해 어노테이션을 사용한다.</p>\n<p><strong>Compose Compiler의 작동 시점</strong>: Compose Compiler는 Kotlin 컴파일 과정 중 프론트엔드 단계에서 동작한다.\n이 단계에서 소스 코드를 분석하고 검증한다.</p>\n<p><strong>컴파일러가 확인하는 것들:</strong> <code class=\"language-text\">@Composable</code> 어노테이션이 붙은 함수들을 찾기,\nComposable 함수가 제약을 잘 지키고 있는지 검증 (다른 Composable에서만 호출되는지 등),\n타입 시스템이 Composable 함수를 일반 함수와 다르게 처리하도록 만들기</p>\n<p><strong>추가 어노테이션들</strong>: <code class=\"language-text\">@Composable</code> 외에도 Compose는 여러 어노테이션을 제공한다.\n이 어노테이션들은 특정 상황에서 추가 검사를 하거나 런타임 최적화를 활성화하는 역할을 한다.</p>\n<p>예를 들어 어떤 함수는 결과를 캐싱해도 되고, 어떤 함수는 안정적인 입력만 받아야 하고,\n어떤 함수는 리컴포지션을 Skip해도 된다는 힌트를 컴파일러에게 줄 수 있다.</p>\n<p>이런 어노테이션들은 모두 Compose Runtime 라이브러리에서 제공된다.</p>\n<hr>\n<h1 id=\"composable\" style=\"position:relative;\"><a href=\"#composable\" aria-label=\"composable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Composable</h1>\n<p>가장 중요한 어노테이션이다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9D%98%EB%AF%B8-the-meaning-of-composable-functions\">1장에서 이미 다뤘지만 (Composable 함수의 의미)</a>,\n컴파일러 관점에서 다시 한번 정리한다.</p>\n<p><strong>Compose Compiler vs 어노테이션 프로세서</strong>: 일반적인 어노테이션 프로세서: 새로운 코드만 생성 가능, 기존 코드를 직접 수정할 수 없음.</p>\n<p><strong>Compose Compiler:</strong> IR(중간 표현)을 직접 변환, 기존 코드를 수정할 수 있음.</p>\n<p><code class=\"language-text\">@Composable</code> 어노테이션이 붙으면 컴파일러가 해당 함수를 직접 변환한다.\n가장 중요한 변경은 <strong>함수의 타입이 바뀐다</strong>는 것이다.</p>\n<p><strong>타입 변경으로 얻는 것들</strong>: 타입이 바뀌면 컴파일러가 Composable 함수에 특별한 제약을 강제할 수 있다.\nComposable 함수는 다른 Composable 함수에서만 호출 가능하다는 규칙 같은 것들 말이다.\n하지만 제약만 생기는 게 아니다. <code class=\"language-text\">@Composable</code>을 통해 함수는 “메모리”를 갖게 된다.</p>\n<p><strong>메모리를 가진다는 의미:</strong>\n<code class=\"language-text\">remember</code>를 사용해서 값을 저장하고 재사용할 수 있음,\n<code class=\"language-text\">Composer</code>와 슬롯 테이블을 활용할 수 있음,\n라이프사이클을 가짐 (리컴포지션 되어도 상태 유지 가능),\n고유한 정체성(ID)을 부여받음 (<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#%EC%9C%84%EC%B9%98-%EA%B8%B0%EC%96%B5%EB%B2%95-positional-memoization\">위치 기억법에서 다뤘음</a>),\n노드를 Composition으로 방출할 수 있음,\nCompositionLocals 처리 가능.</p>\n<p><strong>Composable 함수의 본질</strong>: Composable 함수는 데이터를 트리의 노드로 변환한다.\n이 노드가 UI 노드일 수도 있고, 다른 종류의 노드일 수도 있다.\nCompose Runtime은 UI에만 국한되지 않는다.\n범용적인 트리 구조를 다루는 시스템이며, 우리가 어떻게 사용하느냐에 따라 UI가 될 수도, 다른 무언가가 될 수도 있다.</p>\n<hr>\n<h1 id=\"composablecompilerapi\" style=\"position:relative;\"><a href=\"#composablecompilerapi\" aria-label=\"composablecompilerapi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ComposableCompilerApi</h1>\n<p>Compose 컴파일러 전용 API라는 것을 표시하는 어노테이션이다.\n“이건 컴파일러가 내부적으로 쓰는 거니까 일반 개발자는 건드리지 마세요” 라는 경고 표시다.</p>\n<hr>\n<h1 id=\"internalcomposeapi\" style=\"position:relative;\"><a href=\"#internalcomposeapi\" aria-label=\"internalcomposeapi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@InternalComposeApi</h1>\n<p>Compose 내부에서만 사용하는 API라는 표시다.\nKotlin의 <code class=\"language-text\">internal</code> 키워드는 같은 모듈 안에서만 접근 가능하다.\n하지만 Compose는 여러 모듈로 나뉘어 있어서 모듈 간에 내부 API를 공유해야 할 때가 있다.\n<code class=\"language-text\">@InternalComposeApi</code>는 이런 경우에 사용한다.\n“Compose 내부에서는 쓰지만, 외부 개발자는 쓰지 마세요. 언제든 바뀔 수 있어요”라는 의미다.\nstable 버전에 포함되어도 내부 구현은 계속 바뀔 수 있기 때문에 이런 표시가 필요하다.</p>\n<hr>\n<h1 id=\"disallowcomposablecalls\" style=\"position:relative;\"><a href=\"#disallowcomposablecalls\" aria-label=\"disallowcomposablecalls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@DisallowComposableCalls</h1>\n<p>특정 람다 안에서 Composable 함수 호출을 금지하는 어노테이션이다.\n<strong>왜 필요한가?</strong> 대표적인 예시가 <code class=\"language-text\">remember</code>다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span>  <span class=\"token function\">remember</span><span class=\"token punctuation\">(</span>\n    calculation<span class=\"token operator\">:</span> <span class=\"token annotation builtin\">@DisallowComposableCalls</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> T\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> T <span class=\"token operator\">=</span> currentComposer<span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> calculation<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">remember</code>는 <code class=\"language-text\">calculation</code> 람다를 최초 1회만 실행하고 결과를 저장한다.\nrecomposition 시에는 저장된 값을 그냥 반환한다.\n만약 <code class=\"language-text\">calculation</code> 안에서 Composable 함수를 호출하면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> <span class=\"token keyword\">data</span> <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 🚨 만약 가능하다면?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">forEach</code>의 람다는 <code class=\"language-text\">@Composable</code>로 표시되어 있지 않지만,\n<code class=\"language-text\">MyScreen</code>이 Composable이므로 안에서 <code class=\"language-text\">Text</code>를 호출할 수 있다.\n이건 <code class=\"language-text\">forEach</code> 같은 경우에는 유용하지만, <code class=\"language-text\">remember</code> 같은 경우에는 문제가 된다.\n그래서 명시적으로 금지해야 한다.</p>\n<p><strong>전파성</strong>: <code class=\"language-text\">@DisallowComposableCalls</code>가 붙은 람다 안에서 또 다른 inline 람다를 호출하면,\n컴파일러는 그 람다에도 <code class=\"language-text\">@DisallowComposableCalls</code>를 요구한다.\n이 어노테이션은 주로 Compose Runtime 같은 라이브러리를 만들 때 사용한다.\n일반 앱 개발에서는 거의 쓸 일이 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> remember <span class=\"token punctuation\">{</span>\n    list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> item <span class=\"token operator\">-></span> item <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>  <span class=\"token comment\">// map의 람다도 금지됨</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<hr>\n<h1 id=\"readonlycomposable\" style=\"position:relative;\"><a href=\"#readonlycomposable\" aria-label=\"readonlycomposable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ReadOnlyComposable</h1>\n<p><code class=\"language-text\">@ReadOnlyComposable</code> 이 붙은 Composable 함수는 composition 에 쓰지 않고 읽기만 한다는 의미다.\n본문 내 중첩된 모든 Composable 호출에도 적용된다.\n일반적인 Composable 함수는 컴파일러가 본문을 “그룹” 으로 감싸서 방출한다.\n그룹은 나중에 recomposition 할 때 데이터를 어떻게 정리하거나 이동시킬지에 대한 정보를 담고 있다.</p>\n<p><strong>그룹이 뭔가?</strong> 텍스트에서 시작과 끝을 가리키는 두 개의 포인터를 떠올려보자.\n모든 그룹에는 소스 코드 위치 키가 있고, 이 키로 위치 기억법을 적용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">Text</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>둘 다 Text 함수지만 if 와 else 는 서로 다른 고유성을 가진다.\n그룹의 키가 이 고유성을 구분한다.\n이동 가능한 그룹은 고유한 키를 가지고 있어서 부모 그룹 내에서 재정렬될 수 있다.</p>\n<p>그런데 composition 에 쓰이지 않는 Composable 은 데이터가 교체되거나 이동되지 않으므로 그룹이 필요없다.\n@ReadOnlyComposable 은 이런 불필요한 코드 생성을 방지한다.</p>\n<p>실제 예시로는 CompositionLocal 을 통해 읽는 값들이 있다.\nMaterial 라이브러리의 Colors, Typography, isSystemInDarkTheme() 함수, LocalContext, LocalConfiguration 등이다.\n이런 값들은 단순히 읽기만 하지 쓰지 않는다.</p>\n<p>요약: 읽기만 하는 Composable 은 그룹이 필요없으니 성능 최적화를 위해 명시한다.</p>\n<hr>\n<h1 id=\"nonrestartablecomposable\" style=\"position:relative;\"><a href=\"#nonrestartablecomposable\" aria-label=\"nonrestartablecomposable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@NonRestartableComposable</h1>\n<p>@NonRestartableComposable 이 붙으면 해당 Composable 함수는 재시작이 불가능해진다.\n모든 Composable 이 기본적으로 재시작 가능한 건 아니다.\n인라인 Composable 이나 반환 타입이 Unit 이 아닌 Composable 은 원래 재시작할 수 없다.\n이 어노테이션을 추가하면 컴파일러가 recomposition 중에 함수를 재구성하거나 생략하는 데 필요한 보일러플레이트 코드를 생성하지 않는다.\n언제 쓰나? 다른 Composable 에 의해 recomposition 될 가능성이 희박한 경우다.\n논리가 거의 없어서 스스로 invalidation 시키는 게 의미 없는 함수들이다.\n이런 함수는 상위 Composable 에 의해서만 recomposition 되면 충분하다.\n실제 사용 사례는 매우 드물다.\n정확성을 위해 필요한 건 아니지만, 특수한 경우에 성능 최적화 기법으로 사용할 수 있다.</p>\n<p>요약: 재시작이 필요없는 Composable 에 붙여서 불필요한 코드 생성을 방지한다.</p>\n<hr>\n<h1 id=\"stablemarker\" style=\"position:relative;\"><a href=\"#stablemarker\" aria-label=\"stablemarker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@StableMarker</h1>\n<p>Compose Runtime 은 타입의 안정성을 나타내기 위해 몇 가지 어노테이션을 제공한다. <code class=\"language-text\">@StableMarker</code>, <code class=\"language-text\">@Immutable</code>, <code class=\"language-text\">@Stable</code>.</p>\n<p><code class=\"language-text\">@StableMarker</code> 는 <code class=\"language-text\">@Immutable</code> 과 <code class=\"language-text\">@Stable</code> 에 사용되는 메타 어노테이션이다.\n어노테이션을 위한 어노테이션이라고 보면 된다. <code class=\"language-text\">@StableMarker</code> 로 마킹된 타입은 다음 요구 사항을 만족해야 한다.\nequals 결과가 동일한 두 인스턴스에 대해 항상 동일하다,\npublic 프로퍼티가 변경되면 composition 에 알린다,\n모든 public 프로퍼티가 안정적이다.</p>\n<p>이 요구사항을 만족하면 컴파일러가 최적화할 수 있다.\n입력값이 안 바뀌었다는 걸 확신할 수 있으므로 recomposition을 Skip할 수 있다.</p>\n<p><code class=\"language-text\">@Immutable</code> 이나 <code class=\"language-text\">@Stable</code> 로 마킹된 모든 타입도 위 요구 사항을 만족해야 한다.\n둘 다 <code class=\"language-text\">@StableMarker</code> 를 사용하기 때문이다. 중요한 건 이게 컴파일러에게 하는 “약속” 이라는 점이다.\n컴파일 시 유효성 검사를 하지 않는다.\n요구 사항을 충족하는지는 개발자가 책임진다.\n대부분의 경우 Compose Compiler 가 알아서 타입의 안정성을 추론한다.\n굳이 어노테이션을 달지 않아도 컴파일러가 안정적인 타입으로 취급한다는 뜻이다.</p>\n<p>하지만 두 가지 경우엔 명시적으로 달아야 한다.\n<strong>인터페이스나 추상 클래스에서 구현체가 반드시 안정적이어야 한다고 강제하고 싶을 때.</strong>\n이 어노테이션은 컴파일러와의 약속이자 구현을 위한 요구 사항이 된다.\n구현체가 내부적으로 mutable 하지만 public API 는 안정적이어서 안정적인 타입으로 취급하고 싶을 때.\n예를 들어 내부 캐시는 변하지만 외부로 보이는 값은 변하지 않는 경우다.</p>\n<p>요약: <code class=\"language-text\">@StableMarker</code> 는 타입의 안정성을 컴파일러에게 약속하는 메타 어노테이션이다.</p>\n<hr>\n<h1 id=\"immutable\" style=\"position:relative;\"><a href=\"#immutable\" aria-label=\"immutable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Immutable</h1>\n<p>한번 생성되면 절대 변하지 않는 타입을 표시하는 어노테이션이다.\nKotlin의 <code class=\"language-text\">val</code> 보다 강력한 약속으로서 재할당을 막지만, 불변성을 보장하진 않는다.\n<code class=\"language-text\">val</code>로 선언된 프로퍼티가 mutable한 데이터 구조를 참조하면 내용은 바뀔 수 있다.\n<strong><code class=\"language-text\">@Immutable</code>은 이런 <code class=\"language-text\">val</code>보다 훨씬 강력한 불변성의 보장이다.</strong>\n<strong>생성 후 모든 public 프로퍼티가 절대 안 바뀐다는 약속이다.</strong>\nKotlin은 언어 차원에서 불변성을 보장하는 메커니즘이 없기 때문에 이 어노테이션이 필요하다.</p>\n<p>다음 조건을 모두 만족하는 클래스에 사용할 수 있다. <strong>모든 프로퍼티가 <code class=\"language-text\">val</code>, 커스텀 getter가 없음 (매번 다른 값을 반환할 수 있으니까), 모든 프로퍼티가 불변 타입 (primitive 타입 또는 <code class=\"language-text\">@Immutable</code> 타입).</strong>\n대표적인 예시는 모든 프로퍼티가 <code class=\"language-text\">val</code>인 데이터 클래스다.</p>\n<p><strong>최적화 효과</strong>: Compose Runtime은 <code class=\"language-text\">@Immutable</code> 타입을 보면 값이 절대 안 바뀐다고 가정한다.\n이 확신 덕분에 스마트 recomposition과 recomposition Skip 같은 최적화를 적극적으로 할 수 있다.</p>\n<p><strong>@StableMarker와의 관계</strong>: <code class=\"language-text\">@Immutable</code>은 <code class=\"language-text\">@StableMarker</code>를 포함한다.\n불변 타입은 외부로 노출된 값이 절대 변경되지 않기 때문에, <code class=\"language-text\">@StableMarker</code>의 모든 요구사항을 자동으로 만족한다.\n불변 타입은 값이 변경되지 않으므로 composition에게 변경을 알릴 필요도 없다.</p>\n<hr>\n<h1 id=\"stable\" style=\"position:relative;\"><a href=\"#stable\" aria-label=\"stable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Stable</h1>\n<p><code class=\"language-text\">@Immutable</code>보다 약한 약속이다.\n적용 대상에 따라 의미가 달라진다.\n<strong>타입에 적용하는 경우, 타입이 mutable이지만 안정적이라는 표시다.</strong>\n완전히 불변은 아니지만 <code class=\"language-text\">@StableMarker</code>의 요구사항은 만족한다는 의미다.\n다시 한번 정리하면 <code class=\"language-text\">@StableMarker</code>의 요구사항: <strong>equals 일관성, 프로퍼티 변경 시 composition에 알림, 모든 public 프로퍼티가 안정적.</strong></p>\n<p><strong>함수나 프로퍼티에 적용하는 경우</strong>, 같은 입력에 대해 항상 같은 결과를 반환한다는 약속이다.\n이는 함수의 파라미터가 모두 안정적인 타입이거나 primitive 타입일 때만 가능하다.\n대표적인 예시는 public API는 불변처럼 보이지만 내부는 mutable인 경우다.  예를 들어 private한 mutable 상태를 가지고 있지만,\npublic으로 노출되는 API는 불변적으로 동작하거나 <code class=\"language-text\">MutableState</code>로 내부 프로퍼티를 구현했지만,\n외부에서는 읽기 전용으로만 노출되는 경우.</p>\n<p><strong>최적화 효과</strong>: Composable 함수의 모든 파라미터가 안정적인 타입이면,\nCompose는 위치 기억법을 사용해서 이전 호출과 파라미터를 비교한다.\n모든 값이 동일하면 recomposition을 생략한다.</p>\n<p><strong>주의사항</strong>: 이 어노테이션은 컴파일러와의 약속이다.\n요구사항을 만족하지 않는데 어노테이션을 달면 런타임 오류가 발생할 수 있다.\n확신이 없다면 사용하지 않는 것이 좋다.\n대부분의 경우 컴파일러가 자동으로 안정성을 추론하므로 어노테이션 없이도 잘 동작한다.</p>\n<p><strong>@Immutable과의 차이</strong>: 사실 현재는 Compose Compiler는 <code class=\"language-text\">@Immutable</code>과 <code class=\"language-text\">@Stable</code>을 동일하게 취급한다.\n둘 다 스마트 recomposition과 Skip 최적화를 동일하게 활성화한다.\n그럼에도 두 어노테이션이 따로 존재하는 이유는 미래를 위해서다.\n각자 다른 의미를 가지므로, 향후 Compose가 발전하면서 다르게 처리될 수 있다.\n올바른 어노테이션을 사용하면 미래의 최적화 혜택을 받을 수 있다.</p>\n<hr>\n<blockquote>\n<p><strong>라이브 리터럴 (Live Literals):</strong> 코드의 상수 값(문자열, 숫자 등)을 리컴파일 없이 실시간으로 변경할 수 있게 해주는 기능. Android Studio의 Compose 미리보기에서 텍스트나 색상을 수정하면 즉시 반영되는 것이 이 기능 덕분.</p>\n</blockquote>\n<h1 id=\"컴파일러-확장-등록-registering-compiler-extensions\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%ED%99%95%EC%9E%A5-%EB%93%B1%EB%A1%9D-registering-compiler-extensions\" aria-label=\"컴파일러 확장 등록 registering compiler extensions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일러 확장 등록 (Registering Compiler extensions)</h1>\n<p>Compose Compiler 플러그인이 가장 먼저 하는 일은 Kotlin 컴파일러에 자신을 등록하는 것이다.\n<code class=\"language-text\">ComponentRegistrar</code>라는 메커니즘을 사용해서 Kotlin 컴파일 파이프라인에 끼어든다.\n<code class=\"language-text\">ComposeComponentRegistrar</code>가 일련의 컴파일러 익스텐션들을 등록한다.</p>\n<p><strong>익스텐션의 역할:</strong> 라이브러리 사용을 쉽게 만들기, 런타임에 필요한 코드 생성, Composable 함수 변환.\n이 익스텐션들은 Kotlin 컴파일러와 함께 실행된다.</p>\n<p><strong>컴파일러 플래그:</strong> Compose Compiler는 컴파일러 플래그를 통해 추가 기능을 활성화할 수 있다.</p>\n<p><strong>활성화 가능한 기능들:</strong>\n라이브 리터럴 (Live Literals): 코드 수정 시 즉시 반영,\n소스 정보 포함: Android Studio가 composition 검사 가능,\n<code class=\"language-text\">remember</code> 최적화,\nKotlin 버전 호환성 검사 무시,\nIR 변환 과정에서 디버깅용 메서드 생성.\n이런 플래그들을 설정해서 원하는 기능을 켜고 끌 수 있다.</p>\n<hr>\n<h1 id=\"정적-분석-static-analysis\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EB%B6%84%EC%84%9D-static-analysis\" aria-label=\"정적 분석 static analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 분석 (Static analysis)</h1>\n<p>컴파일러 플러그인이 가장 먼저 하는 일은 린팅(linting)이다.\n소스 코드를 스캔해서 잘못된 부분을 찾아내는 작업이다.\nCompose Compiler는 어노테이션이 올바르게 사용되고 있는지 검사한다.\n“올바르게”의 기준은 Compose Runtime이 기대하는 방식이다.</p>\n<p><code class=\"language-text\">@Composable</code> 함수가 일반 함수에서 호출되는지,\n<code class=\"language-text\">@Immutable</code> 타입이 실제로 불변인지,\n<code class=\"language-text\">@DisallowComposableCalls</code> 람다 안에서 Composable을 호출하는지 같은 것들을 검사한다.\n검사는 컴파일러의 프론트엔드 단계에서 한다.\n코드가 IR로 변환되기 전에 먼저 검증한다는 의미다.\n개발자가 빠르게 피드백을 받을 수 있다.</p>\n<hr>\n<h1 id=\"정적-검사기-static-checkers\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EA%B2%80%EC%82%AC%EA%B8%B0-static-checkers\" aria-label=\"정적 검사기 static checkers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 검사기 (Static Checkers)</h1>\n<p>등록된 익스텐션 중 일부는 정적 검사기다.\n개발자가 코드를 작성하는 동안 잘못된 부분을 실시간으로 알려준다.</p>\n<p>Compose Compiler는 함수 호출, 타입, 선언에 대한 검사기를 익스텐션으로 등록한다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#composable-%ED%95%A8%EC%88%98%EC%9D%98-%EC%86%8D%EC%84%B1-properties-of-composable-functions\">1장에서 다룬 Composable 함수의 제약들</a>\n이 검사기들에 의해 검증된다.\n개발자가 요구사항을 위반하면 즉시 IDE에 보고된다.</p>\n<p>Kotlin 컴파일러는 다양한 검사기를 제공한다.\n클래스 인스턴스화, 타입, 함수 호출, deprecated 호출, 계약(contracts), 클로저 캡처, 중위 호출, 코루틴 호출, 연산자 호출 등을 검사할 수 있다.\n컴파일러 플러그인은 이런 검사기들을 활용해서 소스 코드의 모든 요소를 정적 분석하고, 상황에 따라 경고나 오류를 보고한다.</p>\n<p>모든 검사기는 컴파일러의 프론트엔드 단계에서 실행된다.\n속도가 빠르고 CPU를 많이 소모하지 않는다.\n개발자가 코드를 입력하는 동안 무거운 검사가 실행되면 IDE가 버벅이기 때문이다.\n빠르고 가벼운 검사기가 필요하다.</p>\n<hr>\n<blockquote>\n<p><strong>PSI (Program Structure Interface):</strong> Kotlin 컴파일러가 소스 코드의 구조를 표현하는 트리. 함수, 클래스, 변수 등 모든 코드 요소가 노드로 표현됨.</p>\n</blockquote>\n<h1 id=\"호출-검사-call-checks\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%B6%9C-%EA%B2%80%EC%82%AC-call-checks\" aria-label=\"호출 검사 call checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호출 검사 (Call checks)</h1>\n<p>Compose Compiler가 등록한 검사기 중 하나가 호출 검사기다.\nComposable 함수가 올바른 위치에서 호출되는지 검증한다.\n검사기는 PSI 트리를 방문자 패턴으로 탐색한다.\nPSI는 프론트엔드 컴파일러 단계의 언어 구조를 모델링한 것으로, 구문적이고 정적인 코드 이해 방식이다.</p>\n<p>단일 노드만 분석하는 것으론 부족한 경우가 많다.\nComposable 함수가 어디서 호출되는지 알려면 더 넓은 컨텍스트가 필요하기 때문이다.\n컴파일러는 컨텍스트 추적(context trace)을 통해 방문 경로의 정보를 기록하고,\n람다식이나 try/catch 구문 같은 관련 항목들을 탐색한다.</p>\n<p><code class=\"language-text\">@DisallowComposableCalls</code>로 마킹된 람다 내에서 Composable 함수 호출이 발생하면,\n컨텍스트 추적에 정보를 기록하고 IDE에 오류를 보고한다.\n컨텍스트 추적은 전반적인 분석을 위한 정보를 기록할 수 있는 가변 구조다.</p>\n<p>각 Composable 함수 호출마다 컴파일러는 PSI 트리를 방문해서 호출자, 호출자의 호출자를 확인한다.\n모든 요구사항이 충족되었는지 검증하는 것이다.\n호출자는 람다식, 함수, 프로퍼티, try/catch 블록, 클래스, 파일 등 다양할 수 있다.</p>\n<p>인라인 함수도 중요하게 고려된다.\n인라인 람다의 호출자가 Composable이면 그 람다 안에서도 Composable 함수를 호출할 수 있어야 하기 때문이다.\nCompose Compiler는 Composable 함수를 호출하는 모든 인라인 람다가 호출 스택 어딘가에서 Composable 함수로 둘러싸여 있는지 확인한다.</p>\n<p>검사기는 금지만 하는 게 아니다.\n누락된 <code class=\"language-text\">@Composable</code> 어노테이션을 감지하면 개발자에게 추가하도록 제안한다.\nComposable 함수가 람다 내에서 호출되면 그 람다에 <code class=\"language-text\">@Composable</code>을 추가하라고 제안하는 식이다.\n<code class=\"language-text\">@ReadOnlyComposable</code> 어노테이션이 달린 함수는 다른 읽기 전용 Composable만 호출할 수 있다.\n그렇지 않으면 composition에서 읽기만 가능하고 쓰기는 불가능하다는 최적화 계약을 위반하게 된다.</p>\n<p>Jetpack Compose는 Composable 함수의 참조(reference) 사용을 지원하지 않는다.\n이런 사용도 호출 검사에서 차단한다.</p>\n<hr>\n<h1 id=\"타입-검사-type-checks\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EA%B2%80%EC%82%AC-type-checks\" aria-label=\"타입 검사 type checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 검사 (Type checks)</h1>\n<p>함수뿐만 아니라 타입에도 <code class=\"language-text\">@Composable</code> 어노테이션을 달 수 있다.\nCompose Compiler는 타입 추론과 관련된 검사를 수행한다.\n<code class=\"language-text\">@Composable</code> 어노테이션이 달린 타입을 예상했는데 실제로는 어노테이션이 없는 타입이 발견되면 오류를 보고한다.\n오류 메시지는 추론된 타입과 예상되는 타입을 어노테이션과 함께 출력해서 차이점을 명확하게 보여준다.\n함수 호출 검사와 유사한 방식이다.</p>\n<hr>\n<h1 id=\"선언-검사-declaration-checks\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%96%B8-%EA%B2%80%EC%82%AC-declaration-checks\" aria-label=\"선언 검사 declaration checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선언 검사 (Declaration checks)</h1>\n<p>호출 위치와 타입 검사만으론 부족하다.\n엘리먼트의 선언 위치도 검사해야 한다.\n프로퍼티, 프로퍼티 접근자, 함수 선언, 함수 파라미터 같은 것들이 분석 대상이다.\n프로퍼티, getter, 함수는 Composable로 어노테이션 되어 있어도 재정의될 수 있다.\nCompose Compiler는 이런 요소들이 재정의될 때 <code class=\"language-text\">@Composable</code> 어노테이션이 유지되는지 확인해서 일관성을 유지한다.</p>\n<p>Composable 함수가 suspend 함수인지도 검사한다.\nComposable 함수에 suspend는 지원되지 않기 때문이다.\n<a href=\"https://winter-love.dev/composeinternals/1-composable-functions/#suspend-%ED%95%A8%EC%88%98%EC%99%80%EC%9D%98-%EC%9C%A0%EC%82%AC%EC%84%B1-similarities-with-suspend-functions\">1장에서 설명했듯이 (Suspend 함수와의 유사성)</a>\nsuspend와 <code class=\"language-text\">@Composable</code>은 완전히 다른 개념이며 함께 사용할 수 없다.\nmain 함수를 Composable로 만드는 것도 금지된다.\nComposable 프로퍼티의 backing 필드 선언도 금지된다.</p>\n<hr>\n<h1 id=\"진단-제지기-diagnostic-suppression\" style=\"position:relative;\"><a href=\"#%EC%A7%84%EB%8B%A8-%EC%A0%9C%EC%A7%80%EA%B8%B0-diagnostic-suppression\" aria-label=\"진단 제지기 diagnostic suppression permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진단 제지기 (Diagnostic suppression)</h1>\n<p>컴파일러 플러그인은 진단 제지기를 등록해서 특정 상황의 진단을 음소거할 수 있다.\n일반적으로 Kotlin 컴파일러가 허용하지 않는 코드를 생성하거나 지원할 때 필요하다.\nCompose는 <code class=\"language-text\">ComposeDiagnosticSuppressor</code>를 등록해서 일부 언어 제한을 우회한다.\n특수한 유즈 케이스를 활성화하기 위해서다.</p>\n<p><strong>인라인 람다의 어노테이션 제약 우회</strong>. Kotlin은 인라인 람다에 BINARY나 RUNTIME 보존 타입 어노테이션을 사용하는 것을 금지한다.\n인라인 람다는 컴파일 타임에 호출자 쪽으로 인라인 되므로 어디에도 저장되지 않는다.\n따라서 어노테이션을 저장할 대상이 사라진다.</p>\n<p><strong>일반 Kotlin 코드에서는 이런 오류가 발생한다.</strong>\n“해당 람다식은 인라인 된 매개변수이므로, 이 어노테이션은 어디에도 저장할 수 없습니다.”\n하지만 Compose Compiler는 <code class=\"language-text\">@Composable</code> 어노테이션인 경우에만 이 검사를 제지한다.\n덕분에 호출 시점에서 람다에 <code class=\"language-text\">@Composable</code>을 붙일 수 있다.\n인라인 함수를 선언할 때만 <code class=\"language-text\">@Composable</code>을 붙일 필요가 없어진다.\n함수가 더 유연한 계약을 가질 수 있다.</p>\n<p><strong>함수 타입 파라미터 이름 지정 우회</strong>. Kotlin은 함수 타입의 파라미터에 이름을 지정하는 것을 허용하지 않는다.\n하지만 <code class=\"language-text\">@Composable</code>로 어노테이션 된 함수 타입은 가능하다.\n<code class=\"language-text\">@Composable</code> 어노테이션을 제거하면 다음 오류가 발생한다:\n“함수 유형에는 매개변수에 명명하는 것이 허용되지 않습니다.”</p>\n<p><strong>expect 클래스 제약 우회</strong>. Kotlin 멀티플랫폼의 expect 클래스 멤버에도 동일한 제약 완화가 적용된다.\nJetpack Compose는 멀티플랫폼을 목표로 하므로, <code class=\"language-text\">@Composable</code>로 어노테이션 된 expect 함수와 프로퍼티에 대해서 이런 유연성을 허용해야 한다.</p>\n<hr>\n<h1 id=\"런타임-버전-검사-runtime-version-check\" style=\"position:relative;\"><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84-%EB%B2%84%EC%A0%84-%EA%B2%80%EC%82%AC-runtime-version-check\" aria-label=\"런타임 버전 검사 runtime version check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>런타임 버전 검사 (Runtime version check)</h1>\n<p>코드 생성 단계로 넘어가기 전에 실행되는 작업을 보자.\n코드 생성 직전에 가장 먼저 하는 일은 Compose Runtime 버전을 확인하는 것이다.\nCompose Compiler는 지원하는 최소 버전의 Runtime이 필요하다.\nRuntime이 누락되지 않았는지, 버전이 너무 오래되지 않았는지 검사한다.\n각 Compiler 버전은 지원하는 최소 Runtime 버전이 있고, 그보다 높은 여러 버전을 지원한다.</p>\n<p>이것은 두 번째 버전 검사다.\n첫 번째는 Kotlin 컴파일러 버전을 검사하고, 그 다음이 Compose Runtime 버전 검사다.</p>\n<hr>\n<h1 id=\"코드-생성-code-generation\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1-code-generation\" aria-label=\"코드 생성 code generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 생성 (Code generation)</h1>\n<p>마지막으로 Compose Compiler가 코드 생성 단계로 넘어간다.\n이는 어노테이션 프로세서와 컴파일러 플러그인의 공통점이다.\n둘 다 런타임 라이브러리가 사용할 편리한 코드를 생성하거나 합성하는 데 자주 활용된다.</p>\n<hr>\n<h1 id=\"코틀린-ir-the-kotlin-ir\" style=\"position:relative;\"><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0-ir-the-kotlin-ir\" aria-label=\"코틀린 ir the kotlin ir permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코틀린 IR (The Kotlin IR)</h1>\n<p>컴파일러 플러그인은 IR(Intermediate Representation, 중간 표현)에 접근할 수 있다.\nIR은 목표 플랫폼에 대한 최종 코드를 생성하기 전 단계의 언어 표현이다.\n컴파일러 플러그인은 IR을 통해 개발자가 작성한 소스 코드를 수정할 수 있다.\n파라미터를 몰래 교체하고, 새 파라미터를 추가하고, 코드 구조를 재구성할 수 있다.\n이는 Kotlin 컴파일러의 백엔드 단계에서 발생한다.\nCompose가 각 Composable 함수에 <code class=\"language-text\">Composer</code> 파라미터를 주입하는 것도 이 과정에서 일어난다.</p>\n<p>컴파일러 플러그인은 다양한 형태로 코드를 생성할 수 있다.\nJVM만 목표로 한다면 바이트코드를 생성하면 되지만, Kotlin 팀은 모든 플랫폼을 위한 하나의 통합 백엔드를 만들고 있다.\nIR을 생성하는 것이 더 의미 있는 이유다.</p>\n<p>IR은 목표 플랫폼에 관계없이 존재하는 언어 요소의 중간 표현이다.\nIR을 생성하면 Jetpack Compose가 생성하는 코드가 멀티플랫폼이 될 수 있다.\nCompose Compiler 플러그인은 <code class=\"language-text\">IrGenerationExtension</code>의 구현체를 등록해서 IR을 생성한다.\n이는 Kotlin 컴파일러의 공통 IR 백엔드가 제공하는 익스텐션이다.\nKotlin IR에 대한 심도 있는 학습은 이 책의 범위를 벗어난다고 함. (휴…)</p>\n<hr>\n<blockquote>\n<p><strong>낮추기 (Lowering):</strong> 고수준 프로그래밍 개념을 저수준 개념으로 변환하는 작업. 예를 들어 <code class=\"language-text\">for</code> 루프를 <code class=\"language-text\">while</code>과 인덱스 변수로 변환하는 것. 컴파일러가 최종 기계어 생성을 위해 코드를 단순화하는 과정.</p>\n</blockquote>\n<h1 id=\"낮추기-lowering\" style=\"position:relative;\"><a href=\"#%EB%82%AE%EC%B6%94%EA%B8%B0-lowering\" aria-label=\"낮추기 lowering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>낮추기 (Lowering)</h1>\n<p>낮추기(lowering)는 고급 프로그래밍 개념을 더 낮은 수준의 원자적 개념으로 변환하는 작업이다.\n정규화의 한 형태로 이해할 수 있다.\nKotlin IR은 매우 고급 개념을 표현할 수 있다.\n하지만 목표 플랫폼(JVM 바이트코드, 자바스크립트, LLVM IR)으로 변환하려면 가장 낮은 수준의 형태로 변환해야 한다.</p>\n<p>Compose Compiler도 라이브러리가 지원하는 개념의 수준을 낮춰서 런타임이 이해할 수 있는 표현으로 정규화한다.\n이 과정은 Compose Compiler 플러그인의 코드 생성 단계에서 진행된다.\nIR 트리의 모든 엘리먼트를 방문하고 런타임 요구사항에 맞게 IR을 조정한다.</p>\n<p><strong>낮추기 단계에서 일어나는 주요 작업들:</strong></p>\n<p>클래스 안정성 추론과 메타데이터 추가. 런타임이 클래스 안정성을 이해하는 데 필요한 정보를 추가한다.</p>\n<p>라이브 리터럴 변환. 소스 코드의 변경 사항을 리컴파일 없이 런타임에 반영할 수 있도록 라이브 리터럴 표현식을 가변 상태 인스턴스 접근으로 변환한다.</p>\n<p>Composer 파라미터 주입. Composable 함수에 암시적인 Composer 파라미터를 삽입하고, 모든 Composable 호출에 전달한다.</p>\n<p>Composable 함수 본문 래핑. 컨트롤 플로우를 위한 다양한 그룹 생성(교체 가능한 그룹, 이동 가능한 그룹), 디폴트 파라미터 지원 구현, recomposition Skip 학습, 상태 변경 정보 전파 등을 수행한다.</p>\n<hr>\n<h1 id=\"클래스-안정성-추론-inferring-class-stability\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%95%88%EC%A0%95%EC%84%B1-%EC%B6%94%EB%A1%A0-inferring-class-stability\" aria-label=\"클래스 안정성 추론 inferring class stability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 안정성 추론 (Inferring class stability)</h1>\n<p>스마트 recomposition은 Composable의 입력값이 변경되지 않았고 안정적일 때 recomposition을 생략하는 것이다.\n안정성이 중요한 이유는 Compose Runtime이 입력값을 안전하게 읽고 비교할 수 있다는 것을 의미하기 때문이다.</p>\n<p>안정적인 타입의 특성은 세 가지다.\n<strong>equals 호출이 항상 동일한 결과를 반환한다.</strong>\n<strong>프로퍼티 변경 시 composition에 알림을 준다.</strong>\n<strong>모든 public 프로퍼티가 원시 타입이거나 안정적이다.</strong></p>\n<p>원시 타입, String, 함수형 타입은 기본적으로 안정적이다. 불변이기 때문이다.\n불변이 아니어도 <code class=\"language-text\">MutableState</code> 같은 타입은 <code class=\"language-text\">@Stable</code> 어노테이션으로 안정적이라고 표시할 수 있다.\nCompose는 클래스 안정성을 자동으로 추론한다.\n모든 클래스를 방문해서 <code class=\"language-text\">@StabilityInferred</code> 주석과 <code class=\"language-text\">$stable</code> 합성값을 추가한다.\n런타임 시 클래스 안정성을 결정하는 데 사용된다.\n추론 대상은 일반 클래스와 데이터 클래스다. 열거형, 인터페이스, 어노테이션 같은 건 제외된다.\n클래스의 모든 필드가 읽기 전용이고 안정적이면 안정적이라고 추론한다.</p>\n<p>제네릭 타입 매개변수는 런타임에 결정된다.\n<code class=\"language-text\">class Foo&lt;T>(val value: T)</code>에서 Foo의 안정성은 T의 안정성에 의존한다.\nCompose Compiler는 비트마스크를 사용해서 런타임 시 추론한다.\n내부 가변 상태도 클래스를 불안정하게 만든다.\n<code class=\"language-text\">private var count</code> 같은 필드가 있으면 불안정하다.\nCompose Compiler는 보수적으로 추론한다.\n증명할 수 있는 것만 안정적으로 간주한다.\n인터페이스는 구현을 모르므로 불안정하다.\n<code class=\"language-text\">List&lt;T></code>도 가변적인 <code class=\"language-text\">ArrayList</code>로 구현될 수 있으므로 불안정하다.</p>\n<p>개발자가 더 많은 정보를 가지고 있다면 <code class=\"language-text\">@Stable</code> 어노테이션을 명시적으로 표기할 수 있다.</p>\n<hr>\n<h1 id=\"라이브-리터럴-활성화-enabling-live-literals\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%99%9C%EC%84%B1%ED%99%94-enabling-live-literals\" aria-label=\"라이브 리터럴 활성화 enabling live literals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라이브 리터럴 활성화 (Enabling live literals)</h1>\n<p>이 부분의 글은 구현 세부사항에 가까우며 지속적으로 변경될 수 있다.</p>\n<p>라이브 리터럴은 Compose 도구가 미리 보기에서 변경사항을 리컴파일 없이 실시간으로 반영하게 해주는 기능이다.\n컴파일러 플래그로 활성화할 수 있다. v1은 <code class=\"language-text\">liveLiterals</code>, v2는 <code class=\"language-text\">liveLiteralsEnabled</code>다.\nCompose Compiler는 상수 표현식을 <code class=\"language-text\">MutableState</code>에서 값을 읽는 형태로 변환한다.\n런타임은 프로젝트를 리컴파일할 필요 없이 변경사항을 즉시 감지할 수 있다.\n이 변환은 단순히 개발자 경험 개선을 위한 것이다.\n성능에 민감한 코드의 속도를 크게 저하시킬 수 있으므로 릴리스 빌드에서는 절대 활성화하면 안 된다.</p>\n<p>Compose Compiler는 상수 표현식이 사용된 파일마다 <code class=\"language-text\">LiveLiterals$ClassName</code>이라는 싱글톤 클래스를 생성한다.\n각 상수 표현식에 대한 고유 ID를 생성하고, 상수들을 <code class=\"language-text\">MutableState</code> 프로퍼티의 getter를 통해 획득하도록 변환한다.\n런타임은 생성된 키를 이용해서 변환된 상수값을 획득한다.</p>\n<p>예시를 들면,\n원본 코드에서 <code class=\"language-text\">print(\"Hello World\")</code>는 <code class=\"language-text\">print(LiveLiterals$FooKt.getString$...()()</code>로 변환된다.\n<code class=\"language-text\">LiveLiterals$FooKt</code> 싱글톤 안에 <code class=\"language-text\">MutableState</code> 프로퍼티와 getter 함수가 생성된다.\n상수값이 <code class=\"language-text\">MutableState</code>로 래핑되어 실시간으로 변경 감지가 가능해진다.</p>\n<hr>\n<blockquote>\n<p><strong>메모이제이션 (Memoization):</strong> 캐싱의 한 유형. 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 줄임.</p>\n</blockquote>\n<blockquote>\n<p><strong>도넛 홀 스킵 (Donut-hole skipping):</strong> 트리의 중간 레벨을 건너뛰고 실제로 값을 사용하는 말단 노드에서만 recompose하는 최적화. 도넛의 구멍처럼 중간을 건너뛴다는 의미.</p>\n</blockquote>\n<h1 id=\"compose-람다식-기억법-compose-lambda-memoization\" style=\"position:relative;\"><a href=\"#compose-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EA%B8%B0%EC%96%B5%EB%B2%95-compose-lambda-memoization\" aria-label=\"compose 람다식 기억법 compose lambda memoization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 람다식 기억법 (Compose lambda memoization)</h1>\n<p>Composable 함수에 전달된 람다식을 최적화한다.</p>\n<p><strong>Non-composable 람다식</strong>: 값을 캡처하는 람다식은 remember로 자동으로 감싸진다.\n캡처하는 값이 안정적이면 그 값을 기반으로 람다식을 기억한다.\n런타임은 캡처 값이 일치하면 기존 람다식을 재사용한다.\n값을 캡처하지 않는 람다식은 Kotlin이 싱글톤으로 최적화한다.</p>\n<p><strong>Composable 람다식</strong>: Composable 람다식도 기억된다.\n컴파일러가 <code class=\"language-text\">composableLambda()</code> 팩토리 함수로 변환해서 composition에 저장한다.\n값을 캡처하지 않으면 싱글톤으로 최적화된다.\nComposable 람다식은 State처럼 구현되어 **“도넛 홀 스킵”**이 가능하다.\n트리의 높은 위치에서 람다를 업데이트해도, 실제로 사용되는 낮은 위치에서만 recompose한다.</p>\n<hr>\n<p>그림: Composer injection</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABpElEQVR42k1Ru0oDURC9aqXgC9GsGj9DuyhEBGtBsbG1ttNGLANa2ajxGTAiBsTSSpA8drO7ubtkLWIS8yQii6AJRtAkcD2zQcjCYYa555yZnWFCiC7Lsly2bUuEQqEglUqliUwmM8Dow7sDxroqlcpIsVgc7+RSrNfrUi6Xc5EXSyQSg4qifEajUQE0I5HITzKZpPycTEDqJl+fzzccDodNVVUFYgO8FnStWCzWJC15kBeTZbmXc74PnBiGcaRp2iE3jOATV1bZ3tuYJ9T0Tgcbs3MhW7JMvsm5cQHhEfh+AmlISx7kxVKpVH88HrfQqQTk0C0blZXqs/qwNXP5tbHyKMTSvRDzV+/rSfnxOiIrNngvQB4GedKQFpNb5OVMiKkOgACKZ8Cppus3PB5b69stSAu3Ta/3ruFZPM64E6qyrWl6kHgY4lzXdQLlAfIol8u9zg5ReEWXb6AKfIAk0OigfZP2Dv1+/yDeUJZ/EWnnNRjXsLsq8m/ycHZIl8H/T6TT6UnTNCcpZrPZKeRDzpWXRQ/bgSl4uPwoDub+53WCPOjKf3cgdZorW7kbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"\"\n        src=\"/static/bfc10e70c12030487c2ac5ce2383b9dd/37523/1.png\"\n        srcset=\"/static/bfc10e70c12030487c2ac5ce2383b9dd/e9ff0/1.png 180w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/f21e7/1.png 360w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/37523/1.png 720w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/302a4/1.png 1080w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/07a9c/1.png 1440w,\n/static/bfc10e70c12030487c2ac5ce2383b9dd/cbc84/1.png 5160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1 id=\"composer-주입하기-injecting-the-composer\" style=\"position:relative;\"><a href=\"#composer-%EC%A3%BC%EC%9E%85%ED%95%98%EA%B8%B0-injecting-the-composer\" aria-label=\"composer 주입하기 injecting the composer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composer 주입하기 (Injecting the Composer)</h1>\n<p>Compose Compiler가 모든 Composable 함수에 Composer라는 합성 매개변수를 추가한다.\n기존 Composable 함수를 완전히 대체한다.\n이 매개변수는 코드의 모든 Composable 함수 호출에 전달된다.\n트리의 어느 지점에서나 항상 사용할 수 있게 된다.\nComposable 람다식 호출도 포함된다.</p>\n<p>Composer 파라미터를 추가하면 함수의 타입이 변하므로 타입 리매핑 작업도 필요하다.\nComposer 주입 덕분에 모든 하위 트리에서 Composer를 사용할 수 있다.\nComposable 트리를 구체화하고 업데이트된 상태로 유지하는 데 필요한 모든 정보를 제공한다.\nComposable이 아닌 인라인 람다는 변환하지 않는다.\n컴파일 타임에 호출자 쪽으로 인라인되면서 사라지기 때문이다.\nexpect 함수도 변환하지 않는다.\n타입 해결 시 actual 함수로 처리하고, actual 함수를 변환한다.</p>\n<hr>\n<h1 id=\"비교-전파-comparison-propagation\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%90-%EC%A0%84%ED%8C%8C-comparison-propagation\" aria-label=\"비교 전파 comparison propagation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비교 전파 (Comparison propagation)</h1>\n<p>Composable 함수에는 <code class=\"language-text\">$composer</code> 외에 <code class=\"language-text\">$changed</code>라는 매개변수도 추가된다.\n현재 Composable의 입력 매개변수가 이전 composition 이후 변경되었는지 알려주는 메타데이터다.\n런타임은 이를 통해 recomposition을 생략할 수 있다.\n<code class=\"language-text\">$changed</code> 매개변수는 함수의 입력 매개변수 각각에 대한 조건을 비트로 인코딩한다.\n비트 연산으로 처리하는 것이 프로세서 구조상 수월하기 때문이다.\n이 메타데이터 덕분에 부분적인 최적화가 가능하다.</p>\n<p>입력 매개변수가 정적이면 equals() 비교를 생략할 수 있다.\nString 리터럴이나 상수 같은 경우, 컴파일 타임에 값을 알 수 있으므로 런타임에서 비교할 필요가 없다.\n매개변수가 마지막 composition 이후 변경되지 않았거나, 상위 트리에서 이미 비교 작업을 수행했다면 다시 비교할 필요가 없다.\n매개변수 상태는 “확실하게” 변경될 필요가 없는 것으로 간주된다.</p>\n<p>매개변수 상태가 “불확실”한 경우도 있다.\n런타임은 equals()로 매개변수 값을 비교하고 슬롯 테이블에 저장한다.\n이 경우 <code class=\"language-text\">$changed</code>는 디폴트 값인 0이 되고, 런타임에게 모든 매개변수 비교 작업을 수행하도록 지시한다.</p>\n<p>Composable 함수 본문에는 <code class=\"language-text\">$dirty</code> 변수가 추가된다.\n매개변수가 변경되었는지 저장하는 변수다.\n값이 “dirty”로 간주되면 함수 본문을 실행하고 recomposition이 발생한다.\n그렇지 않으면 recomposition을 생략한다.\n입력 상태가 어떻게 변화하는지 정보를 전달하면 계산 시간과 메모리를 절약할 수 있다.\n매개변수를 매번 저장하고 비교하는 것은 슬롯 테이블 공간을 차지하기 때문이다.</p>\n<p>모든 Composable 함수는 트리 아래로 전달된 모든 매개변수에 대한 정보를 전달해야 할 책임이 있다.\n이것을 “비교 전파(comparison propagation)“라고 한다.\n입력값이 변경되었거나, 정적이거나, 무엇이든 매개변수에 대한 정보를 알고 있다면 하위 Composable 함수에게 <code class=\"language-text\">$changed</code>로 전달한다.</p>\n<p><code class=\"language-text\">$changed</code> 비트마스크는 매개변수가 안정적인지 불안정한지도 인코딩한다.\n<code class=\"language-text\">List&lt;T></code> 같은 광범위한 타입도 <code class=\"language-text\">listOf(1, 2)</code> 같은 안정적인 값이면 recomposition을 생략할 수 있다.</p>\n<hr>\n<h1 id=\"디폴트-매개변수-default-parameters\" style=\"position:relative;\"><a href=\"#%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-default-parameters\" aria-label=\"디폴트 매개변수 default parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디폴트 매개변수 (Default parameters)</h1>\n<p>각 Composable 함수에 <code class=\"language-text\">$default</code>라는 메타데이터가 매개변수로 추가된다.\nKotlin의 디폴트 매개변수 기능은 Composable 함수에서 사용할 수 없다.\nComposable 함수는 디폴트 표현식을 함수 범위(생성된 그룹) 내에서 실행해야 하기 때문이다.</p>\n<p>Compose는 이 문제를 해결하기 위한 대안을 제공한다.\n각 매개변수의 인덱스를 비트마스킹으로 매핑하는 <code class=\"language-text\">$default</code> 매개변수를 추가한다.\n<code class=\"language-text\">$changed</code> 매개변수와 동일한 방식이다.\n<code class=\"language-text\">$default</code> 매개변수는 각 입력 매개변수에 대해 호출자가 값을 제공하는지 여부를 알려준다.\n최종적으로 디폴트 값을 사용할지, 호출자가 넘긴 값을 사용할지 결정한다.\n비트마스킹을 통해 확인하고, 호출자가 값을 제공하지 않았으면 디폴트 값을 사용한다.</p>\n<hr>\n<h1 id=\"교체-가능한-그룹-replaceable-groups\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B2%B4-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-replaceable-groups\" aria-label=\"교체 가능한 그룹 replaceable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교체 가능한 그룹 (Replaceable groups)</h1>\n<p>Composable 람다식은 팩토리 함수로 감싸진다.\n팩토리 함수는 키로 교체 가능한 그룹을 시작하고, 람다식 본문을 감싸고, 그룹을 닫는다.\n시작과 끝 호출 사이에서 composition을 관련 정보로 업데이트한다.\nComposable 함수의 호출도 동일하게 처리된다.\n<code class=\"language-text\">@NonRestartableComposable</code>로 재시작 불가능하다고 마킹된 함수도 교체 가능한 그룹을 생성한다.</p>\n<p>그룹은 트리와 같은 구조다.\n각 그룹은 원하는 만큼 자식 그룹을 가질 수 있다.\nComposable 함수가 다른 Composable 함수를 호출하면 컴파일러는 그 함수에도 그룹을 삽입한다.\nComposable 호출은 위치에 기반하기 때문에 정체성이 보존된다.\n조건부 로직의 서로 다른 두 Text 호출은 런타임이 다르다고 이해할 수 있다.\n조건부 논리를 수행하는 Composable 함수도 교체 가능한 그룹을 발행한다.\n조건이 전환되면 교체될 수 있는 그룹을 슬롯 테이블에 저장한다.</p>\n<hr>\n<h1 id=\"이동-가능한-그룹-movable-groups\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%8F%99-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-movable-groups\" aria-label=\"이동 가능한 그룹 movable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이동 가능한 그룹 (Movable groups)</h1>\n<p>이동 가능한 그룹은 정체성을 잃지 않고 재정렬이 가능한 그룹이다.\n<code class=\"language-text\">key</code> 함수 내부에서 Composable 함수를 호출하는 경우에 활용된다.\n<code class=\"language-text\">key</code> 함수로 Composable을 감싸면 고유한 정체성이 보장되고 이동 가능한 그룹이 생성된다.\n각 Composable 함수마다 정체성을 해치지 않으면서 호출 순서를 변경할 수 있다.\n컴파일러는 <code class=\"language-text\">startMovableGroup()</code> / <code class=\"language-text\">endMovableGroup()</code>으로 그룹을 생성한다.\n리스트 중간에 항목이 추가되거나 삭제되어도 각 항목의 정체성이 유지된다.</p>\n<hr>\n<h1 id=\"재시작-가능한-그룹-restartable-groups\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%8B%9C%EC%9E%91-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B7%B8%EB%A3%B9-restartable-groups\" aria-label=\"재시작 가능한 그룹 restartable groups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재시작 가능한 그룹 (Restartable groups)</h1>\n<p>재시작 가능한 그룹은 가장 흥미로운 그룹 중 하나다.\n재시작 가능한 Composable 함수에만 삽입된다.\n재시작 가능한 그룹도 Composable 호출을 감싸지만, end 함수 호출이 약간 다르다.\nnullable한 값을 반환한다.\nComposable 함수가 어떤 상태도 읽지 않으면 null을 반환한다.\nrecomposition이 필요 없다는 의미다.\n런타임에 재구성하는 방법을 가르칠 필요가 없다.</p>\n<p>null이 아닌 값을 반환하면 컴파일러는 람다식을 생성한다.\n이 람다식은 Composable을 “재시작”(다시 실행)하는 방법을 런타임에 가르친다.\n<code class=\"language-text\">endRestartGroup()?.updateScope()</code>로 범위를 갱신해서 recomposition을 트리거한다.\n동일한 새 호출을 감싸고 recomposition 범위를 업데이트한다.\n재시작 가능한 그룹은 상태를 읽는 모든 Composable 함수에 대해 생성된다.</p>\n<p><strong>그룹 생성 규칙</strong>: 블록이 항상 정확하게 1회만 실행되면 그룹이 필요 없다.\n조건부 논리에서 블록 집합 중 하나가 단 한 번 실행되는 경우(if문, when문), 각 블록 주위에 교체 가능한 그룹을 삽입한다.\n이동 가능한 그룹은 key Composable 함수 호출의 본문에서만 사용된다.</p>\n<hr>\n<h1 id=\"klib과-미끼-생성-klib-and-decoy-generation\" style=\"position:relative;\"><a href=\"#klib%EA%B3%BC-%EB%AF%B8%EB%81%BC-%EC%83%9D%EC%84%B1-klib-and-decoy-generation\" aria-label=\"klib과 미끼 생성 klib and decoy generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Klib과 미끼 생성 (Klib and decoy generation)</h1>\n<p>Compose Compiler는 멀티플랫폼(.klib)과 Kotlin/JS를 위한 특별한 지원을 추가했다.\nJS에서는 종속성에 대한 IR이 역직렬화되는 방식 때문에 문제가 생긴다.\nIR이 변환되면 타입 시그니처와 일치하지 않게 된다.\nCompose가 Composable 함수에 합성 매개변수를 추가하기 때문이다.\nJVM에서는 함수의 IR을 직접 교체하지만, Kotlin/JS에서는 다르게 처리한다.\n함수를 교체하는 대신 복사본을 생성한다.</p>\n<p>기존 함수 선언은 유지한 채로 Kotlin 메타데이터의 각 함수와 IR 사이를 연결한다.\n코드의 모든 참조는 여전히 잘 동작한다.\nCompose가 필요에 따라 복사본의 IR을 조정한다.\n런타임에서 기존 함수와 복사본을 구분하기 위해 복사본 함수 이름에 <code class=\"language-text\">$composable</code> 접미사가 추가된다.\n원본 함수는 decoy로 남고 호출되면 예외를 던진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACxklEQVR42k1TaWsTURTNLxZEFCnFVrStYhdtFeqC2FZEBa3d0i1ts0ySyUz2ZJLZskwmW1P9Ivj5eO4Lgh8u83jz3nnnnnNupFNNolW+RNjModfU0WtkMHLSaJpnqGWj8PmvYZzALcZU9RtJ9KzM9CxL7gpGaOfglhKIBPzZracJpKNT13goh4GTg1eOwytdqb12LYVWNY42Lw5dA33H5PmsAgysNAKuQ669chKRgZvH0CugzxcGdhY33SquOxWMvDzGfh43QU1Vn/+GPDvwigqwS3C5M/KLEIwegVtVDZGRncbE1/mChoZ5irp+TGYXZJ0iCw0W27XzZ/jZyasae1nVhTzQNI5R0fZh6UeoZQ7R0KNk6Oi49nOI7e9gaf4uVhZmsP5sXq3l+/rFIrbfrOLP2MKkTYZsObRNxSgkqGgnrQsBnzJFZGPsZnG+t41E9BMcCn/2YwvG1S4Z0xidhpRomp2hBKZqV7WsOtDJVB4wEFBrv5JCpFc+x8jW8PXDOt6/eko2K2Q2h5fL83i78USt15Zm8Wj2NnXN4aZlqET0qZsAt8lKjBlQc08AQzo0cjIoJPZgxndR1A7QtTTEo59R0g5hF2JInnxR+v4KiqomLRMjN6uYqeIDARkrl8NmlkLr+L7zCgsP7mB1cQZz92/h47s1bD5/jI3lh9TzHrY2l/F7WKWOJs9PE6Gy29CVSV22rAB71UsMJKx1Uq8n0K7ElatyqU/d/PIFgxtXJS6PXIaauocOW6Y5cj5gjoduYdqy6DCQHDLMYZPCt8sqhxLUgWNg0qmqkjRI3v7lTqZDBVpCToaipVuky0JVJmBqfXqaMQL3rBS6Ne430mocg7qMnDadDFa7FENA1kFNgKcT48no+cULuBQ8+G+UupUYHIbWNk/gmPwaUbiFU65PGN4jWOl91FO7sJLf4OkHZJeAjHDTjOEvGExu+FyBF9kAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png\"\n        srcset=\"/static/5314d2a18f59617ee9c2723cac41e942/e9ff0/cover.png 180w,\n/static/5314d2a18f59617ee9c2723cac41e942/f21e7/cover.png 360w,\n/static/5314d2a18f59617ee9c2723cac41e942/6af66/cover.png 640w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","frontmatter":{"date":"2025.11.23","title":"2장 - Compose 컴파일러 (The Compose compiler)","categories":"ComposeInternals","author":"Winter","emoji":null},"fields":{"slug":"/composeinternals/2-the-compose-compiler/"}},"site":{"siteMetadata":{"siteUrl":"https://www.winter-love.dev","comments":{"utterances":{"repo":"winter-love-dev/winter-love-dev.github.io"}}}}},"pageContext":{"slug":"/composeinternals/1-composable-functions/","nextSlug":"/life/super-init-v6-review/","prevSlug":"/composeinternals/2-the-compose-compiler/"}},"staticQueryHashes":["1073350324","1321836341","3350743975","339315159","3586530715","988760642"],"slicesMap":{}}